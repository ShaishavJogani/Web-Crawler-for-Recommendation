post1_rec = {
    "response": [{
        "rank": 1,
        "text": "public class Employee {              // This defines the Employee class.\r\n                                     // The public modifier indicates that\r\n                                     // it can be accessed by any other class\r\n\r\n    private static int nextID;       // Define a static field. Only one copy of this will exist,\r\n                                     // no matter how many Employees are created.\r\n\r\n    private int myID;                // Define fields that will be stored  \r\n    private String myName;           // for each Employee. The private modifier indicates that\r\n                                     // only code inside the Employee class can access it.\r\n \r\n    public Employee(String name) {   // This is a constructor. You can pass a name to the constructor\r\n                                     // and it will give you a newly created Employee object.\r\n        myName = name;\r\n        myID = nextID;               // Automatically assign an ID to the object\r\n        nextID++;                    // Increment the ID counter\r\n    }\r\n \r\n    public String getName() {        // This is a member method that returns the\r\n                                     // Employee object's name.\r\n        return myName;               // Note how it can access the private field myName.\r\n    }\r\n \r\n    public int getID() {             // This is another member method.\r\n   \r\n        return myID;  \r\n    }\r\n \r\n    public static int getNextID() {  // This is a static method that returns the next ID\r\n                                     // that will be assigned if another Employee is created.\r\n        return nextID;\r\n    }\r\n}\r\n",
        "title": "Defining Classes_4.1 Employee.java_code.txt",
        "type": "code"
    }, {
        "rank": 2,
        "text": "\r\nA List l may be sorted as follows.\r\n\r\nCollections.sort(l);\r\n\r\nIf the List consists of String elements, it will be sorted into alphabetical order. If it consists of Date elements, it will be sorted into chronological order. How does this happen? String and Date both implement the \r\nComparable interface. Comparable implementations provide a natural ordering for a class, which allows objects of that class to be sorted automatically. The \r\nfollowing table summarizes some of the more important Java platform classes that implement Comparable.\r\n\r\nClasses Implementing Comparable\r\n\r\nClass\r\nNatural Ordering\r\n\r\n\r\nByte\r\nSigned numerical\r\n\r\n\r\nCharacter\r\nUnsigned numerical\r\n\r\n\r\nLong\r\nSigned numerical\r\n\r\n\r\nInteger\r\nSigned numerical\r\n\r\n\r\nShort\r\nSigned numerical\r\n\r\n\r\nDouble\r\nSigned numerical\r\n\r\n\r\nFloat\r\nSigned numerical\r\n\r\n\r\nBigInteger\r\nSigned numerical\r\n\r\n\r\nBigDecimal\r\nSigned numerical\r\n\r\n\r\nBoolean\r\nBoolean.FALSE < Boolean.TRUE\r\n\r\n\r\nFile\r\nSystem-dependent lexicographic on path name\r\n\r\n\r\nString\r\nLexicographic\r\n\r\n\r\nDate\r\nChronological\r\n\r\n\r\nCollationKey\r\nLocale-specific lexicographic\r\n\r\n\r\n\r\nIf you try to sort a list, the elements of which do not implement Comparable, Collections.sort(list) will throw a \r\nClassCastException. Similarly, Collections.sort(list, comparator) will throw a ClassCastException if you try to sort a list whose elements cannot be compared to one another using the comparator. Elements that can be compared to one another are called mutually comparable. Although elements of different types may be mutually comparable, none of the classes listed here permit interclass comparison.\r\nThis is all you really need to know about the Comparable interface if you just want to sort lists of comparable elements or to create sorted collections of them. The next section will be of interest to you if you want to implement your own Comparable type.\r\nWriting Your Own Comparable Types\r\nThe Comparable interface consists of the following method.\r\n\r\npublic interface Comparable<T> {\r\n    public int compareTo(T o);\r\n}\r\n\r\nThe compareTo method compares the receiving object with the specified object and returns a negative integer, 0, or a positive integer depending on whether the receiving object is less than, equal to, or greater than the specified object. If the specified object cannot be compared to the receiving object, the method throws a ClassCastException.\r\nThe \r\nfollowing class representing a person's name implements Comparable.\r\n\r\nimport java.util.*;\r\n\r\npublic class Name implements Comparable<Name> {\r\n    private final String firstName, lastName;\r\n\r\n    public Name(String firstName, String lastName) {\r\n        if (firstName == null || lastName == null)\r\n            throw new NullPointerException();\r\n        this.firstName = firstName;\r\n        this.lastName = lastName;\r\n    }\r\n\r\n    public String firstName() { return firstName; }\r\n    public String lastName()  { return lastName;  }\r\n\r\n    public boolean equals(Object o) {\r\n        if (!(o instanceof Name))\r\n            return false;\r\n        Name n = (Name) o;\r\n        return n.firstName.equals(firstName) && n.lastName.equals(lastName);\r\n    }\r\n\r\n    public int hashCode() {\r\n        return 31*firstName.hashCode() + lastName.hashCode();\r\n    }\r\n\r\n    public String toString() {\r\n\treturn firstName + \" \" + lastName;\r\n    }\r\n\r\n    public int compareTo(Name n) {\r\n        int lastCmp = lastName.compareTo(n.lastName);\r\n        return (lastCmp != 0 ? lastCmp : firstName.compareTo(n.firstName));\r\n    }\r\n}\r\n\r\nTo keep the preceding example short, the class is somewhat limited: It doesn't support middle names, it demands both a first and a last name, and it is not internationalized in any way. Nonetheless, it illustrates the following important points:\r\n\r\nName objects are immutable. All other things being equal, immutable types are the way to go, especially for objects that will be used as elements in Sets or as keys in Maps. These collections will break if you modify their elements or keys while they're in the collection.\r\nThe constructor checks its arguments for null. This ensures that all Name objects are well formed so that none of the other methods will ever throw a NullPointerException.\r\nThe hashCode method is redefined. This is essential for any class that redefines the equals method. (Equal objects must have equal hash codes.)\r\nThe equals method returns false if the specified object is null or of an inappropriate type. The compareTo method throws a runtime exception under these circumstances. Both of these behaviors are required by the general contracts of the respective methods.\r\nThe toString method has been redefined so it prints the Name in human-readable form. This is always a good idea, especially for objects that are going to get put into collections. The various collection types' toString methods depend on the toString methods of their elements, keys, and values.\r\n\r\nSince this section is about element ordering, let's talk a bit more about Name's compareTo method. It implements the standard name-ordering algorithm, where last names take precedence over first names. This is exactly what you want in a natural ordering. It would be very confusing indeed if the natural ordering were unnatural!\r\nTake a look at how compareTo is implemented, because it's quite typical. First, you compare the most significant part of the object (in this case, the last name). Often, you can just use the natural ordering of the part's type. In this case, the part is a String and the natural (lexicographic) ordering is exactly what's called for. If the comparison results in anything other than zero, which represents equality, you're done: You just return the result. If the most significant parts are equal, you go on to compare the next most-significant parts. In this case, there are only two parts â\u20ac\u201d first name and last name. If there were more parts, you'd proceed in the obvious fashion, comparing parts until you found two that weren't equal or you were comparing the least-significant parts, at which point you'd return the result of the comparison.\r\nJust to show that it all works, here's \r\na program that builds a list of names and sorts them.\r\n\r\nimport java.util.*;\r\n\r\npublic class NameSort {\r\n    public static void main(String[] args) {\r\n        Name nameArray[] = {\r\n            new Name(\"John\", \"Smith\"),\r\n            new Name(\"Karl\", \"Ng\"),\r\n            new Name(\"Jeff\", \"Smith\"),\r\n            new Name(\"Tom\", \"Rich\")\r\n        };\r\n\r\n        List<Name> names = Arrays.asList(nameArray);\r\n        Collections.sort(names);\r\n        System.out.println(names);\r\n    }\r\n}\r\n\r\nIf you run this program, here's what it prints.\r\n\r\n[Karl Ng, Tom Rich, Jeff Smith, John Smith]\r\n\r\nThere are four restrictions on the behavior of the compareTo method, which we won't go into now because they're fairly technical and boring and are better left in the API documentation. It's really important that all classes that implement Comparable obey these restrictions, so read the documentation for Comparable if you're writing a class that implements it. Attempting to sort a list of objects that violate the restrictions has undefined behavior. Technically speaking, these restrictions ensure that the natural ordering is a total order on the objects of a class that implements it; this is necessary to ensure that sorting is well defined.\r\nComparators\r\nWhat if you want to sort some objects in an order other than their natural ordering? Or what if you want to sort some objects that don't implement Comparable? To do either of these things, you'll need to provide a \r\nComparator â\u20ac\u201d an object that encapsulates an ordering. Like the Comparable interface, the Comparator interface consists of a single method.\r\n\r\npublic interface Comparator<T> {\r\n    int compare(T o1, T o2);\r\n}\r\n\r\nThe compare method compares its two arguments, returning a negative integer, 0, or a positive integer depending on whether the first argument is less than, equal to, or greater than the second. If either of the arguments has an inappropriate type for the Comparator, the compare method throws a ClassCastException.\r\nMuch of what was said about Comparable applies to Comparator as well. Writing a compare method is nearly identical to writing a compareTo method, except that the former gets both objects passed in as arguments. The compare method has to obey the same four technical restrictions as Comparable's compareTo method for the same reason â\u20ac\u201d a Comparator must induce a total order on the objects it compares.\r\nSuppose you have a class called Employee, as follows.\r\n\r\npublic class Employee implements Comparable<Employee> {\r\n    public Name name()     { ... }\r\n    public int number()    { ... }\r\n    public Date hireDate() { ... }\r\n       ...\r\n}\r\n\r\nLet's assume that the natural ordering of Employee instances is Name ordering (as defined in the previous example) on employee name. Unfortunately, the boss has asked for a list of employees in order of seniority. This means we have to do some work, but not much. The following program will produce the required list.\r\n\r\nimport java.util.*;\r\npublic class EmpSort {\r\n    static final Comparator<Employee> SENIORITY_ORDER = \r\n                                        new Comparator<Employee>() {\r\n            public int compare(Employee e1, Employee e2) {\r\n                return e2.hireDate().compareTo(e1.hireDate());\r\n            }\r\n    };\r\n\r\n    // Employee database\r\n    static final Collection<Employee> employees = ... ;\r\n\r\n    public static void main(String[] args) {\r\n        List<Employee> e = new ArrayList<Employee>(employees);\r\n        Collections.sort(e, SENIORITY_ORDER);\r\n        System.out.println(e);\r\n    }\r\n}\r\n\r\nThe Comparator in the program is reasonably straightforward. It relies on the natural ordering of Date applied to the values returned by the hireDate accessor method. Note that the Comparator passes the hire date of its second argument to its first rather than vice versa. The reason is that the employee who was hired most recently is the least senior; sorting in the order of hire date would put the list in reverse seniority order. Another technique people sometimes use to achieve this effect is to maintain the argument order but to negate the result of the comparison.\r\n\r\n// Don't do this!!\r\nreturn -r1.hireDate().compareTo(r2.hireDate());\r\n\r\nYou should always use the former technique in favor of the latter because the latter is not guaranteed to work. The reason for this is that the compareTo method can return any negative int if its argument is less than the object on which it is invoked. There is one negative int that remains negative when negated, strange as it may seem.\r\n\r\n-Integer.MIN_VALUE == Integer.MIN_VALUE\r\n\r\nThe Comparator in the preceding program works fine for sorting a List, but it does have one deficiency: It cannot be used to order a sorted collection, such as TreeSet, because it generates an ordering that is not compatible with equals. This means that this Comparator equates objects that the equals method does not. In particular, any two employees who were hired on the same date will compare as equal. When you're sorting a List, this doesn't matter; but when you're using the Comparator to order a sorted collection, it's fatal. If you use this Comparator to insert multiple employees hired on the same date into a TreeSet, only the first one will be added to the set; the second will be seen as a duplicate element and will be ignored.\r\nTo fix this problem, simply tweak the Comparator so that it produces an ordering that is compatible with equals. In other words, tweak it so that the only elements seen as equal when using compare are those that are also seen as equal when compared using equals. The way to do this is to perform a two-part comparison (as for Name), where the first part is the one we're interested in â\u20ac\u201d in this case, the hire date â\u20ac\u201d and the second part is an attribute that uniquely identifies the object. Here the employee number is the obvious attribute. This is the Comparator that results.\r\n\r\nstatic final Comparator<Employee> SENIORITY_ORDER = \r\n                                        new Comparator<Employee>() {\r\n    public int compare(Employee e1, Employee e2) {\r\n        int dateCmp = e2.hireDate().compareTo(e1.hireDate());\r\n        if (dateCmp != 0)\r\n            return dateCmp;\r\n\r\n        return (e1.number() < e2.number() ? -1 :\r\n               (e1.number() == e2.number() ? 0 : 1));\r\n    }\r\n};\r\n\r\nOne last note: You might be tempted to replace the final return statement in the Comparator with the simpler:\r\n\r\nreturn e1.number() - e2.number();\r\n\r\nDon't do it unless you're absolutely sure no one will ever have a negative employee number! This trick does not work in general because the signed integer type is not big enough to represent the difference of two arbitrary signed integers. If i is a large positive integer and j is a large negative integer, i - j will overflow and will return a negative integer. The resulting comparator violates one of the four technical restrictions we keep talking about (transitivity) and produces horrible, subtle bugs. This is not a purely theoretical concern; people get burned by it.\r\n",
        "title": "Oracle_Object Ordering.txt",
        "type": "Oracle_"
    }, {
        "rank": 3,
        "text": "\r\nReflection provides three enum-specific APIs:\r\n\r\n\r\nClass.isEnum()\r\nIndicates whether this class represents an enum type\r\n\r\nClass.getEnumConstants()\r\nRetrieves the list of enum constants defined by the enum in the order they're declared\r\n\r\njava.lang.reflect.Field.isEnumConstant()\r\nIndicates whether this field represents an element of an enumerated type\r\n\r\nSometimes it is necessary to dynamically retrieve the list of enum constants; in non-reflective code this is accomplished by invoking the implicitly declared static method \r\nvalues() on the enum. If an instance of an enum type is not available the only way to get a list of the possible values is to invoke \r\nClass.getEnumConstants() since it is impossible to instantiate an enum type.\r\nGiven a fully qualified name, the \r\nEnumConstants example shows how to retrieve an ordered list of constants in an enum using \r\nClass.getEnumConstants().\r\n\r\n\r\nimport java.util.Arrays;\r\nimport static java.lang.System.out;\r\n\r\nenum Eon { HADEAN, ARCHAEAN, PROTEROZOIC, PHANEROZOIC }\r\n\r\npublic class EnumConstants {\r\n    public static void main(String... args) {\r\n\ttry {\r\n\t    Class<?> c = (args.length == 0 ? Eon.class : Class.forName(args[0]));\r\n\t    out.format(\"Enum name:  %s%nEnum constants:  %s%n\",\r\n\t\t       c.getName(), Arrays.asList(c.getEnumConstants()));\r\n\t    if (c == Eon.class)\r\n\t\tout.format(\"  Eon.values():  %s%n\",\r\n\t\t\t   Arrays.asList(Eon.values()));\r\n\r\n        // production code should handle this exception more gracefully\r\n\t} catch (ClassNotFoundException x) {\r\n\t    x.printStackTrace();\r\n\t}\r\n    }\r\n}\r\n\r\nSamples of the output follows. User input is in italics.\r\n\r\n$ java EnumConstants java.lang.annotation.RetentionPolicy\r\nEnum name:  java.lang.annotation.RetentionPolicy\r\nEnum constants:  [SOURCE, CLASS, RUNTIME]\r\n\r\n\r\n$ java EnumConstants java.util.concurrent.TimeUnit\r\nEnum name:  java.util.concurrent.TimeUnit\r\nEnum constants:  [NANOSECONDS, MICROSECONDS, \r\n                  MILLISECONDS, SECONDS, \r\n                  MINUTES, HOURS, DAYS]\r\n\r\nThis example also shows that value returned by \r\nClass.getEnumConstants() is identical to the value returned by invoking values() on an enum type.\r\n\r\n$ java EnumConstants\r\nEnum name:  Eon\r\nEnum constants:  [HADEAN, ARCHAEAN, \r\n                  PROTEROZOIC, PHANEROZOIC]\r\nEon.values():  [HADEAN, ARCHAEAN, \r\n                PROTEROZOIC, PHANEROZOIC]\r\n\r\nSince enums are classes, other information may be obtained using the same Reflection APIs described in the Fields, Methods, and Constructors sections of this trail. The \r\nEnumSpy code illustrates how to use these APIs to get additional information about the enum's declaration. The example uses \r\nClass.isEnum() to restrict the set of classes examined. It also uses \r\nField.isEnumConstant() to distinguish enum constants from other fields in the enum declaration (not all fields are enum constants).\r\n\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Member;\r\nimport java.util.List;\r\nimport java.util.ArrayList;\r\nimport static java.lang.System.out;\r\n\r\npublic class EnumSpy {\r\n    private static final String fmt = \"  %11s:  %s %s%n\";\r\n\r\n    public static void main(String... args) {\r\n\ttry {\r\n\t    Class<?> c = Class.forName(args[0]);\r\n\t    if (!c.isEnum()) {\r\n\t\tout.format(\"%s is not an enum type%n\", c);\r\n\t\treturn;\r\n\t    }\r\n\t    out.format(\"Class:  %s%n\", c);\r\n\r\n\t    Field[] flds = c.getDeclaredFields();\r\n\t    List<Field> cst = new ArrayList<Field>();  // enum constants\r\n\t    List<Field> mbr = new ArrayList<Field>();  // member fields\r\n\t    for (Field f : flds) {\r\n\t\tif (f.isEnumConstant())\r\n\t\t    cst.add(f);\r\n\t\telse\r\n\t\t    mbr.add(f);\r\n\t    }\r\n\t    if (!cst.isEmpty())\r\n\t\tprint(cst, \"Constant\");\r\n\t    if (!mbr.isEmpty())\r\n\t\tprint(mbr, \"Field\");\r\n\r\n\t    Constructor[] ctors = c.getDeclaredConstructors();\r\n\t    for (Constructor ctor : ctors) {\r\n\t\tout.format(fmt, \"Constructor\", ctor.toGenericString(),\r\n\t\t\t   synthetic(ctor));\r\n\t    }\r\n\r\n\t    Method[] mths = c.getDeclaredMethods();\r\n\t    for (Method m : mths) {\r\n\t\tout.format(fmt, \"Method\", m.toGenericString(),\r\n\t\t\t   synthetic(m));\r\n\t    }\r\n\r\n        // production code should handle this exception more gracefully\r\n\t} catch (ClassNotFoundException x) {\r\n\t    x.printStackTrace();\r\n\t}\r\n    }\r\n\r\n    private static void print(List<Field> lst, String s) {\r\n\tfor (Field f : lst) {\r\n \t    out.format(fmt, s, f.toGenericString(), synthetic(f));\r\n\t}\r\n    }\r\n\r\n    private static String synthetic(Member m) {\r\n\treturn (m.isSynthetic() ? \"[ synthetic ]\" : \"\");\r\n    }\r\n}\r\n\r\n\r\n$ java EnumSpy java.lang.annotation.RetentionPolicy\r\nClass:  class java.lang.annotation.RetentionPolicy\r\n     Constant:  public static final java.lang.annotation.RetentionPolicy\r\n                  java.lang.annotation.RetentionPolicy.SOURCE \r\n     Constant:  public static final java.lang.annotation.RetentionPolicy\r\n                  java.lang.annotation.RetentionPolicy.CLASS \r\n     Constant:  public static final java.lang.annotation.RetentionPolicy \r\n                  java.lang.annotation.RetentionPolicy.RUNTIME \r\n        Field:  private static final java.lang.annotation.RetentionPolicy[] \r\n                  java.lang.annotation.RetentionPolicy. [ synthetic ]\r\n  Constructor:  private java.lang.annotation.RetentionPolicy() \r\n       Method:  public static java.lang.annotation.RetentionPolicy[]\r\n                  java.lang.annotation.RetentionPolicy.values() \r\n       Method:  public static java.lang.annotation.RetentionPolicy\r\n                  java.lang.annotation.RetentionPolicy.valueOf(java.lang.String) \r\n\r\nThe output shows that declaration of \r\njava.lang.annotation.RetentionPolicy only contains the three enum constants. The enum constants are exposed as public static final fields. The field, constructor, and methods are compiler generated. The $VALUES field is related to the implementation of the values() method.\r\nNote:Â For various reasons, including support for evolution of the enum type, the declaration order of enum constants is important. \r\nClass.getFields() and \r\nClass.getDeclaredFields() do not make any guarantee that the order of the returned values matches the order in the declaring source code. If ordering is required by an application, use \r\nClass.getEnumConstants().\r\n\r\nThe output for \r\njava.util.concurrent.TimeUnit shows that much more complicated enums are possible. This class includes several methods as well as additional fields declared static final which are not enum constants.\r\n\r\n$ java EnumSpy java.util.concurrent.TimeUnit\r\nClass:  class java.util.concurrent.TimeUnit\r\n     Constant:  public static final java.util.concurrent.TimeUnit\r\n                  java.util.concurrent.TimeUnit.NANOSECONDS\r\n     Constant:  public static final java.util.concurrent.TimeUnit\r\n                  java.util.concurrent.TimeUnit.MICROSECONDS\r\n     Constant:  public static final java.util.concurrent.TimeUnit\r\n                  java.util.concurrent.TimeUnit.MILLISECONDS\r\n     Constant:  public static final java.util.concurrent.TimeUnit\r\n                  java.util.concurrent.TimeUnit.SECONDS\r\n     Constant:  public static final java.util.concurrent.TimeUnit\r\n                  java.util.concurrent.TimeUnit.MINUTES\r\n     Constant:  public static final java.util.concurrent.TimeUnit\r\n                  java.util.concurrent.TimeUnit.HOURS\r\n     Constant:  public static final java.util.concurrent.TimeUnit\r\n                  java.util.concurrent.TimeUnit.DAYS\r\n        Field:  static final long java.util.concurrent.TimeUnit.C0\r\n        Field:  static final long java.util.concurrent.TimeUnit.C1\r\n        Field:  static final long java.util.concurrent.TimeUnit.C2\r\n        Field:  static final long java.util.concurrent.TimeUnit.C3\r\n        Field:  static final long java.util.concurrent.TimeUnit.C4\r\n        Field:  static final long java.util.concurrent.TimeUnit.C5\r\n        Field:  static final long java.util.concurrent.TimeUnit.C6\r\n        Field:  static final long java.util.concurrent.TimeUnit.MAX\r\n        Field:  private static final java.util.concurrent.TimeUnit[] \r\n                  java.util.concurrent.TimeUnit. [ synthetic ]\r\n  Constructor:  private java.util.concurrent.TimeUnit()\r\n  Constructor:  java.util.concurrent.TimeUnit\r\n                  (java.lang.String,int,java.util.concurrent.TimeUnit)\r\n                  [ synthetic ]\r\n       Method:  public static java.util.concurrent.TimeUnit\r\n                  java.util.concurrent.TimeUnit.valueOf(java.lang.String)\r\n       Method:  public static java.util.concurrent.TimeUnit[] \r\n                  java.util.concurrent.TimeUnit.values()\r\n       Method:  public void java.util.concurrent.TimeUnit.sleep(long) \r\n                  throws java.lang.InterruptedException\r\n       Method:  public long java.util.concurrent.TimeUnit.toNanos(long)\r\n       Method:  public long java.util.concurrent.TimeUnit.convert\r\n                  (long,java.util.concurrent.TimeUnit)\r\n       Method:  abstract int java.util.concurrent.TimeUnit.excessNanos\r\n                  (long,long)\r\n       Method:  public void java.util.concurrent.TimeUnit.timedJoin\r\n                  (java.lang.Thread,long) throws java.lang.InterruptedException\r\n       Method:  public void java.util.concurrent.TimeUnit.timedWait\r\n                  (java.lang.Object,long) throws java.lang.InterruptedException\r\n       Method:  public long java.util.concurrent.TimeUnit.toDays(long)\r\n       Method:  public long java.util.concurrent.TimeUnit.toHours(long)\r\n       Method:  public long java.util.concurrent.TimeUnit.toMicros(long)\r\n       Method:  public long java.util.concurrent.TimeUnit.toMillis(long)\r\n       Method:  public long java.util.concurrent.TimeUnit.toMinutes(long)\r\n       Method:  public long java.util.concurrent.TimeUnit.toSeconds(long)\r\n       Method:  static long java.util.concurrent.TimeUnit.x(long,long,long)\r\n\r\n",
        "title": "Oracle_Examining Enums.txt",
        "type": "Oracle_"
    }, {
        "rank": 4,
        "text": "\r\nThe following rules define a simple strategy for creating immutable objects. Not all classes documented as \"immutable\" follow these rules. This does not necessarily mean the creators of these classes were sloppy â\u20ac\u201d they may have good reason for believing that instances of their classes never change after construction. However, such strategies require sophisticated analysis and are not for beginners.\r\n\r\nDon't provide \"setter\" methods â\u20ac\u201d methods that modify fields or objects referred to by fields.\r\nMake all fields final and private.\r\nDon't allow subclasses to override methods. The simplest way to do this is to declare the class as final. A more sophisticated approach is to make the constructor private and construct instances in factory methods.\r\nIf the instance fields include references to mutable objects, don't allow those objects to be changed:\r\n\r\nDon't provide methods that modify the mutable objects.\r\nDon't share references to the mutable objects. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.\r\n\r\n\r\n\r\nApplying this strategy to SynchronizedRGB results in the following steps:\r\n\r\nThere are two setter methods in this class. The first one, set, arbitrarily transforms the object, and has no place in an immutable version of the class. The second one, invert, can be adapted by having it create a new object instead of modifying the existing one.\r\nAll fields are already private; they are further qualified as final.\r\nThe class itself is declared final.\r\nOnly one field refers to an object, and that object is itself immutable. Therefore, no safeguards against changing the state of \"contained\" mutable objects are necessary.\r\n\r\nAfter these changes, we have \r\nImmutableRGB:\r\n\r\n\r\nfinal public class ImmutableRGB {\r\n\r\n    // Values must be between 0 and 255.\r\n    final private int red;\r\n    final private int green;\r\n    final private int blue;\r\n    final private String name;\r\n\r\n    private void check(int red,\r\n                       int green,\r\n                       int blue) {\r\n        if (red < 0 || red > 255\r\n            || green < 0 || green > 255\r\n            || blue < 0 || blue > 255) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n    }\r\n\r\n    public ImmutableRGB(int red,\r\n                        int green,\r\n                        int blue,\r\n                        String name) {\r\n        check(red, green, blue);\r\n        this.red = red;\r\n        this.green = green;\r\n        this.blue = blue;\r\n        this.name = name;\r\n    }\r\n\r\n\r\n    public int getRGB() {\r\n        return ((red << 16) | (green << 8) | blue);\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public ImmutableRGB invert() {\r\n        return new ImmutableRGB(255 - red,\r\n                       255 - green,\r\n                       255 - blue,\r\n                       \"Inverse of \" + name);\r\n    }\r\n}\r\n\r\n",
        "title": "Oracle_A Strategy for Defining Immutable Objects.txt",
        "type": "Oracle_"
    }, {
        "rank": 5,
        "text": "\r\nThe following topics are covered:\r\n\r\nIntroduction\r\nDictionary Service Example\r\nRunning the DictionaryServiceDemo Sample\r\nCompiling and Running the DictionaryServiceDemo Sample\r\nUnderstanding the DictionaryServiceDemo Sample\r\n\r\nDefine the Service Provider Interface\r\nDefine the Service That Retrieves the Service Provider Implementations\r\n\r\nThe Singleton Design Pattern\r\n\r\n\r\nImplement the Service Provider\r\nRegister Service Providers\r\nCreate a Client That Uses the Service and Service Providers\r\nPackage the Service Providers, the Service, and the Service Client in JAR Files\r\n\r\nPackaging Service Providers in JAR Files\r\nPackaging the Dictionary SPI and Dictionary Service in a JAR File\r\nPackaging the Client in a JAR File\r\n\r\n\r\nRun the Client\r\n\r\n\r\nThe ServiceLoader Class\r\nLimitations of the ServiceLoader API\r\nSummary\r\n\r\nIntroduction\r\nAn extensible application is one that you can extend without modifying its original code base. You can enhance its functionality with new plug-ins or modules. Developers, software vendors, and customers can add new functionality or application programming interfaces (APIs) by adding a new Java Archive (JAR) file onto the application class path or into an application-specific extension directory. \r\nThis section describes how to create applications with extensible services, which enable you or others to provide service implementations that require no modifications to the original application. By designing an extensible application, you provide a way to upgrade or enhance specific parts of a product without changing the core application. \r\nOne example of an extensible application is a word processor that allows the end user to add a new dictionary or spelling checker. In this example, the word processor provides a dictionary or spelling feature that other developers, or even customers, can extend by providing their own implementation of the feature.\r\nThe following are terms and definitions important to understand extensible applications:\r\n\r\nService\r\nA set of programming interfaces and classes that provide access to some specific application functionality or feature. The service can define the interfaces for the functionality and a way to retrieve an implementation. In the word-processor example, a dictionary service can define a way to retrieve a dictionary and the definition of a word, but it does not implement the underlying feature set. Instead, it relies on a service provider to implement that functionality.\r\nService provider interface (SPI)\r\nThe set of public interfaces and abstract classes that a service defines. The SPI defines the classes and methods available to your application.\r\nService Provider\r\nImplements the SPI. An application with extensible services enable you, vendors, and customers to add service providers without modifying the original application.\r\n\r\nDictionary Service Example\r\nConsider how you might design a dictionary service in a word processor or editor. One way is to define a service represented by a class named DictionaryService and a service provider interface named Dictionary. The DictionaryService provides a singleton DictionaryService object. (See the section The Singleton Design Pattern for more information.) This object retrieves definitions of words from Dictionary providers. Dictionary service clients â\u20ac\u201d your application code â\u20ac\u201d retrieve an instance of this service, and the service will search, instantiate, and use Dictionary service providers.\r\nAlthough the word-processor developer would most likely provide a basic, general dictionary with the original product, the customer might require a specialized dictionary, perhaps containing legal or technical terms. Ideally, the customer is able to create or purchase new dictionaries and add them to the existing application.\r\n\r\nThe DictionaryServiceDemo sample shows you how to implement a Dictionary service, create Dictionary service providers that add additional dictionaries, and create a simple Dictionary service client that tests the service. This sample, which is packaged in the zip file DictionaryServiceDemo.zip, consists of the following files:\r\n\r\n\r\n\r\n\r\nbuild.xml \r\nDictionaryDemo\r\n\r\n\r\nbuild.xml \r\nbuild\r\ndist\r\n\r\nDictionaryDemo.jar\r\n\r\n\r\nsrc\r\n\r\ndictionary\r\n\r\n\r\nDictionaryDemo.java \r\n\r\n\r\n\r\n\r\n\r\n\r\nDictionaryServiceProvider\r\n\r\n\r\nbuild.xml \r\nbuild\r\ndist\r\n\r\nDictionaryServiceProvider.jar\r\n\r\n\r\nsrc\r\n\r\ndictionary\r\n\r\n\r\nDictionaryService.java \r\nspi\r\n\r\n\r\nDictionary.java \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nExtendedDictionary\r\n\r\n\r\nbuild.xml \r\nbuild\r\ndist\r\n\r\nExtendedDictionary.jar\r\n\r\n\r\nsrc\r\n\r\ndictionary\r\n\r\n\r\nExtendedDictionary.java \r\n\r\n\r\nMETA-INF\r\n\r\nservices\r\n\r\n\r\ndictionary.spi.Dictionary \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nGeneralDictionary\r\n\r\n\r\nbuild.xml \r\nbuild\r\ndist\r\n\r\nGeneralDictionary.jar\r\n\r\n\r\nsrc\r\n\r\ndictionary\r\n\r\n\r\nGeneralDictionary.java \r\n\r\n\r\nMETA-INF\r\n\r\nservices\r\n\r\n\r\ndictionary.spi.Dictionary \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nNote: The build directories contain the compiled class files of the Java source files contained in the src directory in the same level.\r\nRunning the DictionaryServiceDemo Sample\r\nBecause the zip file DictionaryServiceDemo.zip contains compiled class files, you can unzip this file to your computer and run the sample without compiling it by following these steps:\r\n\r\n\r\n\r\n    Download and unzip the sample code: Download and unzip the file DictionaryServiceDemo.zip to your computer. It is These steps assume that you unzipped the contents of this file into the directory C:\\DictionaryServiceDemo.\r\n\r\n    \r\n\r\n\r\nChange the current directory to C:\\DictionaryServiceDemo\\DictionaryDemo and follow the step Run the Client.\r\n\r\n\r\nCompiling and Running the DictionaryServiceDemo Sample\r\nThe DictionaryServiceDemo sample includes Apache Ant build files, which are all named build.xml. The following steps show you how to use Apache Ant to compile, build, and run the DictionaryServiceDemo sample:\r\n\r\nInstall Apache Ant: Go to the following link to download and install Apache Ant:\r\nhttp://ant.apache.org/\r\nEnsure that the directory that contains the Apache Ant executable file is in your PATH environment variable so that you can run it from any directory. In addition, ensure that your JDK's bin directory, which contains the java and javac executables (java.exe and javac.exe for Microsoft Windows). is in your PATH environment variable. See\r\nPATH and CLASSPATH  for information about setting the PATH environment variable.\r\n\r\n\r\n    Download and unzip the sample code: Download and unzip the file DictionaryServiceDemo.zip to your computer. These steps assume that you unzipped the contents of this file into the directory C:\\DictionaryServiceDemo.\r\n  \r\n    \r\n\r\n\r\nCompile the code: Change the current directory to C:\\DictionaryServiceDemo and run the following command:\r\nant compile-all\r\nThis command compiles the source code in the src directories contained in the directories DictionaryDemo, DictionaryServiceProvider, ExtendedDictionary, and GeneralDictionary, and puts the generated class files in the corresponding build directories.\r\n\r\n\r\nPackage the compiled Java files into JAR files: Ensure the current directory is C:\\DictionaryServiceDemo and run the following command:\r\nant jar\r\nThis command creates the following JAR files:\r\n\r\nDictionaryDemo/dist/DictionaryDemo.jar\r\nDictionaryServiceProvider/dist/DictionaryServiceProvider.jar\r\nGeneralDictionary/dist/GeneralDictionary.jar\r\nExtendedDictionary/dist/ExtendedDictionary.jar\r\n\r\n\r\n\r\nRun the sample: Ensure that the directory that contains the java executable is in your PATH environment variable. See\r\nPATH and CLASSPATH     for more information.\r\nChange the current directory to C:\\DictionaryServiceDemo\\DictionaryDemo and run the following command:\r\nant run\r\nThe sample prints the following:\r\nbook: a set of written or printed pages, usually bound with a protective covereditor: a person who editsxml: a document standard often used in web services, among other thingsREST: an architecture style for creating, reading, updating, and deleting data that attempts to use the common vocabulary of the HTTP protocol; Representational State Transfer\r\n\r\n\r\nUnderstanding the DictionaryServiceDemo Sample\r\n\r\n    The following steps show you how to re-create the contents of the file DictionaryServiceDemo.zip. These steps show you how the sample works and how to run it.\r\n \r\n\r\n1. Define the Service Provider Interface\r\nThe DictionaryServiceDemo sample defines one SPI, the\r\nDictionary.java interface. It contains only one method:\r\n\r\n\r\n\r\npackage dictionary.spi;\r\n\r\n\r\n\r\npublic interface Dictionary {\r\n\r\n    public String getDefinition(String word);\r\n\r\n}\r\n\r\n\r\nThe sample stores the compiled class file in the directory DictionaryServiceProvider/build.\r\n2. Define the Service That Retrieves the Service Provider Implementations\r\nThe\r\nDictionaryService.java class loads and accesses available Dictionary service providers on behalf of dictionary service clients:\r\n\r\n\r\n\r\npackage dictionary;\r\n\r\n\r\n\r\nimport dictionary.spi.Dictionary;\r\n\r\nimport java.util.Iterator;\r\n\r\nimport java.util.ServiceConfigurationError;\r\n\r\nimport java.util.ServiceLoader;\r\n\r\n\r\n\r\npublic class DictionaryService {\r\n\r\n\r\n\r\n    private static DictionaryService service;\r\n\r\n    private ServiceLoader<Dictionary> loader;\r\n\r\n\r\n\r\n    private DictionaryService() {\r\n\r\n        loader = ServiceLoader.load(Dictionary.class);\r\n\r\n    }\r\n\r\n\r\n\r\n    public static synchronized DictionaryService getInstance() {\r\n\r\n        if (service == null) {\r\n\r\n            service = new DictionaryService();\r\n\r\n        }\r\n\r\n        return service;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    public String getDefinition(String word) {\r\n\r\n        String definition = null;\r\n\r\n\r\n\r\n        try {\r\n\r\n            Iterator<Dictionary> dictionaries = loader.iterator();\r\n\r\n            while (definition == null && dictionaries.hasNext()) {\r\n\r\n                Dictionary d = dictionaries.next();\r\n\r\n                definition = d.getDefinition(word);\r\n\r\n            }\r\n\r\n        } catch (ServiceConfigurationError serviceError) {\r\n\r\n            definition = null;\r\n\r\n            serviceError.printStackTrace();\r\n\r\n\r\n\r\n        }\r\n\r\n        return definition;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\nThe sample stores the compiled class file in the directory DictionaryServiceProvider/build.\r\nThe\r\nDictionaryService class implements the singleton design pattern. This means that only a single instance of the DictionaryService class is ever created. See the section The Singleton Design Pattern for more information.\r\nThe DictionaryService class is the dictionary service client's  entry point to using any installed Dictionary service provider. Use the\r\nServiceLoader.load method to retrieve the private static member DictionaryService.service, the singleton service entry point. Then the application can call the getDefinition method, which iterates through available Dictionary providers until it finds the targeted word. The getDefinition method returns null if no Dictionary instance contains the specified definition of the word.\r\nThe dictionary service uses the ServiceLoader.load method to find the target class. The SPI is defined by the interface dictionary.spi.Dictionary, so the example uses this class as the load method's argument. The default load method searches the application class path with the default class loader.\r\nHowever, an overloaded version of this method enables you to specify \r\ncustom class loaders if you wish. That enables you to do more \r\nsophisticated class searches. A particularly enthusiastic programmer \r\nmight, for example, create a\r\nClassLoader instance that can search in an application-specific subdirectory that contains \r\nprovider JARs added during runtime. The result is an application \r\nthat does not require a restart to access new provider classes.\r\nAfter a loader for this class exists, you can use its iterator method to access and use each provider that it finds. The getDefinition method uses a Dictionary iterator to go through the providers until it finds a definition for the specified word. The iterator method caches Dictionary instances, so successive calls require little additional processing time. If new providers have been placed into service since the last invocation, the iterator method adds them to the list.\r\nThe\r\nDictionaryDemo.java class uses this service. To use the service, the application obtains a DictionaryService instance and calls the getDefinition method. If a definition is available, the application prints it. If a definition is not available, the application prints a message stating that no available dictionary carries the word.\r\nThe Singleton Design Pattern\r\nA design pattern is a general solution to a common problem in software design. The idea is that the solution gets translated into code, and that code can be applied in different situations where the problem occurs. The singleton pattern describes a technique to ensure that only a single instance of a class is ever created. In essence, the technique takes the following approach: Do not let anyone outside the class create instances of the object.\r\nFor example, the\r\nDictionaryService class implements the singleton pattern as follows:\r\n\r\nDeclares the DictionaryService constructor as private, which prevents all other classes, except DictionaryService, from creating instances of it.\r\nDefines the DictionaryService member variable service as static, which ensures only one instance of DictionaryService exists.\r\nDefines the method getInstance, which enables other classes controlled access to the DictionaryService member variable service.\r\n\r\n3. Implement the Service Provider\r\nTo provide this service, you must create a\r\nDictionary.java implementation. To keep things simple, create a general dictionary that defines just a few words. You can implement the dictionary with a database, a set of property files, or any other technology. The easiest way to demonstrate the provider pattern is to include all the words and definitions within a single file. \r\nThe following code shows an implementation of the Dictionary SPI, the\r\nGeneralDictionary.java class. Notice that it provides a no-argument constructor and implements the getDefinition method defined by the SPI.\r\n\r\n\r\n\r\npackage dictionary;\r\n\r\n\r\n\r\nimport dictionary.spi.Dictionary;\r\n\r\nimport java.util.SortedMap;\r\n\r\nimport java.util.TreeMap;\r\n\r\n\r\n\r\npublic class GeneralDictionary implements Dictionary {\r\n\r\n\r\n\r\n    private SortedMap<String, String> map;\r\n\r\n    \r\n\r\n    public GeneralDictionary() {\r\n\r\n        map = new TreeMap<String, String>();\r\n\r\n        map.put(\r\n\r\n            \"book\",\r\n\r\n            \"a set of written or printed pages, usually bound with \" +\r\n\r\n                \"a protective cover\");\r\n\r\n        map.put(\r\n\r\n            \"editor\",\r\n\r\n            \"a person who edits\");\r\n\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n\r\n    public String getDefinition(String word) {\r\n\r\n        return map.get(word);\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\nThe sample stores the compiled class file in the directory GeneralDictionary/build. Note: You must compile the classes dictionary.DictionaryService and dictionary.spi.Dictionary before the class GeneralDictionary.\r\nThe GeneralDictionary provider for this example defines just two words: book and editor. Obviously, a more usable dictionary would provide a more substantial list of generally used vocabulary.\r\nTo demonstrate how multiple providers can implement the same SPI, the following code shows yet another possible provider. The\r\nExtendedDictionary.java service provider is an extended dictionary containing technical terms familiar to most software developers. \r\n\r\n\r\n\r\npackage dictionary;\r\n\r\n\r\n\r\nimport dictionary.spi.Dictionary;\r\n\r\nimport java.util.SortedMap;\r\n\r\nimport java.util.TreeMap;\r\n\r\n\r\n\r\npublic class ExtendedDictionary implements Dictionary {\r\n\r\n\r\n\r\n        private SortedMap<String, String> map;\r\n\r\n\r\n\r\n    public ExtendedDictionary() {\r\n\r\n        map = new TreeMap<String, String>();\r\n\r\n        map.put(\r\n\r\n            \"xml\",\r\n\r\n            \"a document standard often used in web services, among other \" +\r\n\r\n                \"things\");\r\n\r\n        map.put(\r\n\r\n            \"REST\",\r\n\r\n            \"an architecture style for creating, reading, updating, \" +\r\n\r\n                \"and deleting data that attempts to use the common \" +\r\n\r\n                \"vocabulary of the HTTP protocol; Representational State \" +\r\n\r\n                \"Transfer\");\r\n\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n\r\n    public String getDefinition(String word) {\r\n\r\n        return map.get(word);\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\nThe sample stores the compiled class file in the directory ExtendedDictionary/build. Note: You must compile the classes dictionary.DictionaryService and dictionary.spi.Dictionary before the class ExtendedDictionary.\r\nIt is easy to imagine customers using a complete set of Dictionary providers for their own special needs. The service loader API enables them to add new dictionaries to their application as their needs or preferences change. Because the underlying word-processor \r\napplication is extensible, no additional coding is required for customers to use the new providers.\r\n4. Register Service Providers\r\nTo register your service provider, you create a provider configuration file, which is stored in the META-INF/services directory of the service provider's JAR file. The name of the configuration file is the fully qualified class name of the service provider, in which each component of the name is separated by a period (.), and nested classes are separated by a dollar sign ($).\r\nThe provider configuration file contains the fully qualified class names of your service providers, one name per line. The file must be UTF-8 encoded. Additionally, you can include comments in the file by beginning the comment line with the number sign (#).\r\nFor example, to register the service provider GeneralDictionary create a text file named\r\ndictionary.spi.Dictionary . This file contains one line:\r\n\r\ndictionary.GeneralDictionary\r\n\r\nSimilarly, to register the service provider ExtendedDictionary  create a text file named \r\ndictionary.spi.Dictionary . This file contains one line:\r\n\r\ndictionary.ExtendedDictionary\r\n\r\n5. Create a Client That Uses the Service and Service Providers\r\nBecause developing a full word-processor application is a \r\nsignificant undertaking, this tutorial provides a simpler application that uses the DictionaryService and Dictionary SPI. The DictionaryDemo sample searches for the words book, editor, xml, and REST words from any Dictionary providers on the class path and retrieves their definitions.\r\nThe following is the\r\nDictionaryDemo sample. It requests a definition of the target word from the DictionaryService instance, which passes the request to its known Dictionary providers.\r\n\r\n\r\npackage dictionary;\r\n\r\nimport dictionary.DictionaryService;\r\n\r\npublic class DictionaryDemo {\r\n\r\n  public static void main(String[] args) {\r\n\r\n    DictionaryService dictionary = DictionaryService.getInstance();\r\n    System.out.println(DictionaryDemo.lookup(dictionary, \"book\"));\r\n    System.out.println(DictionaryDemo.lookup(dictionary, \"editor\"));\r\n    System.out.println(DictionaryDemo.lookup(dictionary, \"xml\"));\r\n    System.out.println(DictionaryDemo.lookup(dictionary, \"REST\"));\r\n  }\r\n\r\n  public static String lookup(DictionaryService dictionary, String word) {\r\n    String outputString = word + \": \";\r\n    String definition = dictionary.getDefinition(word);\r\n    if (definition == null) {\r\n      return outputString + \"Cannot find definition for this word.\";\r\n    } else {\r\n      return outputString + definition;\r\n    }\r\n  }\r\n}\r\n\r\nThe sample stores the compiled class file in the directory DictionaryDemo/build. Note: You must compile the classes dictionary.DictionaryService and dictionary.spi.Dictionary before the class DictionaryDemo.\r\n6. Package the Service Providers, the Service, and the Service Client in JAR Files\r\nSee the lesson\r\nPackaging Programs in JAR Files for information about how to create JAR files.\r\nPackaging Service Providers in JAR Files\r\nTo package the GeneralDictionary service provider, create a JAR file named GeneralDictionary/dist/GeneralDictionary.jar that contains the compiled class file of this service provider and the configuration file in the following directory structure:\r\n\r\nMETA-INF\r\n\r\nservices\r\n\r\ndictionary.spi.Dictionary\r\n\r\n\r\n\r\n\r\ndictionary\r\n\r\nGeneralDictionary.class\r\n\r\n\r\n\r\nSimilarly, to package the ExtendedDictionary service provider, create a JAR file named ExtendedDictionary/dist/ExtendedDictionary.jar that contains the compiled class file of this service provider and the configuration file in the following directory structure:\r\n\r\nMETA-INF\r\n\r\nservices\r\n\r\ndictionary.spi.Dictionary\r\n\r\n\r\n\r\n\r\ndictionary\r\n\r\nExtendedDictionary.class\r\n\r\n\r\n\r\nNote that the provider configuration file must be in the directory META-INF/services in the JAR file.\r\nPackaging the Dictionary SPI and Dictionary Service in a JAR File\r\nCreate a JAR file named DictionaryServiceProvider/dist/DictionaryServiceProvider.jar that contains the following files:\r\n\r\ndictionary\r\n\r\nDictionaryService.class\r\nspi\r\n\r\nDictionary.class\r\n\r\n\r\n\r\n\r\n\r\nPackaging the Client in a JAR File\r\nCreate a JAR file named DictionaryDemo/dist/DictionaryDemo.jar that contains the following file:\r\n\r\ndictionary\r\n\r\nDictionaryDemo.class\r\n\r\n\r\n\r\n7. Run the Client\r\nThe following command runs the DictionaryDemo sample with the GeneralDictionary service provider:\r\nLinux and Solaris:\r\njava -Djava.ext.dirs=../DictionaryServiceProvider/dist:../GeneralDictionary/dist -cp dist/DictionaryDemo.jar dictionary.DictionaryDemo\r\nWindows:\r\njava -Djava.ext.dirs=..\\DictionaryServiceProvider\\dist;..\\GeneralDictionary\\dist -cp dist\\DictionaryDemo.jar dictionary.DictionaryDemo\r\nWhen using this command, the following is assumed:\r\n\r\nThe current directory is DictionaryDemo.\r\nThe following JAR files exist:\r\n    \r\nDictionaryDemo/dist/DictionaryDemo.jar: Contains the DictionaryDemo class\r\nDictionaryServiceProvider/dist/DictionaryServiceProvider.jar: Contains the Dictionary SPI and the DictionaryService class\r\nGeneralDictionary/dist/GeneralDictionary.jar: Contains the GeneralDictionary service provider and configuration file\r\n\r\n\r\n\r\nThe command prints the following:\r\n\r\nbook: a set of written or printed pages, usually bound with a protective cover\r\neditor: a person who edits\r\nxml: Cannot find definition for this word.\r\nREST: Cannot find definition for this word.\r\n\r\nSuppose you run the following command and ExtendedDictionary/dist/ExtendedDictionary.jar exists:\r\nLinux and Solaris:\r\njava -Djava.ext.dirs=../DictionaryServiceProvider/dist:../ExtendedDictionary/dist -cp dist/DictionaryDemo.jar dictionary.DictionaryDemo\r\nWindows:\r\njava -Djava.ext.dirs=..\\DictionaryServiceProvider\\dist;..\\ExtendedDictionary\\dist -cp dist\\DictionaryDemo.jar dictionary.DictionaryDemo\r\nThe command prints the following:\r\n\r\nbook: Cannot find definition for this word.\r\neditor: Cannot find definition for this word.\r\nxml: a document standard often used in web services, among other things\r\nREST: an architecture style for creating, reading, updating, and deleting data that attempts to use the common vocabulary of the HTTP protocol; Representational State Transfer\r\n\r\nThe ServiceLoader Class\r\nThe java.util.ServiceLoader class helps you find, load, and use service providers. It searches for service providers on your application's class path or in your runtime environment's extensions directory. It loads them and enables your application to use the provider's APIs. If you add new providers to the class path or runtime extension directory, the ServiceLoader class finds them. If your application knows the provider interface, it can find and use different implementations of that interface. You can use the first loadable instance of the interface or iterate through all the available interfaces.\r\nThe ServiceLoader class is final, which means that you cannot make it a subclass or override its loading algorithms. You cannot, for example, change its algorithm to search for services from a different location.\r\nFrom the perspective of the ServiceLoader class, all services have a single type, which is usually a single interface or abstract class. The provider itself contains one or more concrete classes that extend the service type with an implementation specific to its purpose. The ServiceLoader class requires that the single exposed provider type has a default constructor, which requires no arguments. This enables the ServiceLoader class to easily instantiate the service providers that it finds.\r\nProviders are located and instantiated on demand. A service loader maintains a cache of the providers that were loaded. Each invocation of the loader's iterator method returns an iterator that first yields all of the elements of the cache, in instantiation order. The service loader then locates and instantiates any new providers, adding each one to the cache in turn. You can clear the provider cache with the reload method.\r\nTo create a loader for a specific class, provide the class itself to the load or loadInstalled method. You can use default class loaders or provide your own ClassLoader subclass.\r\nThe loadInstalled method searches the runtime environment's extension directory of installed runtime providers. The default extension location is your runtime environment's jre/lib/ext directory. You should use the extension location only for well-known, trusted providers because this location becomes part of the class path for all applications. In this article, providers do not use the extension directory but will instead depend on an application-specific class path.\r\nLimitations of the ServiceLoader API\r\nThe ServiceLoader API is useful, but it has limitations. For example, it is impossible to derive a class from the ServiceLoader class, so you cannot modify its behavior. You can use custom ClassLoader subclasses to change how classes are found, but ServiceLoader itself cannot be extended. Also, the current ServiceLoader\r\n class cannot tell your application when new providers are available at \r\nruntime. Additionally, you cannot add change-listeners to the loader to \r\nfind out whether a new provider was placed into an \r\napplication-specific extension directory. \r\nThe public ServiceLoader API is available in Java SE 6. \r\nAlthough the loader service existed as early as JDK 1.3, the API was \r\nprivate and only available to internal Java runtime code. \r\nSummary\r\nExtensible applications provide service points that can be extended \r\nby service providers. The easiest way to create an extensible \r\napplication is to use the ServiceLoader, which is available for Java SE 6 and later. Using this class, you can add provider \r\nimplementations to the application class path to make new functionality \r\navailable. The ServiceLoader class is final, so you cannot modify its abilities.\r\n",
        "title": "Oracle_Creating Extensible Applications.txt",
        "type": "Oracle_"
    }, {
        "rank": 6,
        "text": "\r\nIn order to be able to create a digital signature, you need a private key. (Its corresponding public key will be needed in order to verify the authenticity of the signature.)\r\nIn some cases the key pair (private key and corresponding public key) are already available in files. In that case the program can import and use the private key for signing, as shown in Weaknesses and Alternatives.\r\nIn other cases the program needs to generate the key pair. A key pair is generated by using the KeyPairGenerator class.\r\nIn this example you will generate a public/private key pair for the Digital Signature Algorithm (DSA). You will generate keys with a 1024-bit length.\r\nGenerating a key pair requires several steps:\r\nCreate a Key Pair Generator\r\nThe first step is to get a key-pair generator object for generating keys for the DSA signature algorithm.\r\nAs with all engine classes, the way to get a KeyPairGenerator object for a particular type of algorithm is to call the getInstance static factory method on the KeyPairGenerator class. This method has two forms, both of which hava a String algorithm first argument; one form also has a String provider second argument.\r\nA caller may thus optionally specify the name of a provider, which will guarantee that the implementation of the algorithm requested is from the named provider. The sample code of this lesson always specifies the default SUN provider built into the JDK.\r\nPut the following statement after the\r\n\r\nelse try {\r\n\r\nline in the file created in the previous step, Prepare Initial Program Structure:\r\n\r\nKeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"DSA\", \"SUN\");\r\n\r\nInitialize the Key Pair Generator\r\nThe next step is to initialize the key pair generator. All key pair generators share the concepts of a keysize and a source of randomness. The KeyPairGenerator class has an initialize method that takes these two types of arguments.\r\nThe keysize for a DSA key generator is the key length (in bits), which you will set to 1024.\r\nThe source of randomness must be an instance of the SecureRandom class that provides a cryptographically strong random number generator (RNG). For more information about SecureRandom, see the \r\nSecureRandom API Specification and the \r\nJava Cryptography Architecture Reference Guide .\r\nThe following example requests an instance of SecureRandom that uses the SHA1PRNG algorithm, as provided by the built-in SUN provider. The example then passes this SecureRandom instance to the key-pair generator initialization method.\r\n\r\nSecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\", \"SUN\");\r\nkeyGen.initialize(1024, random);\r\n\r\nSome situations require strong random values, such as when creating high-value and long-lived secrets like RSA public and private keys. To help guide applications in selecting a suitable strong SecureRandom implementation, starting from JDK 8 Java distributions include a list of known strong SecureRandom implementations in the securerandom.strongAlgorithms property of the java.security.Security class. When you are creating such data, you should consider using SecureRandom.getInstanceStrong(), as it obtains an instance of the known strong algorithms.\r\nGenerate the Pair of Keys\r\nThe final step is to generate the key pair and to store the keys in PrivateKey and PublicKey objects.\r\n\r\nKeyPair pair = keyGen.generateKeyPair();\r\nPrivateKey priv = pair.getPrivate();\r\nPublicKey pub = pair.getPublic();\r\n\r\n",
        "title": "Oracle_Generate Public and Private Keys.txt",
        "type": "Oracle_"
    }, {
        "rank": 7,
        "text": "\r\n\r\nIn this section, we discuss the use of the static keyword to create fields and methods that belong to the class, rather than to an instance of the class.\r\nClass Variables\r\nWhen a number of objects are created from the same class blueprint, they each have their own distinct copies of instance variables. In the case of the Bicycle class, the instance variables are cadence, gear, and speed. Each Bicycle object has its own values for these variables, stored in different memory locations.\r\nSometimes, you want to have variables that are common to all objects. This is accomplished with the static modifier. Fields that have the static modifier in their declaration are called static fields or class variables. They are associated with the class, rather than with any object. Every instance of the class shares a class variable, which is in one fixed location in memory. Any object can change the value of a class variable, but class variables can also be manipulated without creating an instance of the class.\r\nFor example, suppose you want to create a number of Bicycle objects and assign each a serial number, beginning with 1 for the first object. This ID number is unique to each object and is therefore an instance variable. At the same time, you need a field to keep track of how many Bicycle objects have been created so that you know what ID to assign to the next one. Such a field is not related to any individual object, but to the class as a whole. For this you need a class variable, numberOfBicycles, as follows:\r\n\r\npublic class Bicycle {\r\n        \r\n    private int cadence;\r\n    private int gear;\r\n    private int speed;\r\n        \r\n    // add an instance variable for the object ID\r\n    private int id;\r\n    \r\n    // add a class variable for the\r\n    // number of Bicycle objects instantiated\r\n    private static int numberOfBicycles = 0;\r\n        ...\r\n}\r\n\r\nClass variables are referenced by the class name itself, as in\r\n\r\nBicycle.numberOfBicycles\r\n\r\nThis makes it clear that they are class variables.\r\nNote:Â You can also refer to static fields with an object reference like\r\n\r\nmyBike.numberOfBicycles\r\n \r\nbut this is discouraged because it does not make it clear that they are class variables.\r\n\r\nYou can use the Bicycle constructor to set the id instance variable and increment the numberOfBicycles class variable:\r\n\r\npublic class Bicycle {\r\n        \r\n    private int cadence;\r\n    private int gear;\r\n    private int speed;\r\n    private int id;\r\n    private static int numberOfBicycles = 0;\r\n        \r\n    public Bicycle(int startCadence, int startSpeed, int startGear){\r\n        gear = startGear;\r\n        cadence = startCadence;\r\n        speed = startSpeed;\r\n\r\n        // increment number of Bicycles\r\n        // and assign ID number\r\n        id = ++numberOfBicycles;\r\n    }\r\n\r\n    // new method to return the ID instance variable\r\n    public int getID() {\r\n        return id;\r\n    }\r\n        ...\r\n}\r\n\r\nClass Methods\r\nThe Java programming language supports static methods as well as static variables. Static methods, which have the static modifier in their declarations, should be invoked with the class name, without the need for creating an instance of the class, as in\r\n\r\nClassName.methodName(args)\r\n\r\nNote:Â You can also refer to static methods with an object reference like\r\n\r\ninstanceName.methodName(args)\r\n \r\nbut this is discouraged because it does not make it clear that they are class methods.\r\n\r\nA common use for static methods is to access static fields. For example, we could add a static method to the Bicycle class to access the numberOfBicycles static field:\r\n\r\npublic static int getNumberOfBicycles() {\r\n    return numberOfBicycles;\r\n}\r\n\r\nNot all combinations of instance and class variables and methods are allowed:\r\n\r\nInstance methods can access instance variables and instance methods directly.\r\nInstance methods can access class variables and class methods directly.\r\nClass methods can access class variables and class methods directly.\r\nClass methods cannot access instance variables or instance methods directlyâ\u20ac\u201dthey must use an object reference. Also, class methods cannot use the this keyword as there is no instance for this to refer to.\r\n\r\nConstants\r\nThe static modifier, in combination with the final modifier, is also used to define constants. The final modifier indicates that the value of this field cannot change.\r\nFor example, the following variable declaration defines a constant named PI, whose value is an approximation of pi (the ratio of the circumference of a circle to its diameter):\r\n\r\nstatic final double PI = 3.141592653589793;\r\n\r\nConstants defined in this way cannot be reassigned, and it is a compile-time error if your program tries to do so. By convention, the names of constant values are spelled in uppercase letters. If the name is composed of more than one word, the words are separated by an underscore (_).\r\nNote:Â If a primitive type or a string is defined as a constant and the value is known at compile time, the compiler replaces the constant name everywhere in the code with its value. This is called a compile-time constant. If the value of the constant in the outside world changes (for example, if it is legislated that pi actually should be 3.975), you will need to recompile any classes that use this constant to get the current value.\r\n\r\nThe Bicycle Class\r\nAfter all the modifications made in this section, the Bicycle class is now:\r\n\r\npublic class Bicycle {\r\n        \r\n    private int cadence;\r\n    private int gear;\r\n    private int speed;\r\n        \r\n    private int id;\r\n    \r\n    private static int numberOfBicycles = 0;\r\n\r\n        \r\n    public Bicycle(int startCadence,\r\n                   int startSpeed,\r\n                   int startGear) {\r\n        gear = startGear;\r\n        cadence = startCadence;\r\n        speed = startSpeed;\r\n\r\n        id = ++numberOfBicycles;\r\n    }\r\n\r\n    public int getID() {\r\n        return id;\r\n    }\r\n\r\n    public static int getNumberOfBicycles() {\r\n        return numberOfBicycles;\r\n    }\r\n\r\n    public int getCadence() {\r\n        return cadence;\r\n    }\r\n        \r\n    public void setCadence(int newValue) {\r\n        cadence = newValue;\r\n    }\r\n        \r\n    public int getGear(){\r\n        return gear;\r\n    }\r\n        \r\n    public void setGear(int newValue) {\r\n        gear = newValue;\r\n    }\r\n        \r\n    public int getSpeed() {\r\n        return speed;\r\n    }\r\n        \r\n    public void applyBrake(int decrement) {\r\n        speed -= decrement;\r\n    }\r\n        \r\n    public void speedUp(int increment) {\r\n        speed += increment;\r\n    }\r\n}\r\n\r\n",
        "title": "Oracle_Understanding Class Members.txt",
        "type": "Oracle_"
    }, {
        "rank": 8,
        "text": "\r\nYou use\r\nlambda expressions to create anonymous methods. Sometimes, however, a lambda expression does nothing but call an existing method. In those cases, it's often clearer to refer to the existing method by name. Method references enable you to do this; they are compact, easy-to-read lambda expressions for methods that already have a name.\r\nConsider again the\r\nPerson class discussed in the section\r\nLambda Expressions:\r\npublic class Person {\r\n\r\n    public enum Sex {\r\n        MALE, FEMALE\r\n    }\r\n\r\n    String name;\r\n    LocalDate birthday;\r\n    Sex gender;\r\n    String emailAddress;\r\n\r\n    public int getAge() {\r\n        // ...\r\n    }\r\n    \r\n    public Calendar getBirthday() {\r\n        return birthday;\r\n    }    \r\n\r\n    public static int compareByAge(Person a, Person b) {\r\n        return a.birthday.compareTo(b.birthday);\r\n    }}\r\nSuppose that the members of your social networking application are contained in an array, and you want to sort the array by age. You could use the following code (find the code excerpts described in this section in the example\r\nMethodReferencesTest):\r\nPerson[] rosterAsArray = roster.toArray(new Person[roster.size()]);\r\n\r\nclass PersonAgeComparator implements Comparator<Person> {\r\n    public int compare(Person a, Person b) {\r\n        return a.getBirthday().compareTo(b.getBirthday());\r\n    }\r\n}\r\n        \r\nArrays.sort(rosterAsArray, new PersonAgeComparator());\r\nThe method signature of this invocation of sort is the following:\r\nstatic <T> void sort(T[] a, Comparator<? super T> c)\r\nNotice that the interface Comparator is a functional interface. Therefore, you could use a lambda expression instead of defining and then creating a new instance of a class that implements Comparator:\r\nArrays.sort(rosterAsArray,\r\n    (Person a, Person b) -> {\r\n        return a.getBirthday().compareTo(b.getBirthday());\r\n    }\r\n);\r\nHowever, this method to compare the birth dates of two Person instances already exists as Person.compareByAge. You can invoke this method instead in the body of the lambda expression:\r\nArrays.sort(rosterAsArray,\r\n    (a, b) -> Person.compareByAge(a, b)\r\n);\r\nBecause this lambda expression invokes an existing method, you can use a method reference instead of a lambda expression:\r\nArrays.sort(rosterAsArray, Person::compareByAge);\r\nThe method reference Person::compareByAge is semantically the same as the lambda expression (a, b) -> Person.compareByAge(a, b). Each has the following characteristics:\r\n\r\nIts formal parameter list is copied from Comparator<Person>.compare, which is (Person, Person).\r\nIts body calls the method Person.compareByAge.\r\n\r\nKinds of Method References\r\nThere are four kinds of method references:\r\n\r\n\r\nKind\r\nExample\r\n\r\n\r\nReference to a static method\r\nContainingClass::staticMethodName\r\n\r\n\r\nReference to an instance method of a particular object\r\ncontainingObject::instanceMethodName\r\n\r\n\r\nReference to an instance method of an arbitrary object of a particular type\r\nContainingType::methodName\r\n\r\n\r\nReference to a constructor\r\nClassName::new\r\n\r\n\r\nReference to a Static Method\r\nThe method reference Person::compareByAge is a reference to a static method.\r\nReference to an Instance Method of a Particular Object\r\nThe following is an example of a reference to an instance method of a particular object:\r\nclass ComparisonProvider {\r\n    public int compareByName(Person a, Person b) {\r\n        return a.getName().compareTo(b.getName());\r\n    }\r\n        \r\n    public int compareByAge(Person a, Person b) {\r\n        return a.getBirthday().compareTo(b.getBirthday());\r\n    }\r\n}\r\nComparisonProvider myComparisonProvider = new ComparisonProvider();\r\nArrays.sort(rosterAsArray, myComparisonProvider::compareByName);\r\nThe method reference myComparisonProvider::compareByName invokes the method compareByName that is part of the object myComparisonProvider. The JRE infers the method type arguments, which in this case are (Person, Person).\r\nReference to an Instance Method of an Arbitrary Object of a Particular Type\r\nThe following is an example of a reference to an instance method of an arbitrary object of a particular type:\r\nString[] stringArray = { \"Barbara\", \"James\", \"Mary\", \"John\",\r\n    \"Patricia\", \"Robert\", \"Michael\", \"Linda\" };\r\nArrays.sort(stringArray, String::compareToIgnoreCase);\r\nThe equivalent lambda expression for the method reference String::compareToIgnoreCase would have the formal parameter list (String a, String b), where a and b are arbitrary names used to better describe this example. The method reference would invoke the method a.compareToIgnoreCase(b).\r\nReference to a Constructor\r\nYou can reference a constructor in the same way as a static method by using the name new. The following method copies elements from one collection to another:\r\npublic static <T, SOURCE extends Collection<T>, DEST extends Collection<T>>\r\n    DEST transferElements(\r\n        SOURCE sourceCollection,\r\n        Supplier<DEST> collectionFactory) {\r\n        \r\n        DEST result = collectionFactory.get();\r\n        for (T t : sourceCollection) {\r\n            result.add(t);\r\n        }\r\n        return result;\r\n}\r\nThe functional interface Supplier contains one method get that takes no arguments and returns an object. Consequently, you can invoke the method transferElements with a lambda expression as follows:\r\nSet<Person> rosterSetLambda =\r\n    transferElements(roster, () -> { return new HashSet<>(); });\r\nYou can use a constructor reference in place of the lambda expression as follows:\r\nSet<Person> rosterSet = transferElements(roster, HashSet::new);\r\nThe Java compiler infers that you want to create a HashSet collection that contains elements of type Person. Alternatively, you can specify this as follows:\r\nSet<Person> rosterSet = transferElements(roster, HashSet<Person>::new);\r\n",
        "title": "Oracle_Method References.txt",
        "type": "Oracle_"
    }, {
        "rank": 9,
        "text": "\r\nWith the \r\nJTable class you can display tables of data, optionally allowing the user to edit the data. JTable does not contain or cache data; it is simply a view of your data. Here is a picture of a typical table displayed within a scroll pane:\r\nThe rest of this section shows you how to accomplish some common table-related tasks. Here are the topics this section covers:\r\n\r\nCreating a Simple Table\r\nAdding a Table to a Container\r\nSetting and Changing Column Widths\r\nUser Selections\r\nCreating a Table Model\r\nListening for Data Changes\r\nFiring Data Change Events\r\nConcepts: Editors and Renderers\r\nUsing Custom Renderers\r\nSpecifying Tool Tips for Cells\r\nSpecifying Tool Tips for Column Headers\r\nSorting and Filtering\r\nUsing a Combo Box as an Editor\r\nUsing Other Editors\r\nUsing an Editor to Validate User-Entered Text\r\nPrinting\r\nExamples that Use Tables\r\n\r\nCreating a Simple Table\r\nTry this:Â \r\n\r\nClick the Launch button to run SimpleTableDemo using \r\nJavaâ\u201e¢ Web Start (download JDK 7 or later). Or, to compile and run the example yourself, consult the example index.\r\n\r\n\r\nClick the cell that contains \"Snowboarding\".\r\nThe entire first row is selected, indicating that you have selected Kathy Smith's data. A special highlight indicates that the \"Snowboarding\" cell is editable. Generally, you begin editing a text cell by double-clicking it.\r\n\r\n\r\nPosition the cursor over \"First Name\". Now press the mouse button and drag to the right.\r\nAs you can see, users can rearrange columns in tables.\r\n\r\n\r\nPosition the cursor just to the right of a column header. Now press the mouse button and drag to the right or left.\r\nThe column changes size, and the other columns adjust to fill the remaining space.\r\n\r\nResize the window containing the table so that it's bigger than necessary to display the whole table.\r\nAll the table cells become wider, expanding to fill the extra horizontal space.\r\n\r\n\r\nThe table in \r\nSimpleTableDemo.java declares the column names in a String array:\r\n\r\nString[] columnNames = {\"First Name\",\r\n                        \"Last Name\",\r\n                        \"Sport\",\r\n                        \"# of Years\",\r\n                        \"Vegetarian\"};\r\n\r\nIts data is initialized and stored in a two-dimensional Object array:\r\n\r\nObject[][] data = {\r\n    {\"Kathy\", \"Smith\",\r\n     \"Snowboarding\", new Integer(5), new Boolean(false)},\r\n    {\"John\", \"Doe\",\r\n     \"Rowing\", new Integer(3), new Boolean(true)},\r\n    {\"Sue\", \"Black\",\r\n     \"Knitting\", new Integer(2), new Boolean(false)},\r\n    {\"Jane\", \"White\",\r\n     \"Speed reading\", new Integer(20), new Boolean(true)},\r\n    {\"Joe\", \"Brown\",\r\n     \"Pool\", new Integer(10), new Boolean(false)}\r\n};\r\n\r\nThen the Table is constructed using these data and columnNames:\r\n\r\nJTable table = new JTable(data, columnNames);\r\n\r\nThere are two JTable constructors that directly accept data (SimpleTableDemo uses the first):\r\n\r\nJTable(Object[][] rowData, Object[] columnNames)\r\nJTable(Vector rowData, Vector columnNames)\r\n\r\nThe advantage of these constructors is that they are easy to use. However, these constructors also have disadvantages:\r\n\r\nThey automatically make every cell editable.\r\nThey treat all data types the same (as strings). For example, if a table column has Boolean data, the table can display the data in a check box. However, if you use either of the two JTable constructors listed previously, your Boolean data is displayed as a string. You can see this difference in the Vegetarian column of the previous figure.\r\nThey require that you put all of the table's data in an array or vector, which may not be appropriate for some data. For example, if you are instantiating a set of objects from a database, you might want to query the objects directly for their values, rather than copying all their values into an array or vector.\r\n\r\nIf you want to get around these restrictions, you need to implement your own table model, as described in Creating a Table Model.\r\nAdding a Table to a Container\r\nHere is typical code for creating a scroll pane that serves as a container for a table:\r\n\r\nJScrollPane scrollPane = new JScrollPane(table);\r\ntable.setFillsViewportHeight(true);\r\n\r\nThe two lines in this snippet do the following:\r\n\r\nThe JScrollPane constructor is invoked with an argument that refers to the table object. This creates a scroll pane as a container for the table; the table is automatically added to the container.\r\nJTable.setFillsViewportHeight is invoked to set the fillsViewportHeight property. When this property is true the table uses the entire height of the container, even if the table doesn't have enough rows to use the whole vertical space. This makes it easier to use the table as a drag-and-drop target.\r\n\r\nThe scroll pane automatically places the table header at the top of the viewport. The column names remain visible at the top of the viewing area when the table data is scrolled.\r\nIf you are using a table without a scroll pane, then you must get the table header component and place it yourself. For example:\r\n\r\ncontainer.setLayout(new BorderLayout());\r\ncontainer.add(table.getTableHeader(), BorderLayout.PAGE_START);\r\ncontainer.add(table, BorderLayout.CENTER);\r\n\r\nSetting and Changing Column Widths\r\nBy default, all columns in a table start out with equal width, and the columns automatically fill the entire width of the table. When the table becomes wider or narrower (which might happen when the user resizes the window containing the table), all the column widths change appropriately.\r\nWhen the user resizes a column by dragging its right border, then either other columns must change size, or the table's size must change. By default, the table's size remains the same, and all columns to the right of the drag point resize to accommodate space added to or removed from the column to the left of the drag point.\r\nTo customize initial column widths, you can invoke setPreferredWidth on each of your table's columns. This sets both the preferred widths of the columns and their approximate relative widths. For example, adding the following code to SimpleTableDemo makes its third column bigger than the other columns:\r\n\r\nTableColumn column = null;\r\nfor (int i = 0; i < 5; i++) {\r\n    column = table.getColumnModel().getColumn(i);\r\n    if (i == 2) {\r\n        column.setPreferredWidth(100); //third column is bigger\r\n    } else {\r\n        column.setPreferredWidth(50);\r\n    }\r\n}\r\n\r\nAs the preceding code shows, each column in a table is represented by a \r\nTableColumn object. TableColumn supplies getter and setter methods for the minimum, preferred, and maximum widths of a column, as well as a method for getting the current width. For an example of setting cell widths based on an approximation of the space needed to draw the cells' contents, see the initColumnSizes method in \r\nTableRenderDemo.java.\r\nWhen the user explicitly resizes columns, the columns' preferred widths are set such that the user-specified sizes become the columns' new current widths. However, when table itself is resized â\u20ac\u201d typically because the window has resized â\u20ac\u201d; the columns' preferred widths do not change. Instead, the existing preferred widths are used to calculate new column widths to fill the available space.\r\nYou can change a table's resize behavior by invoking \r\nsetAutoResizeMode.\r\n\r\n\r\nUser Selections\r\nIn its default configuration, a table supports a selection that consists of one or more rows. The user can select a contiguous range of rows or an arbitrary set of rows. The last cell that the user indicated gets a special indication; in the Metal look and feel, the cell is outlined. This cell is known as the lead selection; it is sometimes called \"the cell with the focus\" or \"the current cell\".\r\nThe user uses the mouse and/or keyboard to make selections, as described in the following table:\r\n\r\n\r\n\r\nOperation\r\nMouse Action\r\nKeyboard Action\r\n\r\n\r\nSelect single row.\r\nClick.\r\nUp Arrow or Down Arrow.\r\n\r\n\r\nExtend contiguous selection.\r\nShift-Click or Drag over rows.\r\nShift-Up Arrow or Shift-Down Arrow.\r\n\r\n\r\nAdd row to selection/toggle row selection.\r\nControl-Click\r\nMove lead selection with Control-Up Arrow or Control-Down Arrow, then use Space Bar to add to selection or Control-Space Bar to toggle row selection.\r\n\r\n\r\n\r\nTo see how selections work, click the Launch button to run TableSelectionDemo using \r\nJavaâ\u201e¢ Web Start (download JDK 7 or later). Or, to compile and run the example yourself, consult the example index.\r\n\r\nThis example program presents the familiar table, and allows the user to manipulate certain JTable options. There is also a text pane that logs selection events.\r\nIn the screenshot below, a user has run the program, clicked in the first row, then control-clicked in the third row. Notice the outline around the last cell clicked; this is how the Metal look and feel highlights the lead selection.\r\nUnder \"Selection Mode\" there are a set of radio buttons. Click the one labelled \"Single Selection\". Now you can only select one row at a time. If you click on the \"Single Interval Selection\" radio button, you can select a set of rows that must be contiguous.\r\nAll of the radio buttons under \"Selection Mode\" invoke \r\nJTable.setSelectionMode. This method takes a single argument, which must be one of the following constants defined in javax.swing.ListSelectionModel: MULTIPLE_INTERVAL_SELECTION, SINGLE_INTERVAL_SELECTION, and SINGLE_SELECTION.\r\nReturning to TableSelectionDemo, notice the three option checkboxes under \"Selection Options.\" Each of checkbox controls the state of a boolean bound variable defined by JTable:\r\n\r\n\"Row Selection\" controls rowSelectionAllowed which has setter method setRowSelectionAllowed and getter method getRowSelectionAllowed. When this bound property is true (and the columnSelectionAllowed property is false), the user can select by row.\r\n\"Column Selection\" controls columnSelectionAllowed which has setter method setColumnSelectionAllowed and getter method getColumnSelectionAllowed. When this bound property is true (and the rowSelectionAllowed bound property is false), the user can select by column.\r\n\"Cell Selection\" controls cellSelectionEnabled, which has setter method setCellSelectionEnabled and getter method getCellSelectionEnabled. When this bound property is true, the user can select a single cell or rectangular block of cells.\r\n\r\nNOTE:Â JTable uses a very simple concept of selection, managed as an intersection of rows and columns. It was not designed to handle fully independent cell selections.\r\n\r\nIf you clear all three check boxes (setting all three bound properties to false), there is no selection; only the lead selection is shown.\r\nYou may notice that the \"Cell Selection\" checkbox is disabled in multiple interval selection mode. This is because cell selection is not supported in this mode in the demo. You can specify selection by cell in multiple interval selection mode, but the result is a table that does not produce useful selections.\r\nYou may also notice that changing any of the three selection options can affect the others. This is because allowing both row selection and column selection is exactly the same as enabling cell selection. JTable automatically updates the three bound variables as necessary to keep them consistent.\r\nNOTE:Â Setting cellSelectionEnabled to a value has the side effect of also setting both rowSelectionEnabled and columnSelectionEnabled to that value. Setting both rowSelectionEnabled and columnSelectionEnabled to a value has the side effect of also setting cellSelectionEnabled to that value. Setting rowSelectionEnabled and columnSelectionEnabled to different values has the side effect of also setting cellSelectionEnabled to false.\r\n\r\nTo retrieve the current selection, use \r\nJTable.getSelectedRows which returns an array of row indexes, and \r\nJTable.getSelectedColumns which returns an array of column indexes. To retrieve the coordinates of the lead selection, refer to the selection models for the table itself and for the table's column model. The following code formats a string containing the row and column of the lead selection:\r\n\r\nString.format(\"Lead Selection: %d, %d. \",\r\n    table.getSelectionModel().getLeadSelectionIndex(),\r\n    table.getColumnModel().getSelectionModel().getLeadSelectionIndex());\r\n\r\nUser selections generate a number of events. For information on these, refer to \r\nHow to Write a List Selection Listener in the \r\nWriting Event Listeners lesson.\r\nNOTE:Â Selection data actually describes selected cells in the \"view\" (table data as it appears after any sorting or filtering) rather than in the table model. This distinction does not matter unless your viewed data has been rearranged by sorting, filtering, or user manipulation of columns. In that case, you must convert selection coordinates using the conversion methods described in Sorting and Filtering.\r\n\r\nCreating a Table Model\r\nEvery table object uses a table model object to manage the actual table data. A table model object must implement the \r\nTableModel interface. If the programmer does not provide a table model object, JTable automatically creates an instance of \r\nDefaultTableModel. This relationship is illustrated below.\r\nThe JTable constructor used by SimpleTableDemo creates its table model with code like this:\r\n\r\nnew AbstractTableModel() {\r\n    public String getColumnName(int col) {\r\n        return columnNames[col].toString();\r\n    }\r\n    public int getRowCount() { return rowData.length; }\r\n    public int getColumnCount() { return columnNames.length; }\r\n    public Object getValueAt(int row, int col) {\r\n        return rowData[row][col];\r\n    }\r\n    public boolean isCellEditable(int row, int col)\r\n        { return true; }\r\n    public void setValueAt(Object value, int row, int col) {\r\n        rowData[row][col] = value;\r\n        fireTableCellUpdated(row, col);\r\n    }\r\n}\r\n\r\nAs the preceding code shows, implementing a table model can be simple. Generally, you implement your table model in a subclass of the \r\nAbstractTableModel class.\r\nYour model might hold its data in an array, vector, or hash map, or it might get the data from an outside source such as a database. It might even generate the data at execution time.\r\nThis table is different from the SimpleTableDemo table in the following ways:\r\n\r\nTableDemo's custom table model, even though it is simple, can easily determine the data's type, helping the JTable display the data in the best format. SimpleTableDemo's automatically created table model, on the other hand, does not know that the # of Years column contains numbers (which should generally be right aligned and have a particular format). It also does not know that the Vegetarian column contains boolean values, which can be represented by check boxes.\r\nThe custom table model implemented in TableDemo does not let you edit the name columns; it does, however, let you edit the other columns. In SimpleTableDemo, all cells are editable.\r\n\r\nSee below the code taken from \r\nTableDemo.java that is different from the \r\nSimpleTableDemo.java. Bold font indicates the code that makes this table's model different from the table model defined automatically for SimpleTableDemo.\r\n\r\npublic TableDemo() {\r\n    ...\r\n    JTable table = new JTable(new MyTableModel());\r\n    ...\r\n}\r\n\r\nclass MyTableModel extends AbstractTableModel {\r\n    private String[] columnNames = ...//same as before...\r\n    private Object[][] data = ...//same as before...\r\n\r\n    public int getColumnCount() {\r\n        return columnNames.length;\r\n    }\r\n\r\n    public int getRowCount() {\r\n        return data.length;\r\n    }\r\n\r\n    public String getColumnName(int col) {\r\n        return columnNames[col];\r\n    }\r\n\r\n    public Object getValueAt(int row, int col) {\r\n        return data[row][col];\r\n    }\r\n\r\n    public Class getColumnClass(int c) {\r\n        return getValueAt(0, c).getClass();\r\n    }\r\n\r\n    /*\r\n     * Don't need to implement this method unless your table's\r\n     * editable.\r\n     */\r\n    public boolean isCellEditable(int row, int col) {\r\n        //Note that the data/cell address is constant,\r\n        //no matter where the cell appears onscreen.\r\n        if (col < 2) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Don't need to implement this method unless your table's\r\n     * data can change.\r\n     */\r\n    public void setValueAt(Object value, int row, int col) {\r\n        data[row][col] = value;\r\n        fireTableCellUpdated(row, col);\r\n    }\r\n    ...\r\n}\r\n\r\nListening for Data Changes\r\nA table model can have a set of listeners that are notified whenever the table data changes. Listeners are instances of \r\nTableModelListener. In the following example code, SimpleTableDemo is extended to include such a listener. New code is in bold.\r\n\r\nimport javax.swing.event.*;\r\nimport javax.swing.table.TableModel;\r\n\r\npublic class SimpleTableDemo ... implements TableModelListener {\r\n    ...\r\n    public SimpleTableDemo() {\r\n        ...\r\n        table.getModel().addTableModelListener(this);\r\n        ...\r\n    }\r\n\r\n    public void tableChanged(TableModelEvent e) {\r\n        int row = e.getFirstRow();\r\n        int column = e.getColumn();\r\n        TableModel model = (TableModel)e.getSource();\r\n        String columnName = model.getColumnName(column);\r\n        Object data = model.getValueAt(row, column);\r\n\r\n        ...// Do something with the data...\r\n    }\r\n    ...\r\n}\r\n\r\nFiring Data Change Events\r\nIn order to fire data change events the table model must know how to construct a \r\nTableModelEvent object. This can be a complex procedure, but is already implemented in DefaultTableModel. You can either allow JTable to use its default instance of DefaultTableModel, or create your own custom subclass of DefaultTableModel.\r\nIf DefaultTableModel is not a suitable base class for your custom table model class, consider subclassing \r\nAbstractTableModel. This class implements a simple framework for constructing TableModelEvent objects. Your custom class simply needs to invoke one the following AbstractTableModel methods each time table data is changed by an external source.\r\n\r\n\r\n\r\nMethod\r\nChange\r\n\r\n\r\nfireTableCellUpdated\r\nUpdate of specified cell.\r\n\r\n\r\nfireTableRowsUpdated\r\nUpdate of specified rows\r\n\r\n\r\nfireTableDataChanged\r\nUpdate of entire table (data only).\r\n\r\n\r\nfireTableRowsInserted\r\nNew rows inserted.\r\n\r\n\r\nfireTableRowsDeleted\r\nExisting rows Deleted\r\n\r\n\r\nfireTableStructureChangedÂ Â \r\nInvalidate entire table, both data and structure.\r\n\r\n\r\n\r\nConcepts: Editors and Renderers\r\nBefore you go on to the next few tasks, you need to understand how tables draw their cells. You might expect each cell in a table to be a component. However, for performance reasons, Swing tables are implemented differently.\r\nInstead, a single cell renderer is generally used to draw all of the cells that contain the same type of data. You can think of the renderer as a configurable ink stamp that the table uses to stamp appropriately formatted data onto each cell. When the user starts to edit a cell's data, a cell editor takes over the cell, controlling the cell's editing behavior.\r\nFor example, each cell in the # of Years column in TableDemo contains Number data â\u20ac\u201d specifically, an Integer object. By default, the cell renderer for a Number-containing column uses a single JLabel instance to draw the appropriate numbers, right-aligned, on the column's cells. If the user begins editing one of the cells, the default cell editor uses a right-aligned JTextField to control the cell editing.\r\nTo choose the renderer that displays the cells in a column, a table first determines whether you specified a renderer for that particular column. If you did not, then the table invokes the table model's getColumnClass method, which gets the data type of the column's cells. Next, the table compares the column's data type with a list of data types for which cell renderers are registered. This list is initialized by the table, but you can add to it or change it. Currently, tables put the following types of data in the list:\r\n\r\nBoolean â\u20ac\u201d rendered with a check box.\r\nNumber â\u20ac\u201d rendered by a right-aligned label.\r\nDouble, Float â\u20ac\u201d same as Number, but the object-to-text translation is performed by a \r\nNumberFormat instance (using the default number format for the current locale).\r\nDate â\u20ac\u201d rendered by a label, with the object-to-text translation performed by a \r\nDateFormat instance (using a short style for the date and time).\r\nImageIcon, Icon â\u20ac\u201d rendered by a centered label.\r\nObject â\u20ac\u201d rendered by a label that displays the object's string value.\r\n\r\nCell editors are chosen using a similar algorithm.\r\nRemember that if you let a table create its own model, it uses Object as the type of every column. To specify more precise column types, the table model must define the getColumnClass method appropriately, as demonstrated by \r\nTableDemo.java.\r\nKeep in mind that although renderers determine how each cell or column header looks and can specify its tool tip text, a renderer does not handle events. If you need to pick up the events that take place inside a table, the technique you use varies by the sort of event you are interested in:\r\n\r\n\r\n\r\nSituation\r\nHow to Get Events\r\n\r\n\r\nTo detect events from a cell that is being edited...\r\nUse the cell editor (or register a listener on the cell editor).\r\n\r\n\r\nTo detect row/column/cell selections and deselections...\r\nUse a selection listener as described in Detecting User Selections.\r\n\r\n\r\nTo detect mouse events on a column header...\r\nRegister the appropriate type of \r\nmouse listener  on the table's JTableHeader object. (See \r\nTableSorter.java for an example.)\r\n\r\n\r\nTo detect other events...\r\nRegister the appropriate listener on the JTable object.\r\n\r\n\r\n\r\nThe next few sections tell you how to customize display and editing by specifying renderers and editors. You can specify cell renderers and editors either by column or by data type.\r\nUsing Custom Renderers\r\nThis section tells you how to create and specify a cell renderer. You can set a type-specific cell renderer using the JTable method setDefaultRenderer. To specify that cells in a particular column should use a renderer, you use the TableColumn method setCellRenderer. You can even specify a cell-specific renderer by creating a JTable subclass.\r\nIt is easy to customize the text or image rendered by the default renderer, DefaultTableCellRenderer. You just create a subclass and implement the setValue method so that it invokes setText or setIcon with the appropriate string or image. For example, here is how the default date renderer is implemented:\r\n\r\nstatic class DateRenderer extends DefaultTableCellRenderer {\r\n    DateFormat formatter;\r\n    public DateRenderer() { super(); }\r\n\r\n    public void setValue(Object value) {\r\n        if (formatter==null) {\r\n            formatter = DateFormat.getDateInstance();\r\n        }\r\n        setText((value == null) ? \"\" : formatter.format(value));\r\n    }\r\n}\r\n\r\nIf extending DefaultTableCellRenderer is insufficient, you can build a renderer using another superclass. The easiest way is to create a subclass of an existing component, making your subclass implement the \r\nTableCellRenderer interface. TableCellRenderer requires just one method: getTableCellRendererComponent. Your implementation of this method should set up the rendering component to reflect the passed-in state, and then return the component.\r\nIn the snapshot of TableDialogEditDemo, the renderer used for Favorite Color cells is a subclass of JLabel called ColorRenderer. Here are excerpts from \r\nColorRenderer.java that show how it is implemented.\r\n\r\npublic class ColorRenderer extends JLabel\r\n                           implements TableCellRenderer {\r\n    ...\r\n    public ColorRenderer(boolean isBordered) {\r\n        this.isBordered = isBordered;\r\n        setOpaque(true); //MUST do this for background to show up.\r\n    }\r\n\r\n    public Component getTableCellRendererComponent(\r\n                            JTable table, Object color,\r\n                            boolean isSelected, boolean hasFocus,\r\n                            int row, int column) {\r\n        Color newColor = (Color)color;\r\n        setBackground(newColor);\r\n        if (isBordered) {\r\n            if (isSelected) {\r\n                ...\r\n                //selectedBorder is a solid border in the color\r\n                //table.getSelectionBackground().\r\n                setBorder(selectedBorder);\r\n            } else {\r\n                ...\r\n                //unselectedBorder is a solid border in the color\r\n                //table.getBackground().\r\n                setBorder(unselectedBorder);\r\n            }\r\n        }\r\n        \r\n        setToolTipText(...); //Discussed in the following section\r\n        return this;\r\n    }\r\n}\r\n\r\nHere is the code from \r\nTableDialogEditDemo.java that registers a ColorRenderer instance as the default renderer for all Color data:\r\n\r\ntable.setDefaultRenderer(Color.class, new ColorRenderer(true));\r\n\r\nTo specify a cell-specific renderer, you need to define a JTable subclass that overrides the getCellRenderer method. For example, the following code makes the first cell in the first column of the table use a custom renderer:\r\n\r\nTableCellRenderer weirdRenderer = new WeirdRenderer();\r\ntable = new JTable(...) {\r\n    public TableCellRenderer getCellRenderer(int row, int column) {\r\n        if ((row == 0) && (column == 0)) {\r\n            return weirdRenderer;\r\n        }\r\n        // else...\r\n        return super.getCellRenderer(row, column);\r\n    }\r\n};\r\n\r\nSpecifying Tool Tips for Cells\r\nBy default, the tool tip text displayed for a table cell is determined by the cell's renderer. However, sometimes it can be simpler to specify tool tip text by overriding JTable's implementation of the getToolTipText(MouseEvent) method. This section shows you how to use both techniques.\r\nTo add a tool tip to a cell using its renderer, you first need to get or create the cell renderer. Then, after making sure the rendering component is a JComponent, invoke the setToolTipText method on it.\r\nAn example of setting tool tips for cells is in TableRenderDemo. Click the Launch button to run it using \r\nJavaâ\u201e¢ Web Start (download JDK 7 or later). Or, to compile and run the example yourself, consult the example index.\r\n\r\nThe source code is in \r\nTableRenderDemo.java. It adds tool tips to the cells of the Sport column with the following code:\r\n\r\n//Set up tool tips for the sport cells.\r\nDefaultTableCellRenderer renderer =\r\n        new DefaultTableCellRenderer();\r\nrenderer.setToolTipText(\"Click for combo box\");\r\nsportColumn.setCellRenderer(renderer);\r\n\r\nAlthough the tool tip text in the previous example is static, you can also implement tool tips whose text changes depending on the state of the cell or program. Here are a couple ways to do so:\r\n\r\nAdd a bit of code to the renderer's implementation of the getTableCellRendererComponent method.\r\nOverride the JTable method getToolTipText(MouseEvent).\r\n\r\nAn example of adding code to a cell renderer is in TableDialogEditDemo. Click the Launch button to run it using \r\nJavaâ\u201e¢ Web Start (download JDK 7 or later). Or, to compile and run the example yourself, consult the example index.\r\n\r\nTableDialogEditDemo uses a renderer for colors, implemented in \r\nColorRenderer.java, that sets the tool tip text using the boldface code in the following snippet:\r\n\r\npublic class ColorRenderer extends JLabel \r\n                           implements TableCellRenderer {\r\n    ...\r\n    public Component getTableCellRendererComponent(\r\n                            JTable table, Object color,\r\n                            boolean isSelected, boolean hasFocus,\r\n                            int row, int column) {\r\n        Color newColor = (Color)color;\r\n        ...\r\n        setToolTipText(\"RGB value: \" + newColor.getRed() + \", \"\r\n                                     + newColor.getGreen() + \", \"\r\n                                     + newColor.getBlue());\r\n        return this;\r\n    }\r\n}\r\n\r\nHere is an example of what the tool tip looks like:\r\nYou can specify tool tip text by overriding JTable's getToolTipText(MouseEvent) method. The program TableToolTipsDemo shows how. Click the Launch button to run it using \r\nJavaâ\u201e¢ Web Start (download JDK 7 or later). Or, to compile and run the example yourself, consult the example index.\r\n\r\nThe cells with tool tips are in the Sport and Vegetarian columns. Here is a picture of its tool tip:\r\nHere is the code from \r\nTableToolTipsDemo.java that implements tool tips for cells in the Sport and Vegetarian columns:\r\n\r\nJTable table = new JTable(new MyTableModel()) {    \r\n    //Implement table cell tool tips.\r\n    public String getToolTipText(MouseEvent e) {\r\n        String tip = null;\r\n        java.awt.Point p = e.getPoint();\r\n        int rowIndex = rowAtPoint(p);\r\n        int colIndex = columnAtPoint(p);\r\n        int realColumnIndex = convertColumnIndexToModel(colIndex);\r\n\r\n        if (realColumnIndex == 2) { //Sport column\r\n            tip = \"This person's favorite sport to \"\r\n                   + \"participate in is: \"\r\n                   + getValueAt(rowIndex, colIndex);\r\n\r\n        } else if (realColumnIndex == 4) { //Veggie column\r\n            TableModel model = getModel();\r\n            String firstName = (String)model.getValueAt(rowIndex,0);\r\n            String lastName = (String)model.getValueAt(rowIndex,1);\r\n            Boolean veggie = (Boolean)model.getValueAt(rowIndex,4);\r\n            if (Boolean.TRUE.equals(veggie)) {\r\n                tip = firstName + \" \" + lastName\r\n                      + \" is a vegetarian\";\r\n            } else {\r\n                tip = firstName + \" \" + lastName\r\n                      + \" is not a vegetarian\";\r\n            }\r\n\r\n        } else { //another column\r\n            //You can omit this part if you know you don't \r\n            //have any renderers that supply their own tool \r\n            //tips.\r\n            tip = super.getToolTipText(e);\r\n        }\r\n        return tip;\r\n    }\r\n    ...\r\n}\r\n\r\nThe code is fairly straightforward, except perhaps for the call to convertColumnIndexToModel. That call is necessary because if the user moves the columns around, the view's index for the column will not match the model's index for the column. For example, the user might drag the Vegetarian column (which the model considers to be at index 4) so it is displayed as the first column â\u20ac\u201d at view index 0. Since prepareRenderer provides the view index, you need to translate the view index to a model index so you can be sure the intended column has been selected.\r\nSpecifying Tool Tips for Column Headers\r\nYou can add a tool tip to a column header by setting the tool tip text for the table's JTableHeader. Often, different column headers require different tool tip text. You can change the text by overriding the table header's getToolTipText method. Alternately, you can invoke TableColumn.setHeaderRenderer to provide a custom renderer for the header.\r\nAn example of using the same tool tip text for all column headers is in \r\nTableSorterDemo.java.  Here is how it sets the tool tip text:\r\n\r\ntable.getTableHeader().setToolTipText(\r\n        \"Click to sort; Shift-Click to sort in reverse order\");\r\n\r\n\r\nTableToolTipsDemo.java has an example of implementing column header tool tips that vary by column. If you run TableToolTipsDemo (click the Launch button) using \r\nJavaâ\u201e¢ Web Start (download JDK 7 or later). Or, to compile and run the example yourself, consult the example index.\r\n\r\nYou will see the tool tips when you mouse over any column header except for the first two. No tool tips were suppled for the name columns since they seemed self-explanatory. Here is a picture of one of the column header tool tips:\r\nThe following code implements the tool tips. Basically, it creates a subclass of JTableHeader that overrides the getToolTipText(MouseEvent) method so that it returns the text for the current column. To associate the revised table header with the table, the JTable method createDefaultTableHeader is overridden so that it returns an instance of the JTableHeader subclass.\r\n\r\nprotected String[] columnToolTips = {\r\n    null, // \"First Name\" assumed obvious\r\n    null, // \"Last Name\" assumed obvious\r\n    \"The person's favorite sport to participate in\",\r\n    \"The number of years the person has played the sport\",\r\n    \"If checked, the person eats no meat\"};\r\n...\r\n\r\nJTable table = new JTable(new MyTableModel()) {\r\n    ...\r\n\r\n    //Implement table header tool tips.\r\n    protected JTableHeader createDefaultTableHeader() {\r\n        return new JTableHeader(columnModel) {\r\n            public String getToolTipText(MouseEvent e) {\r\n                String tip = null;\r\n                java.awt.Point p = e.getPoint();\r\n                int index = columnModel.getColumnIndexAtX(p.x);\r\n                int realIndex = \r\n                        columnModel.getColumn(index).getModelIndex();\r\n                return columnToolTips[realIndex];\r\n            }\r\n        };\r\n    }\r\n};\r\n\r\nSorting and Filtering\r\nTable sorting and filtering is managed by a sorter object. The easiest way to provide a sorter object is to set autoCreateRowSorter bound property to true:\r\n\r\nJTable table = new JTable();\r\ntable.setAutoCreateRowSorter(true);\r\n\r\nThis action defines a row sorter that is an instance of \r\njavax.swing.table.TableRowSorter. This provides a table that does a simple locale-specific sort when the user clicks on a column header. This is demonstrated in \r\nTableSortDemo.java, as seen in this screen shot:\r\nTo have more control over sorting, you can construct an instance of TableRowSorter and specify that it is the sorter object for your table.\r\n\r\nTableRowSorter<TableModel> sorter \r\n    = new TableRowSorter<TableModel>(table.getModel());\r\ntable.setRowSorter(sorter);\r\n\r\nTableRowSorter uses \r\njava.util.Comparator objects to sort its rows. A class that implements this interface must provide a method called compare that defines how any two objects are compared for the purpose of sorting. For example, the following code creates a Comparator that sorts a set of strings by the last word in each string:\r\n\r\nComparator<String> comparator = new Comparator<String>() {\r\n    public int compare(String s1, String s2) {\r\n        String[] strings1 = s1.split(\"\\\\s\");\r\n        String[] strings2 = s2.split(\"\\\\s\");\r\n        return strings1[strings1.length - 1]\r\n            .compareTo(strings2[strings2.length - 1]);\r\n    }\r\n};\r\n\r\nThis example is fairly simplistic; more typically, a Comparator implementation is a subclass of \r\njava.text.Collator. You can define your own subclass, use the factory methods in Collator to obtain a Comparator for a specific locale, or use \r\njava.text.RuleBasedCollator.\r\nTo determine which Comparator to use for a column, TableRowSorter attempts to apply each of the following rules in turn. Rules are followed in the order listed below; the first rule that provides the sorter with a Comparator is used, and the remainining rules ignored.\r\n\r\nIf a comparator has been specified by invoking \r\nsetComparator, use that comparator.\r\nIf the table model reports that the column data consists of strings (TableModel.getColumnClass returns String.class for that column), use a comparator that sorts the strings based on the current locale.\r\nIf the column class returned by TableModel.getColumnClass implements Comparable, use a comparator that sorts the strings based on the values returned by \r\nComparable.compareTo.\r\nIf a string convertor has been specified for the table by invoking \r\nsetStringConverter, use a comparator that sorts the resulting string representations based on the current locale.\r\nIf none of the previous rules apply, use a comparator that invokes toString on the column data and sorts the resulting strings based on the current locale.\r\n\r\nFor more sophisticated kinds of sorting, subclass TableRowSorter or its parent class \r\njavax.swing.DefaultRowSorter.\r\nTo specify the sort order and sort precedence for columns, invoke \r\nsetSortKeys. Here is an example that sorts the table used in the examples by the first two columns. The precedence of the columns in the sort is indicated by the order of the sort keys in the sort key list. In this case, the second column has the first sort key, so they rows are sorted by first name, then last name.\r\n\r\nList <RowSorter.SortKey> sortKeys \r\n    = new ArrayList<RowSorter.SortKey>();\r\nsortKeys.add(new RowSorter.SortKey(1, SortOrder.ASCENDING));\r\nsortKeys.add(new RowSorter.SortKey(0, SortOrder.ASCENDING));\r\nsorter.setSortKeys(sortKeys); \r\n\r\nIn addition to reordering the results, a table sorter can also specify which rows will be displayed. This is known as filtering. TableRowSorter implements filtering using \r\njavax.swing.RowFilter objects. RowFilter implements several factory methods that create common kinds of filters. For example, \r\nregexFilter returns a RowFilter that filters based on a \r\nregular expression.\r\nIn the following example code, you explicitly create a sorter object so you can later use it to specify a filter:\r\n\r\nMyTableModel model = new MyTableModel();\r\nsorter = new TableRowSorter<MyTableModel>(model);\r\ntable = new JTable(model);\r\ntable.setRowSorter(sorter);\r\n\r\nThen you filter based on the current value of a text field:\r\n\r\nprivate void newFilter() {\r\n    RowFilter<MyTableModel, Object> rf = null;\r\n    //If current expression doesn't parse, don't update.\r\n    try {\r\n        rf = RowFilter.regexFilter(filterText.getText(), 0);\r\n    } catch (java.util.regex.PatternSyntaxException e) {\r\n        return;\r\n    }\r\n    sorter.setRowFilter(rf);\r\n}\r\n\r\nIn a subsequent example, newFilter() is invoked every time the text field changes. When the user enters complicated regular expressions, the try...catch prevents the syntax exception from interfering with input.\r\nWhen a table uses a sorter, the data the users sees may be in a different order than that specified by the data model, and may not include all rows specified by the data model. The data the user actually sees is known as the view, and has its own set of coordinates. JTable provides methods that convert from model coordinates to view coordinates â\u20ac\u201d \r\nconvertColumnIndexToView and \r\nconvertRowIndexToView â\u20ac\u201d and that convert from view coordinates to model coordinates â\u20ac\u201d \r\nconvertColumnIndexToModel and \r\nconvertRowIndexToModel.\r\nNOTE:Â When using a sorter, always remember to translate cell coordinates.\r\n\r\nThe following example brings together the ideas discussed in this section. \r\nTableFilterDemo.java adds a small number of changes to TableDemo. These include the code snippets earlier in this section, which provide a sorter for the main table, and use a text field to supply the filtering regular expression. The following screen shot shows TableFilterDemo before any sorting or filtering has been done. Notice that row 3 in the model is still the same as row 3 in the view:\r\nIf the user clicks twice on the second column, the fourth row becomes the first row â\u20ac\u201d but only in the view:\r\nAs previously noted, the text the user enters in the \"Filter Text\" text field defines a filter that determines which rows are shown. As with sorting, filtering can cause view coordinates to diverge from model coordinates:\r\nHere is the code that updates the status field to reflect the current selection:\r\n\r\ntable.getSelectionModel().addListSelectionListener(\r\n        new ListSelectionListener() {\r\n            public void valueChanged(ListSelectionEvent event) {\r\n                int viewRow = table.getSelectedRow();\r\n                if (viewRow < 0) {\r\n                    //Selection got filtered away.\r\n                    statusText.setText(\"\");\r\n                } else {\r\n                    int modelRow = \r\n                        table.convertRowIndexToModel(viewRow);\r\n                    statusText.setText(\r\n                        String.format(\"Selected Row in view: %d. \" +\r\n                            \"Selected Row in model: %d.\", \r\n                            viewRow, modelRow));\r\n                }\r\n            }\r\n        }\r\n);\r\n\r\nUsing a Combo Box as an Editor\r\nSetting up a combo box as an editor is simple, as the following example shows. The bold line of code sets up the combo box as the editor for a specific column.\r\n\r\nTableColumn sportColumn = table.getColumnModel().getColumn(2);\r\n...\r\nJComboBox comboBox = new JComboBox();\r\ncomboBox.addItem(\"Snowboarding\");\r\ncomboBox.addItem(\"Rowing\");\r\ncomboBox.addItem(\"Chasing toddlers\");\r\ncomboBox.addItem(\"Speed reading\");\r\ncomboBox.addItem(\"Teaching high school\");\r\ncomboBox.addItem(\"None\");\r\nsportColumn.setCellEditor(new DefaultCellEditor(comboBox));\r\n\r\nHere is a picture of the combo box editor in use:\r\nThe preceding code is from \r\nTableRenderDemo.java. You can run TableRenderDemo (click the Launch button) using \r\nJavaâ\u201e¢ Web Start (download JDK 7 or later). Or, to compile and run the example yourself, consult the example index.\r\n\r\nUsing Other Editors\r\nWhether you are setting the editor for a single column of cells (using the TableColumn setCellEditor method) or for a specific type of data (using the JTable setDefaultEditor method), you specify the editor using an argument that adheres to the TableCellEditor interface. Fortunately, the DefaultCellEditor class implements this interface and provides constructors to let you specify an editing component that is a JTextField, JCheckBox, or JComboBox. Usually you do not have to explicitly specify a check box as an editor, since columns with Boolean data automatically use a check box renderer and editor.\r\nWhat if you want to specify an editor other than a text field, check box, or combo box? As DefaultCellEditor does not support other types of components, you must do a little more work. You need to create a class that implements the \r\nTableCellEditor interface. The \r\nAbstractCellEditor class is a good superclass to use. It implements TableCellEditor's superinterface, \r\nCellEditor, saving you the trouble of implementing the event firing code necessary for cell editors.\r\nYour cell editor class needs to define at least two methods â\u20ac\u201d getCellEditorValue and getTableCellEditorComponent. The getCellEditorValue method, required by CellEditor, returns the cell's current value. The getTableCellEditorComponent method, required by TableCellEditor, should configure and return the component that you want to use as the editor.\r\nHere is a picture of a table with a dialog that serves, indirectly, as a cell editor. When the user begins editing a cell in the Favorite Color column, a button (the true cell editor) appears and brings up the dialog, with which the user can choose a different color.\r\n\r\nYou can run TableDialogEditDemo (click the Launch button) using \r\nJavaâ\u201e¢ Web Start (download JDK 7 or later). Or, to compile and run the example yourself, consult the example index.\r\n\r\nHere is the code, taken from \r\nColorEditor.java, that implements the cell editor.\r\n\r\npublic class ColorEditor extends AbstractCellEditor\r\n                         implements TableCellEditor,\r\n                                    ActionListener {\r\n    Color currentColor;\r\n    JButton button;\r\n    JColorChooser colorChooser;\r\n    JDialog dialog;\r\n    protected static final String EDIT = \"edit\";\r\n\r\n    public ColorEditor() {\r\n        button = new JButton();\r\n        button.setActionCommand(EDIT);\r\n        button.addActionListener(this);\r\n        button.setBorderPainted(false);\r\n\r\n        //Set up the dialog that the button brings up.\r\n        colorChooser = new JColorChooser();\r\n        dialog = JColorChooser.createDialog(button,\r\n                                        \"Pick a Color\",\r\n                                        true,  //modal\r\n                                        colorChooser,\r\n                                        this,  //OK button handler\r\n                                        null); //no CANCEL button handler\r\n    }\r\n\r\n    public void actionPerformed(ActionEvent e) {\r\n        if (EDIT.equals(e.getActionCommand())) {\r\n            //The user has clicked the cell, so\r\n            //bring up the dialog.\r\n            button.setBackground(currentColor);\r\n            colorChooser.setColor(currentColor);\r\n            dialog.setVisible(true);\r\n\r\n            fireEditingStopped(); //Make the renderer reappear.\r\n\r\n        } else { //User pressed dialog's \"OK\" button.\r\n            currentColor = colorChooser.getColor();\r\n        }\r\n    }\r\n\r\n    //Implement the one CellEditor method that AbstractCellEditor doesn't.\r\n    public Object getCellEditorValue() {\r\n        return currentColor;\r\n    }\r\n\r\n    //Implement the one method defined by TableCellEditor.\r\n    public Component getTableCellEditorComponent(JTable table,\r\n                                                 Object value,\r\n                                                 boolean isSelected,\r\n                                                 int row,\r\n                                                 int column) {\r\n        currentColor = (Color)value;\r\n        return button;\r\n    }\r\n}\r\n\r\nAs you can see, the code is pretty simple. The only part that is a bit tricky is the call to fireEditingStopped at the end of the editor button's action handler. Without this call, the editor would remain active, even though the modal dialog is no longer visible. The call to fireEditingStopped lets the table know that it can deactivate the editor, letting the cell be handled by the renderer again.\r\nUsing an Editor to Validate User-Entered Text\r\nIf a cell's default editor allows text entry, you get some error checking for free if the cell's type is specified as something other than String or Object. The error checking is a side effect of converting the entered text into an object of the proper type.\r\nThe automatic checking of user-entered strings occurs when the default editor attempts to create a new instance of the class associated with the cell's column. The default editor creates this instance using a constructor that takes a String as an argument. For example, in a column whose cells have type Integer, when the user types in \"123\" the default editor creates the corresponding Integer using code equivalent to new Integer(\"123\"). If the constructor throws an exception, the cell's outline turns red and refuses to let focus move out of the cell. If you implement a class used as a column data type, you can use the default editor if your class supplies a constructor that takes a single argument of type String.\r\nIf you like having a text field as the editor for a cell, but want to customize it â\u20ac\u201d perhaps to check user-entered text more strictly or to react differently when the text is invalid â\u20ac\u201d you can change the cell editor to use a formatted text field. The formatted text field can check the value either continuously while the user is typing or after the user has indicated the end of typing (such as by pressing Enter).\r\nThe following code, taken from a demo named \r\nTableFTFEditDemo.java, sets up a formatted text field as an editor that limits all integer values to be between 0 and 100. You can run TableFTFEditDemo (click the Launch button) using \r\nJavaâ\u201e¢ Web Start (download JDK 7 or later). Or, to compile and run the example yourself, consult the example index.\r\n\r\nThe following code makes the formatted text field the editor for all columns that contain data of type Integer.\r\n\r\ntable.setDefaultEditor(Integer.class,\r\n                       new IntegerEditor(0, 100));\r\n\r\nThe IntegerEditor class is implemented as a subclass of \r\nDefaultCellEditor that uses a JFormattedTextField instead of the JTextField that DefaultCellEditor supports. It accomplishes this by first setting up a formatted text field to use an integer format and have the specified minimum and maximum values, using the API described in How to Use Formatted Text Fields. It then overrides the DefaultCellEditor implementation of the getTableCellEditorComponent, getCellEditorValue, and stopCellEditing methods, adding the operations that are necessary for formatted text fields.\r\nThe override of getTableCellEditorComponent sets the formatted text field's value property (and not just the text property it inherits from JTextField) before the editor is shown. The override of getCellEditorValue keeps the cell value as an Integer, rather than, say, the Long value that the formatted text field's parser tends to return. Finally, overriding stopCellEditing lets you check whether the text is valid, possibly stopping the editor from being dismissed. If the text isn't valid, your implementation of stopCellEditing puts up a dialog that gives the user the option of continuing to edit or reverting to the last good value. The source code is a bit too long to include here, but you can find it in \r\nIntegerEditor.java.\r\nPrinting\r\nJTable provides a simple API for printing tables. The easiest way to print out a table is to invoke \r\nJTable.print with no arguments:\r\n\r\ntry {\r\n    if (! table.print()) {\r\n        System.err.println(\"User cancelled printing\");\r\n    }\r\n} catch (java.awt.print.PrinterException e) {\r\n    System.err.format(\"Cannot print %s%n\", e.getMessage());\r\n}\r\n\r\nInvoking print on a normal Swing application brings up a standard printing dialog box. (On a headless application, the table is simply printed.) The return value indicates whether the user went ahead with the print job or cancelled it. JTable.print can throw java.awt.print.PrinterException, which is a \r\nchecked exception; that's why the above example uses a try ... catch.\r\nJTable provides several overloads of print with various options. The following code from \r\nTablePrintDemo.java shows how to define a page header:\r\n\r\nMessageFormat header = new MessageFormat(\"Page {0,number,integer}\");\r\ntry {\r\n    table.print(JTable.PrintMode.FIT_WIDTH, header, null);\r\n} catch (java.awt.print.PrinterException e) {\r\n    System.err.format(\"Cannot print %s%n\", e.getMessage());\r\n}\r\n\r\nFor more sophisticated printing applications, use \r\nJTable.getPrintable to obtain a Printable object for the table. For more on Printable, refer to the \r\nPrinting lesson in the \r\n2D Graphics trail.\r\nExamples that Use Tables\r\nThis table lists examples that use JTable and where those examples are described.\r\n\r\n\r\n\r\nExample\r\nWhere Described\r\nNotes\r\n\r\n\r\nSimpleTableDemo\r\nCreating a Simple Table\r\nA basic table with no custom model. Does not include code to specify column widths or detect user editing.\r\n\r\n\r\nSimpleTable-\r\nSelectionDemo\r\nDetecting User Selections\r\nAdds single selection and selection detection to SimpleTableDemo. By modifying the program's ALLOW_COLUMN_SELECTION and ALLOW_ROW_SELECTION constants, you can experiment with alternatives to the table default of allowing only rows to be selected.\r\n\r\n\r\nTableDemo\r\nCreating a Table Model\r\nA basic table with a custom model.\r\n\r\n\r\nTableFTFEditDemo\r\nUsing an Editor to Validate User-Entered Text\r\nModifies TableDemo to use a custom editor (a formatted text field variant) for all Integer data.\r\n\r\n\r\nTableRenderDemo\r\nUsing a Combo Box as an Editor\r\nModifies TableDemo to use a custom editor (a combo box) for all data in the Sport column. Also intelligently picks column sizes. Uses renderers to display tool tips for the sport cells.\r\n\r\n\r\nTableDialogEditDemo\r\nUsing Other Editors\r\nModifies TableDemo to have a cell renderer and editor that display a color and let you choose a new one, using a color chooser dialog.\r\n\r\n\r\nTableToolTipsDemo\r\nSpecifying Tool Tips for Cells, Specifying Tool Tips for Column Headers,\r\nDemonstrates how to use several techniques to set tool tip text for cells and column headers.\r\n\r\n\r\nTableSortDemo\r\nSorting and Filtering\r\nDemonstrates the default sorter, which allows the user to sort columns by clicking on their headers.\r\n\r\n\r\nTableFilterDemo\r\nSorting and Filtering\r\nDemonstrates sorting and filtering, and how this can cause the view coordinates to diverge from the model coordinates.\r\n\r\n\r\nTablePrintDemo\r\nPrinting\r\nDemonstrates table printing.\r\n\r\n\r\nListSelectionDemo\r\nHow to Write a List Selection Listener\r\nShows how to use all list selection modes, using a list selection listener that's shared between a table and list.\r\n\r\n\r\nSharedModelDemo\r\nNowhere\r\nBuilds on ListSelectionDemo making the data model be shared between the table and list. If you edit an item in the first column of the table, the new value is reflected in the list.\r\n\r\n\r\n\r\n",
        "title": "Oracle_How to Use Tables.txt",
        "type": "Oracle_"
    }, {
        "rank": 10,
        "text": "\r\n\r\nUp until now, we have primarily focused on attaching a TransferHandler to one of the JComponent subclasses. But you can also set a TransferHandler directly on a top-level container, such as JFrame and JDialog.\r\nThis is particularly useful for applications that import files, such as editors, IDEs, image manipulation programs, CD burning programs. Such an application generally includes a menu, a toolbar, an area for editing documents, and probably a list or mechanism for switching between open documents.\r\nWe have such an example but because this demo reads files, we do not provide a Java Web Start version â\u20ac\u201d you will have to download and compile the demo yourself.\r\nAs you can see in the screen shot below, TopLevelTransferHandlerDemo has a menu (empty, except for the Demo submenu), a (non-functional) toolbar, an area (on the left) that displays a list of open documents, and a area (to the right) that displays the content of each open document. At startup the blue document area has been assigned a transfer handler that supports file imports â\u20ac\u201d so is the only place that can accept a drop.\r\nTry this:Â \r\nCompile and run the \r\nTopLevelTransferHandlerDemo example, consult the example index if you would like to download a zip file structured for NetBeans.\r\nDrag a file from your native desktop or file system and drop it on the blue document area to the right. The file is opened and a frame filled with its contents will appear. The document area, a JDesktopPane, contains a transfer handler that supports import of javaFileListFlavor.\r\nDrag another file and attempt to drop it on the document area. You will find that you cannot drop it on top of the frame displaying the last file. You also cannot drop it on the list, the menu, or the toolbar. The only place you can drop is the blue portion of the document area or on the menu bar of a previously opened frame. Inside each content frame there is a text component's transfer handler that doesn't understand a file drop â\u20ac\u201d you can drop text into that area, but not a file.\r\nFrom the menu, choose Demo->Use Top-Level TransferHandler to install the transfer handler on the top-level container â\u20ac\u201d a JFrame.\r\nTry dragging over the demo again. The number of areas that accept drops has increased. You can now drop most anywhere on the application including the menu bar, toolbar, the frame's title bar, except for the list (on the left) or the content area of a previously opened file. Neither the JList's nor the text area's transfer handlers know how to import files.\r\nDisable the transfer handlers on those remaining components by choosing Demo->Remove TransferHandler from List and Text from the menu.\r\nDrag over the demo again. You can now drop a file anywhere on the application!\r\nFrom the menu, choose Demo->Use COPY Action.\r\nDrag over the demo again. Note that the mouse cursor now shows the COPY cursor â\u20ac\u201d this provides more accurate feedback because a successful drop does not remove the file from the source. The target can be programmed to select from the available drop actions as described in \r\nChoosing the Drop Action.\r\n\r\n\r\nNote one undesirable side effect of disabling the default transfer handler on the text component: You can no longer drag and drop (or cut/copy/paste) text within the editing area. To fix this, you will need to implement a custom transfer handler for the text component that accepts file drops and also re-implements the missing support for text transfers. You might want to watch \r\nRFE 4830695 which would allow adding data import on top of an existing TransferHandler.\r\nHere is the source code for \r\nTopLevelTransferHandlerDemo.java:\r\n\r\n/**\r\n * Demonstration of the top-level {@code TransferHandler}\r\n * support on {@code JFrame}.\r\n */\r\npublic class TopLevelTransferHandlerDemo extends JFrame {\r\n    \r\n    private static boolean DEMO = false;\r\n\r\n    private JDesktopPane dp = new JDesktopPane();\r\n    private DefaultListModel listModel = new DefaultListModel();\r\n    private JList list = new JList(listModel);\r\n    private static int left;\r\n    private static int top;\r\n    private JCheckBoxMenuItem copyItem;\r\n    private JCheckBoxMenuItem nullItem;\r\n    private JCheckBoxMenuItem thItem;\r\n\r\n    private class Doc extends InternalFrameAdapter implements ActionListener {\r\n        String name;\r\n        JInternalFrame frame;\r\n        TransferHandler th;\r\n        JTextArea area;\r\n\r\n        public Doc(File file) {\r\n            this.name = file.getName();\r\n            try {\r\n                init(file.toURI().toURL());\r\n            } catch (MalformedURLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        \r\n        public Doc(String name) {\r\n            this.name = name;\r\n            init(getClass().getResource(name));\r\n        }\r\n        \r\n        private void init(URL url) {\r\n            frame = new JInternalFrame(name);\r\n            frame.addInternalFrameListener(this);\r\n            listModel.add(listModel.size(), this);\r\n\r\n            area = new JTextArea();\r\n            area.setMargin(new Insets(5, 5, 5, 5));\r\n\r\n            try {\r\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\r\n                String in;\r\n                while ((in = reader.readLine()) != null) {\r\n                    area.append(in);\r\n                    area.append(\"\\n\");\r\n                }\r\n                reader.close();\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n                return;\r\n            }\r\n\r\n            th = area.getTransferHandler();\r\n            area.setFont(new Font(\"monospaced\", Font.PLAIN, 12));\r\n            area.setCaretPosition(0);\r\n            area.setDragEnabled(true);\r\n            area.setDropMode(DropMode.INSERT);\r\n            frame.getContentPane().add(new JScrollPane(area));\r\n            dp.add(frame);\r\n            frame.show();\r\n            if (DEMO) {\r\n                frame.setSize(300, 200);\r\n            } else {\r\n                frame.setSize(400, 300);\r\n            }\r\n            frame.setResizable(true);\r\n            frame.setClosable(true);\r\n            frame.setIconifiable(true);\r\n            frame.setMaximizable(true);\r\n            frame.setLocation(left, top);\r\n            incr();\r\n            SwingUtilities.invokeLater(new Runnable() {\r\n                public void run() {\r\n                    select();\r\n                }\r\n            });\r\n            nullItem.addActionListener(this);\r\n            setNullTH();\r\n        }\r\n\r\n        public void internalFrameClosing(InternalFrameEvent event) {\r\n            listModel.removeElement(this);\r\n            nullItem.removeActionListener(this);\r\n        }\r\n\r\n        public void internalFrameOpened(InternalFrameEvent event) {\r\n            int index = listModel.indexOf(this);\r\n            list.getSelectionModel().setSelectionInterval(index, index);\r\n        }\r\n\r\n        public void internalFrameActivated(InternalFrameEvent event) {\r\n            int index = listModel.indexOf(this);\r\n            list.getSelectionModel().setSelectionInterval(index, index);\r\n        }\r\n\r\n        public String toString() {\r\n            return name;\r\n        }\r\n        \r\n        public void select() {\r\n            try {\r\n                frame.toFront();\r\n                frame.setSelected(true);\r\n            } catch (java.beans.PropertyVetoException e) {}\r\n        }\r\n        \r\n        public void actionPerformed(ActionEvent ae) {\r\n            setNullTH();\r\n        }\r\n        \r\n        public void setNullTH() {\r\n            if (nullItem.isSelected()) {\r\n                area.setTransferHandler(null);\r\n            } else {\r\n                area.setTransferHandler(th);\r\n            }\r\n        }\r\n    }\r\n\r\n    private TransferHandler handler = new TransferHandler() {\r\n        public boolean canImport(TransferHandler.TransferSupport support) {\r\n            if (!support.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {\r\n                return false;\r\n            }\r\n\r\n            if (copyItem.isSelected()) {\r\n                boolean copySupported = (COPY & support.getSourceDropActions()) == COPY;\r\n\r\n                if (!copySupported) {\r\n                    return false;\r\n                }\r\n\r\n                support.setDropAction(COPY);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        public boolean importData(TransferHandler.TransferSupport support) {\r\n            if (!canImport(support)) {\r\n                return false;\r\n            }\r\n            \r\n            Transferable t = support.getTransferable();\r\n\r\n            try {\r\n                java.util.List<File> l =\r\n                    (java.util.List<File>)t.getTransferData(DataFlavor.javaFileListFlavor);\r\n\r\n                for (File f : l) {\r\n                    new Doc(f);\r\n                }\r\n            } catch (UnsupportedFlavorException e) {\r\n                return false;\r\n            } catch (IOException e) {\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    };\r\n\r\n    private static void incr() {\r\n        left += 30;\r\n        top += 30;\r\n        if (top == 150) {\r\n            top = 0;\r\n        }\r\n    }\r\n\r\n    public TopLevelTransferHandlerDemo() {\r\n        super(\"TopLevelTransferHandlerDemo\");\r\n        setJMenuBar(createDummyMenuBar());\r\n        getContentPane().add(createDummyToolBar(), BorderLayout.NORTH);\r\n\r\n        JSplitPane sp = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, list, dp);\r\n        sp.setDividerLocation(120);\r\n        getContentPane().add(sp);\r\n        //new Doc(\"sample.txt\");\r\n        //new Doc(\"sample.txt\");\r\n        //new Doc(\"sample.txt\");\r\n\r\n        list.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\r\n\r\n        list.addListSelectionListener(new ListSelectionListener() {\r\n            public void valueChanged(ListSelectionEvent e) {\r\n                if (e.getValueIsAdjusting()) {\r\n                    return;\r\n                }\r\n                \r\n                Doc val = (Doc)list.getSelectedValue();\r\n                if (val != null) {\r\n                    val.select();\r\n                }\r\n             }\r\n        });\r\n        \r\n        final TransferHandler th = list.getTransferHandler();\r\n\r\n        nullItem.addActionListener(new ActionListener() {\r\n            public void actionPerformed(ActionEvent ae) {\r\n                if (nullItem.isSelected()) {\r\n                    list.setTransferHandler(null);\r\n                } else {\r\n                    list.setTransferHandler(th);\r\n                }\r\n            }\r\n        });\r\n        thItem.addActionListener(new ActionListener() {\r\n            public void actionPerformed(ActionEvent ae) {\r\n                if (thItem.isSelected()) {\r\n                    setTransferHandler(handler);\r\n                } else {\r\n                    setTransferHandler(null);\r\n                }\r\n            }\r\n        });\r\n        dp.setTransferHandler(handler);\r\n    }\r\n\r\n    private static void createAndShowGUI(String[] args) {\r\n        try {\r\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n        } catch (Exception e) {\r\n        }\r\n\r\n        TopLevelTransferHandlerDemo test = new TopLevelTransferHandlerDemo();\r\n        test.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n        if (DEMO) {\r\n            test.setSize(493, 307);\r\n        } else {\r\n            test.setSize(800, 600);\r\n        }\r\n        test.setLocationRelativeTo(null);\r\n        test.setVisible(true);\r\n        test.list.requestFocus();\r\n    }\r\n    \r\n    public static void main(final String[] args) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                //Turn off metal's use of bold fonts\r\n                UIManager.put(\"swing.boldMetal\", Boolean.FALSE);\r\n                createAndShowGUI(args);\r\n            }\r\n        });\r\n    }\r\n    \r\n    private JToolBar createDummyToolBar() {\r\n        JToolBar tb = new JToolBar();\r\n        JButton b;\r\n        b = new JButton(\"New\");\r\n        b.setRequestFocusEnabled(false);\r\n        tb.add(b);\r\n        b = new JButton(\"Open\");\r\n        b.setRequestFocusEnabled(false);\r\n        tb.add(b);\r\n        b = new JButton(\"Save\");\r\n        b.setRequestFocusEnabled(false);\r\n        tb.add(b);\r\n        b = new JButton(\"Print\");\r\n        b.setRequestFocusEnabled(false);\r\n        tb.add(b);\r\n        b = new JButton(\"Preview\");\r\n        b.setRequestFocusEnabled(false);\r\n        tb.add(b);\r\n        tb.setFloatable(false);\r\n        return tb;\r\n    }\r\n    \r\n    private JMenuBar createDummyMenuBar() {\r\n        JMenuBar mb = new JMenuBar();\r\n        mb.add(createDummyMenu(\"File\"));\r\n        mb.add(createDummyMenu(\"Edit\"));\r\n        mb.add(createDummyMenu(\"Search\"));\r\n        mb.add(createDummyMenu(\"View\"));\r\n        mb.add(createDummyMenu(\"Tools\"));\r\n        mb.add(createDummyMenu(\"Help\"));\r\n        \r\n        JMenu demo = new JMenu(\"Demo\");\r\n        demo.setMnemonic(KeyEvent.VK_D);\r\n        mb.add(demo);\r\n\r\n        thItem = new JCheckBoxMenuItem(\"Use Top-Level TransferHandler\");\r\n        thItem.setMnemonic(KeyEvent.VK_T);\r\n        demo.add(thItem);\r\n\r\n        nullItem = new JCheckBoxMenuItem(\"Remove TransferHandler from List and Text\");\r\n        nullItem.setMnemonic(KeyEvent.VK_R);\r\n        demo.add(nullItem);\r\n\r\n        copyItem = new JCheckBoxMenuItem(\"Use COPY Action\");\r\n        copyItem.setMnemonic(KeyEvent.VK_C);\r\n        demo.add(copyItem);\r\n\r\n        return mb;\r\n    }\r\n    \r\n    private JMenu createDummyMenu(String str) {\r\n        JMenu menu = new JMenu(str);\r\n        JMenuItem item = new JMenuItem(\"[Empty]\");\r\n        item.setEnabled(false);\r\n        menu.add(item);\r\n        return menu;\r\n    }\r\n}\r\n\r\n",
        "title": "Oracle_Top-Level Drop.txt",
        "type": "Oracle_"
    }]
}

post2_rec = {
    "response": [{
        "rank": 1,
        "text": "\r\nThis lesson covers the Java platform classes used for basic I/O. It first focuses on I/O Streams, a powerful concept that greatly simplifies I/O operations. The lesson also looks at serialization, which lets a program write whole objects out to streams and read them back again. Then the lesson looks at file I/O and file system operations, including random access files.\r\nMost of the classes covered in the I/O Streams section are in the java.io package. Most of the classes covered in the File I/O section are in the java.nio.file package.\r\nI/O Streams\r\n\r\nByte Streams handle I/O of raw binary data.\r\nCharacter Streams handle I/O of character data, automatically handling translation to and from the local character set.\r\nBuffered Streams optimize input and output by reducing the number of calls to the native API.\r\nScanning and Formatting allows a program to read and write formatted text.\r\nI/O from the Command Line describes the Standard Streams and the Console object.\r\nData Streams handle binary I/O of primitive data type and String values.\r\nObject Streams handle binary I/O of objects.\r\n\r\nFile I/O (Featuring NIO.2)\r\n\r\nWhat is a Path? examines the concept of a path on a file system.\r\nThe Path Class introduces the cornerstone class of the java.nio.file package.\r\nPath Operations looks at methods in the Path class that deal with syntactic operations.\r\nFile Operations introduces concepts common to many of the file I/O methods.\r\nChecking a File or Directory shows how to check a file's existence and its level of accessibility.\r\nDeleting a File or Directory.\r\nCopying a File or Directory.\r\nMoving a File or Directory.\r\nManaging Metadata explains how to read and set file attributes.\r\nReading, Writing and Creating Files shows the stream and channel methods for reading and writing files.\r\nRandom Access Files shows how to read or write files in a non-sequentially manner.\r\nCreating and Reading Directories covers API specific to directories, such as how to list a directory's contents.\r\nLinks, Symbolic or Otherwise covers issues specific to symbolic and hard links.\r\nWalking the File Tree demonstrates how to recursively visit each file and directory in a file tree.\r\nFinding Files shows how to search for files using pattern matching.\r\nWatching a Directory for Changes shows how to use the watch service to detect files that are added, removed or updated in one or more directories.\r\nOther Useful Methods covers important API that didn't fit elsewhere in the lesson.\r\nLegacy File I/O Code shows how to leverage Path functionality if you have older code using the java.io.File class. A table mapping java.io.File API to java.nio.file API is provided.\r\n\r\nSummary\r\nA summary of the key points covered in this trail.\r\nQuestions and Exercises\r\nTest what you've learned in this trail by trying these questions and exercises.\r\nThe I/O Classes in Action\r\nMany of the examples in the next trail, \r\nCustom Networking use the I/O streams described in this lesson to read from and write to network connections.\r\nSecurity consideration:Â Some I/O operations are subject to approval by the current security manager. The example programs contained in these lessons are standalone applications, which by default have no security manager. To work in an applet, most of these examples would have to be modified. See \r\nWhat Applets Can and Cannot Do for information about the security restrictions placed on applets.\r\n\r\n",
        "title": "Oracle_Basic I-O.txt",
        "type": "Oracle_"
    }, {
        "rank": 2,
        "text": "\r\nQuestions\r\n\r\nConsider the following code snippet.\r\n\r\narrayOfInts[j] > arrayOfInts[j+1]\r\n\r\nWhich operators does the code contain?\r\nConsider the following code snippet.\r\n\r\nint i = 10;\r\nint n = i++%5;\r\n\r\n\r\nWhat are the values of i and n after the code is executed?\r\nWhat are the final values of i and n if instead of using the postfix increment operator (i++), you use the prefix version (++i))?\r\n\r\n\r\nTo invert the value of a boolean, which operator would you use?\r\nWhich operator is used to compare two values, = or == ?\r\nExplain the following code sample: result = someCondition ? value1 : value2;\r\n\r\nExercises\r\n\r\nChange the following program to use compound assignments:\r\n\r\nclass ArithmeticDemo {\r\n\r\n     public static void main (String[] args){\r\n          \r\n          int result = 1 + 2; // result is now 3\r\n          System.out.println(result);\r\n\r\n          result = result - 1; // result is now 2\r\n          System.out.println(result);\r\n\r\n          result = result * 2; // result is now 4\r\n          System.out.println(result);\r\n\r\n          result = result / 2; // result is now 2\r\n          System.out.println(result);\r\n\r\n          result = result + 8; // result is now 10\r\n          result = result % 7; // result is now 3\r\n          System.out.println(result);\r\n     }\r\n}\r\n\r\n\r\n\r\nIn the following program, explain why the value \"6\" is printed twice in a row:\r\n\r\nclass PrePostDemo {\r\n    public static void main(String[] args){\r\n        int i = 3;\r\n        i++;\r\n        System.out.println(i);    // \"4\"\r\n        ++i;                     \r\n        System.out.println(i);    // \"5\"\r\n        System.out.println(++i);  // \"6\"\r\n        System.out.println(i++);  // \"6\"\r\n        System.out.println(i);    // \"7\"\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nCheck your answers\r\n",
        "title": "Oracle_Questions and Exercises Operators.txt",
        "type": "Oracle_"
    }, {
        "rank": 3,
        "text": "\r\n\r\nThe \r\nFiles class is the other primary entrypoint of the java.nio.file package. This class offers a rich set of static methods for reading, writing, and manipulating files and directories. The Files methods work on instances of Path objects. Before proceeding to the remaining sections, you should familiarize yourself with the following common concepts:\r\n\r\nReleasing System Resources\r\nCatching Exceptions\r\nVarargs\r\nAtomic Operations\r\nMethod Chaining\r\nWhat Is a Glob?\r\nLink Awareness\r\n\r\nReleasing System Resources\r\nMany of the resources that are used in this API, such as streams or channels, implement or extend the \r\njava.io.Closeable interface. A requirement of a Closeable resource is that the close method must be invoked to release the resource when no longer required. Neglecting to close a resource can have a negative implication on an application's performance. The try-with-resources statement, described in the next section, handles this step for you.\r\nCatching Exceptions\r\nWith file I/O, unexpected conditions are a fact of life: a file exists (or doesn't exist) when expected, the program doesn't have access to the file system, the default file system implementation does not support a particular function, and so on. Numerous errors can be encountered.\r\nAll methods that access the file system can throw an IOException. It is best practice to catch these exceptions by embedding these methods into a try-with-resources statement, introduced in the Java SE 7 release. The try-with-resources statement has the advantage that the compiler automatically generates the code to close the resource(s) when no longer required. The following code shows how this might look:\r\n\r\nCharset charset = Charset.forName(\"US-ASCII\");\r\nString s = ...;\r\ntry (BufferedWriter writer = Files.newBufferedWriter(file, charset)) {\r\n    writer.write(s, 0, s.length());\r\n} catch (IOException x) {\r\n    System.err.format(\"IOException: %s%n\", x);\r\n}\r\n\r\nFor more information, see \r\nThe try-with-resources Statement.\r\nAlternatively, you can embed the file I/O methods in a try block and then catch any exceptions in a catch block. If your code has opened any streams or channels, you should close them in a finally block. The previous example would look something like the following using the try-catch-finally approach:\r\n\r\nCharset charset = Charset.forName(\"US-ASCII\");\r\nString s = ...;\r\nBufferedWriter writer = null;\r\ntry {\r\n    writer = Files.newBufferedWriter(file, charset);\r\n    writer.write(s, 0, s.length());\r\n} catch (IOException x) {\r\n    System.err.format(\"IOException: %s%n\", x);\r\n} finally {\r\n    if (writer != null) writer.close();\r\n}\r\n\r\nFor more information, see \r\nCatching and Handling Exceptions.\r\nIn addition to IOException, many specific exceptions extend \r\nFileSystemException. This class has some useful methods that return the file involved \r\n(getFile), the detailed message string \r\n(getMessage), the reason why the file system operation failed \r\n(getReason), and the \"other\" file involved, if any \r\n(getOtherFile).\r\nThe following code snippet shows how the getFile method might be used:\r\n\r\ntry (...) {\r\n    ...    \r\n} catch (NoSuchFileException x) {\r\n    System.err.format(\"%s does not exist\\n\", x.getFile());\r\n}\r\n\r\nFor purposes of clarity, the file I/O examples in this lesson may not show exception handling, but your code should always include it.\r\nVarargs\r\nSeveral Files methods accept an arbitrary number of arguments when flags are specified. For example, in the following method signature, the ellipses notation after the CopyOption argument indicates that the method accepts a variable number of arguments, or varargs, as they are typically called:\r\n\r\nPath Files.move(Path, Path, CopyOption...)\r\n\r\nWhen a method accepts a varargs argument, you can pass it a comma-separated list of values or an array (CopyOption[]) of values.\r\nIn the move example, the method can be invoked as follows:\r\n\r\nimport static java.nio.file.StandardCopyOption.*;\r\n\r\nPath source = ...;\r\nPath target = ...;\r\nFiles.move(source,\r\n           target,\r\n           REPLACE_EXISTING,\r\n           ATOMIC_MOVE);\r\n\r\nFor more information about varargs syntax, see \r\nArbitrary Number of Arguments.\r\nAtomic Operations\r\nSeveral Files methods, such as move, can perform certain operations atomically in some file systems.\r\nAn atomic file operation is an operation that cannot be interrupted or \"partially\" performed. Either the entire operation is performed or the operation fails. This is important when you have multiple processes operating on the same area of the file system, and you need to guarantee that each process accesses a complete file.\r\nMethod Chaining\r\nMany of the file I/O methods support the concept of method chaining.\r\nYou first invoke a method that returns an object. You then immediately invoke a method on that object, which returns yet another object, and so on. Many of the I/O examples use the following technique:\r\n\r\nString value = Charset.defaultCharset().decode(buf).toString();\r\nUserPrincipal group =\r\n    file.getFileSystem().getUserPrincipalLookupService().\r\n         lookupPrincipalByName(\"me\");\r\n\r\nThis technique produces compact code and enables you to avoid declaring temporary variables that you don't need.\r\nWhat Is a Glob?\r\nTwo methods in the Files class accept a glob argument, but what is a glob?\r\nYou can use glob syntax to specify pattern-matching behavior.\r\nA glob pattern is specified as a string and is matched against other strings, such as directory or file names. Glob syntax follows several simple rules:\r\n\r\nAn asterisk, *, matches any number of characters (including none).\r\nTwo asterisks, **, works like * but crosses directory boundaries. This syntax is generally used for matching complete paths.\r\nA question mark, ?, matches exactly one character.\r\nBraces specify a collection of subpatterns. For example:\r\n\r\n{sun,moon,stars} matches \"sun\", \"moon\", or \"stars\".\r\n{temp*,tmp*} matches all strings beginning with \"temp\" or \"tmp\".\r\n\r\n\r\nSquare brackets convey a set of single characters or, when the hyphen character (-) is used, a range of characters. For example:\r\n\r\n[aeiou] matches any lowercase vowel.\r\n[0-9] matches any digit.\r\n[A-Z] matches any uppercase letter.\r\n[a-z,A-Z] matches any uppercase or lowercase letter.\r\n\r\nWithin the square brackets, *, ?, and \\ match themselves.\r\nAll other characters match themselves.\r\nTo match *, ?, or the other special characters, you can escape them by using the backslash character, \\. For example: \\\\ matches a single backslash, and \\? matches the question mark.\r\n\r\nHere are some examples of glob syntax:\r\n\r\n*.html â\u20ac\u201c Matches all strings that end in .html\r\n??? â\u20ac\u201c Matches all strings with exactly three letters or digits\r\n*[0-9]* â\u20ac\u201c Matches all strings containing a numeric value\r\n*.{htm,html,pdf} â\u20ac\u201c Matches any string ending with .htm, .html or .pdf\r\na?*.java â\u20ac\u201c Matches any string beginning with a, followed by at least one letter or digit, and ending with .java\r\n{foo*,*[0-9]*} â\u20ac\u201c Matches any string beginning with foo or any string containing a numeric value\r\n\r\nNote:Â If you are typing the glob pattern at the keyboard and it contains one of the special characters, you must put the pattern in quotes (\"*\"), use the backslash (\\*), or use whatever escape mechanism is supported at the command line.\r\n\r\nThe glob syntax is powerful and easy to use. However, if it is not sufficient for your needs, you can also use a regular expression. For more information, see the \r\nRegular Expressions lesson.\r\nFor more information about the glob sytnax, see the API specification for the \r\ngetPathMatcher method in the FileSystem class.\r\nLink Awareness\r\nThe Files class is \"link aware.\" Every Files method either detects what to do when a symbolic link is encountered, or it provides an option enabling you to configure the behavior when a symbolic link is encountered.\r\n",
        "title": "Oracle_File Operations.txt",
        "type": "Oracle_"
    }, {
        "rank": 4,
        "text": "\r\n\r\nQuantifiers allow you to specify the number of occurrences to match against. For convenience, the three sections of the Pattern API specification describing greedy, reluctant, and possessive quantifiers are presented below. At first glance it may appear that the quantifiers X?, X?? and X?+ do exactly the same thing, since they all promise to match \"X, once or not at all\". There are subtle implementation differences which will be explained near the end of this section.\r\n\r\n\r\nGreedy\r\nReluctant\r\nPossessive\r\nMeaning\r\n\r\n\r\nX?\r\nX??\r\nX?+\r\nX, once or not at all\r\n\r\n\r\nX*\r\nX*?\r\nX*+\r\nX, zero or more times\r\n\r\n\r\nX+\r\nX+?\r\nX++\r\nX, one or more times\r\n\r\n\r\nX{n}\r\nX{n}?\r\nX{n}+\r\nX, exactly n times\r\n\r\n\r\nX{n,}\r\nX{n,}?\r\nX{n,}+\r\nX, at least n times\r\n\r\n\r\nX{n,m}\r\nX{n,m}?\r\nX{n,m}+\r\nX, at least n but not more than m times\r\n\r\n\r\nLet's start our look at greedy quantifiers by creating three different regular expressions: the letter \"a\" followed by either ?, *, or +. Let's see what happens when these expressions are tested against an empty input string \"\":\r\n \r\nEnter your regex: a?\r\nEnter input string to search: \r\nI found the text \"\" starting at index 0 and ending at index 0.\r\n\r\nEnter your regex: a*\r\nEnter input string to search: \r\nI found the text \"\" starting at index 0 and ending at index 0.\r\n\r\nEnter your regex: a+\r\nEnter input string to search: \r\nNo match found.\r\n\r\nZero-Length Matches\r\nIn the above example, the match is successful in the first two cases because the expressions a? and a* both allow for zero occurrences of the letter a. You'll also notice that the start and end indices are both zero, which is unlike any of the examples we've seen so far. The empty input string \"\" has no length, so the test simply matches nothing at index 0. Matches of this sort are known as a zero-length matches. A zero-length match can occur in several cases: in an empty input string, at the beginning of an input string, after the last character of an input string, or in between any two characters of an input string. Zero-length matches are easily identifiable because they always start and end at the same index position.\r\nLet's explore zero-length matches with a few more examples. Change the input string to a single letter \"a\" and you'll notice something interesting:\r\n \r\nEnter your regex: a?\r\nEnter input string to search: a\r\nI found the text \"a\" starting at index 0 and ending at index 1.\r\nI found the text \"\" starting at index 1 and ending at index 1.\r\n\r\nEnter your regex: a*\r\nEnter input string to search: a\r\nI found the text \"a\" starting at index 0 and ending at index 1.\r\nI found the text \"\" starting at index 1 and ending at index 1.\r\n\r\nEnter your regex: a+\r\nEnter input string to search: a\r\nI found the text \"a\" starting at index 0 and ending at index 1.\r\n\r\nAll three quantifiers found the letter \"a\", but the first two also found a zero-length match at index 1; that is, after the last character of the input string. Remember, the matcher sees the character \"a\" as sitting in the cell between index 0 and index 1, and our test harness loops until it can no longer find a match. Depending on the quantifier used, the presence of \"nothing\" at the index after the last character may or may not trigger a match.\r\nNow change the input string to the letter \"a\" five times in a row and you'll get the following:\r\n \r\nEnter your regex: a?\r\nEnter input string to search: aaaaa\r\nI found the text \"a\" starting at index 0 and ending at index 1.\r\nI found the text \"a\" starting at index 1 and ending at index 2.\r\nI found the text \"a\" starting at index 2 and ending at index 3.\r\nI found the text \"a\" starting at index 3 and ending at index 4.\r\nI found the text \"a\" starting at index 4 and ending at index 5.\r\nI found the text \"\" starting at index 5 and ending at index 5.\r\n\r\nEnter your regex: a*\r\nEnter input string to search: aaaaa\r\nI found the text \"aaaaa\" starting at index 0 and ending at index 5.\r\nI found the text \"\" starting at index 5 and ending at index 5.\r\n\r\nEnter your regex: a+\r\nEnter input string to search: aaaaa\r\nI found the text \"aaaaa\" starting at index 0 and ending at index 5.\r\n\r\nThe expression a? finds an individual match for each character, since it matches when \"a\" appears zero or one times. The expression a* finds two separate matches: all of the letter \"a\"'s in the first match, then the zero-length match after the last character at index 5. And finally, a+ matches all occurrences of the letter \"a\", ignoring the presence of \"nothing\" at the last index.\r\nAt this point, you might be wondering what the results would be if the first two quantifiers encounter a letter other than \"a\". For example, what happens if it encounters the letter \"b\", as in \"ababaaaab\"?\r\nLet's find out:\r\n \r\nEnter your regex: a?\r\nEnter input string to search: ababaaaab\r\nI found the text \"a\" starting at index 0 and ending at index 1.\r\nI found the text \"\" starting at index 1 and ending at index 1.\r\nI found the text \"a\" starting at index 2 and ending at index 3.\r\nI found the text \"\" starting at index 3 and ending at index 3.\r\nI found the text \"a\" starting at index 4 and ending at index 5.\r\nI found the text \"a\" starting at index 5 and ending at index 6.\r\nI found the text \"a\" starting at index 6 and ending at index 7.\r\nI found the text \"a\" starting at index 7 and ending at index 8.\r\nI found the text \"\" starting at index 8 and ending at index 8.\r\nI found the text \"\" starting at index 9 and ending at index 9.\r\n\r\nEnter your regex: a*\r\nEnter input string to search: ababaaaab\r\nI found the text \"a\" starting at index 0 and ending at index 1.\r\nI found the text \"\" starting at index 1 and ending at index 1.\r\nI found the text \"a\" starting at index 2 and ending at index 3.\r\nI found the text \"\" starting at index 3 and ending at index 3.\r\nI found the text \"aaaa\" starting at index 4 and ending at index 8.\r\nI found the text \"\" starting at index 8 and ending at index 8.\r\nI found the text \"\" starting at index 9 and ending at index 9.\r\n\r\nEnter your regex: a+\r\nEnter input string to search: ababaaaab\r\nI found the text \"a\" starting at index 0 and ending at index 1.\r\nI found the text \"a\" starting at index 2 and ending at index 3.\r\nI found the text \"aaaa\" starting at index 4 and ending at index 8.\r\n\r\nEven though the letter \"b\" appears in cells 1, 3, and 8, the output reports a zero-length match at those locations. The regular expression a? is not specifically looking for the letter \"b\"; it's merely looking for the presence (or lack thereof) of the letter \"a\". If the quantifier allows for a match of \"a\" zero times, anything in the input string that's not an \"a\" will show up as a zero-length match. The remaining a's are matched according to the rules discussed in the previous examples.\r\nTo match a pattern exactly n number of times, simply specify the number inside a set of braces:\r\n \r\nEnter your regex: a{3}\r\nEnter input string to search: aa\r\nNo match found.\r\n\r\nEnter your regex: a{3}\r\nEnter input string to search: aaa\r\nI found the text \"aaa\" starting at index 0 and ending at index 3.\r\n\r\nEnter your regex: a{3}\r\nEnter input string to search: aaaa\r\nI found the text \"aaa\" starting at index 0 and ending at index 3.\r\n\r\nHere, the regular expression a{3} is searching for three occurrences of the letter \"a\" in a row. The first test fails because the input string does not have enough a's to match against. The second test contains exactly 3 a's in the input string, which triggers a match. The third test also triggers a match because there are exactly 3 a's at the beginning of the input string. Anything following that is irrelevant to the first match. If the pattern should appear again after that point, it would trigger subsequent matches:\r\n \r\nEnter your regex: a{3}\r\nEnter input string to search: aaaaaaaaa\r\nI found the text \"aaa\" starting at index 0 and ending at index 3.\r\nI found the text \"aaa\" starting at index 3 and ending at index 6.\r\nI found the text \"aaa\" starting at index 6 and ending at index 9.\r\n\r\nTo require a pattern to appear at least n times, add a comma after the number:\r\n \r\nEnter your regex: a{3,}\r\nEnter input string to search: aaaaaaaaa\r\nI found the text \"aaaaaaaaa\" starting at index 0 and ending at index 9.\r\n\r\nWith the same input string, this test finds only one match, because the 9 a's in a row satisfy the need for \"at least\" 3 a's.\r\nFinally, to specify an upper limit on the number of occurances, add a second number inside the braces:\r\n \r\nEnter your regex: a{3,6} // find at least 3 (but no more than 6) a's in a row\r\nEnter input string to search: aaaaaaaaa\r\nI found the text \"aaaaaa\" starting at index 0 and ending at index 6.\r\nI found the text \"aaa\" starting at index 6 and ending at index 9.\r\n\r\nHere the first match is forced to stop at the upper limit of 6 characters. The second match includes whatever is left over, which happens to be three a's â\u20ac\u201d the mimimum number of characters allowed for this match. If the input string were one character shorter, there would not be a second match since only two a's would remain.\r\nCapturing Groups and Character Classes with Quantifiers\r\nUntil now, we've only tested quantifiers on input strings containing one character. In fact, quantifiers can only attach to one character at a time, so the regular expression \"abc+\" would mean \"a, followed by b, followed by c one or more times\". It would not mean \"abc\" one or more times. However, quantifiers can also attach to \r\nCharacter Classes and \r\nCapturing Groups, such as [abc]+ (a or b or c, one or more times) or (abc)+ (the group \"abc\", one or more times).\r\nLet's illustrate by specifying the group (dog), three times in a row.\r\n \r\nEnter your regex: (dog){3}\r\nEnter input string to search: dogdogdogdogdogdog\r\nI found the text \"dogdogdog\" starting at index 0 and ending at index 9.\r\nI found the text \"dogdogdog\" starting at index 9 and ending at index 18.\r\n\r\nEnter your regex: dog{3}\r\nEnter input string to search: dogdogdogdogdogdog\r\nNo match found.\r\n\r\nHere the first example finds three matches, since the quantifier applies to the entire capturing group. Remove the parentheses, however, and the match fails because the quantifier {3} now applies only to the letter \"g\".\r\nSimilarly, we can apply a quantifier to an entire character class:\r\n\r\nEnter your regex: [abc]{3}\r\nEnter input string to search: abccabaaaccbbbc\r\nI found the text \"abc\" starting at index 0 and ending at index 3.\r\nI found the text \"cab\" starting at index 3 and ending at index 6.\r\nI found the text \"aaa\" starting at index 6 and ending at index 9.\r\nI found the text \"ccb\" starting at index 9 and ending at index 12.\r\nI found the text \"bbc\" starting at index 12 and ending at index 15.\r\n\r\nEnter your regex: abc{3}\r\nEnter input string to search: abccabaaaccbbbc\r\nNo match found.\r\n\r\nHere the quantifier {3} applies to the entire character class in the first example, but only to the letter \"c\" in the second. \r\nDifferences Among Greedy, Reluctant, and Possessive Quantifiers\r\nThere are subtle differences among greedy, reluctant, and possessive quantifiers.\r\nGreedy quantifiers are considered \"greedy\" because they force the matcher to read in, or eat, the entire input string prior to attempting the first match. If the first match attempt (the entire input string) fails, the matcher backs off the input string by one character and tries again, repeating the process until a match is found or there are no more characters left to back off from. Depending on the quantifier used in the expression, the last thing it will try matching against is 1 or 0 characters.\r\nThe reluctant quantifiers, however, take the opposite approach: They start at the beginning of the input string, then reluctantly eat one character at a time looking for a match. The last thing they try is the entire input string.\r\nFinally, the possessive quantifiers always eat the entire input string, trying once (and only once) for a match. Unlike the greedy quantifiers, possessive quantifiers never back off, even if doing so would allow the overall match to succeed.\r\nTo illustrate, consider the input string xfooxxxxxxfoo.\r\n \r\nEnter your regex: .*foo  // greedy quantifier\r\nEnter input string to search: xfooxxxxxxfoo\r\nI found the text \"xfooxxxxxxfoo\" starting at index 0 and ending at index 13.\r\n\r\nEnter your regex: .*?foo  // reluctant quantifier\r\nEnter input string to search: xfooxxxxxxfoo\r\nI found the text \"xfoo\" starting at index 0 and ending at index 4.\r\nI found the text \"xxxxxxfoo\" starting at index 4 and ending at index 13.\r\n\r\nEnter your regex: .*+foo // possessive quantifier\r\nEnter input string to search: xfooxxxxxxfoo\r\nNo match found.\r\n\r\nThe first example uses the greedy quantifier .* to find \"anything\", zero or more times, followed by the letters \"f\" \"o\" \"o\". Because the quantifier is greedy, the .* portion of the expression first eats the entire input string. At this point, the overall expression cannot succeed, because the last three letters (\"f\" \"o\" \"o\") have already been consumed. So the matcher slowly backs off one letter at a time until the rightmost occurrence of \"foo\" has been regurgitated, at which point the match succeeds and the search ends.\r\nThe second example, however, is reluctant, so it starts by first consuming \"nothing\". Because \"foo\" doesn't appear at the beginning of the string, it's forced to swallow the first letter (an \"x\"), which triggers the first match at 0 and 4. Our test harness continues the process until the input string is exhausted. It finds another match at 4 and 13.\r\nThe third example fails to find a match because the quantifier is possessive. In this case, the entire input string is consumed by .*+, leaving nothing left over to satisfy the \"foo\" at the end of the expression. Use a possessive quantifier for situations where you want to seize all of something without ever backing off; it will outperform the equivalent greedy quantifier in cases where the match is not immediately found.\r\n",
        "title": "Oracle_Quantifiers.txt",
        "type": "Oracle_"
    }, {
        "rank": 5,
        "text": "\r\nThis lesson answers the frequently asked questions users often have when using the JNDI to access LDAP services. Some of the common problems are answered in the \r\nTrouble Shooting Tips of the Naming and Directory Operations lesson.\r\n\r\n\r\n\r\nContexts:\r\n\r\nIs the context safe for multithreaded access?\r\nWhy does the LDAP provider ignore my security environment properties?\r\nWhy do I keep getting a CommunicationException?\r\nHow can I get a trace of LDAP messages?\r\nHow do I use a different authentication mechanism such as Kerberos?\r\nShould I enable ssl when changing the password?\r\nAttributes:\r\n\r\nWhen I ask for one attribute, I get back another. Why?\r\nHow do I know the type of an attribute's value?\r\nHow do I get back an attribute's value in a form other than a String or byte array?\r\nWhy does putting an \"*\" as an attribute value not work as expected in my search?\r\nSearches:\r\n\r\nWhy don't wildcards in search filters always work?\r\nWhy do I get back only n number of entries when I know there are more in the directory?\r\nHow do I pass controls with my search?\r\nHow do I find out how many search results I got back?\r\nNames:\r\n\r\nWhy do I get an empty string as a name in my SearchResult?\r\nWhy do I get a URL string as a name in my SearchResult?\r\nWhat type is the Name argument passed to the context methods?\r\nCan I pass the name I got back from NameParser to the Context methods?\r\nWhat's the relationship between the name I use for the Context.SECURITY_PRINCIPAL property and the directory?\r\nWhy are there strange quotation marks and escapes in the names that I read from the directory?\r\nHow do I get an LDAP entry's full DN?\r\n\r\n\r\n\r\n1. Is the context safe for multithreaded access, or do I need to lock/synchronize access to a context?\r\nThe answer depends on the implementation. This is because the \r\nContext and \r\nDirContext interfaces do not specify synchronization requirements. The LDAP implementation in the JDK is optimized for single-threaded access. If you have multiple threads accessing the same Context instance, then each thread needs to lock the Context instance when using it. This also applies to any NamingEnumeration that is derived from the same Context instance. However, multiple threads can access different Context instances (even those derived from the same initial context) concurrently without locks.\r\n2. Why does the LDAP provider ignore my security environment properties if I do not set the \r\nContext.SECURITY_CREDENTIALS (\"java.naming.security.credentials\") property or set it to the empty string?\r\nIf you supply an empty string, an empty byte/char array, or null to the Context.SECURITY_CREDENTIALS environment property, then an anonymous bind will occur even if the Context.SECURITY_AUTHENTICATION property was set to \"simple\". This is because for simple authentication, the LDAP requires the password to be nonempty. If a password is not supplied, then the protocol automatically converts the authentication to \"none\".\r\n3. Why do I keep getting a \r\nCommunicationException when I try to create an initial context?\r\nYou might be talking to a server that supports only the LDAP v2. See the Miscellaneous lesson of the \r\nJNDI Tutorial for an example of how to set the version number.\r\n4. How can I trace the LDAP message?\r\nTry using the \"com.sun.jndi.ldap.trace.ber\" environment property. If the value of this property is an instance of java.io.OutputStream, then trace information about BER buffers sent and received by the LDAP provider is written to that stream. If the property's value is null, then no trace output is written.\r\nFor example, the following code will send the trace output to System.err.\r\n\r\nenv.put(\"com.sun.jndi.ldap.trace.ber\", System.err);\r\n\r\n5. How do I use a different authentication mechanism such as Kerberos?\r\nFollow the instructions in the GSS-API/Kerberos v5 Authentication of the \r\nJNDI Tutorial for information on how to use Kerberos authentication. To use other authentication mechanisms, see the Using Arbitrary SASL Mechanisms section of the \r\nJNDI tutorial.\r\n6. Should I enable SSL when changing the password? /\r\nIt really depends on the directory server you are using. Some directory servers won't allow you to change the password if SSL is not enabled but some do allow it. It's good to have SSL enabled to have your password secured in the communication channel.\r\n7. When I ask for one attribute, I get back another. Why?\r\nThe attribute name that you are using might be a synonym for another attribute. In this case, the LDAP server might return the canonical attribute name instead of the one that you supplied. When you look in the Attributes returned by the server, you need to use the canonical name instead of the synonym.\r\nFor example, \"fax\" might be a synonym for the canonical attribute name \"facsimiletelephonenumber\". If you ask for \"fax\", the server will return the attribute named \"facsimiletelephonenumber\". See the \r\nNaming and Directory Operations lesson for details on synonyms and other issues regarding attribute names.\r\n8. How do I know the type of an attribute's value?\r\nAn attribute's value can be either java.lang.String or byte[]. See the Miscellaneous section of the \r\nJNDI Tutorial for information on which attributes' values are returned as byte[]. To do this programmatically, you can use the instanceof operator to examine the attribute value that you get back from the LDAP provider.\r\n9. How do I get back an attribute's value in a form other than a String or byte array?\r\nCurrently you can't. The LDAP provider returns only attribute values that are either java.lang.String or byte[]. See the Miscellaneous section of the \r\nJNDI Tutorial.\r\n10. Why does putting an \"*\" as an attribute value not work as expected in my search?\r\nWhen you use the following form of search(), the attribute values are treated as literals; that is, the attribute in the directory entry is expected to contain exactly that value: \r\nsearch(Name name, Attributes matchingAttrs) To use wildcards, you should use the string filter forms of search(), as follows. \r\nsearch(Name name, String filter, SearchControls ctls)\r\nsearch(Name name, String filterExpr, Object[]filterArgs, SearchControls ctls)\r\nFor the last form, the wildcard characters must appear in the filterExpr argument, and not in filterArgs. The values in filterArgs are also treated as literals.\r\n11. Why don't wildcards in search filters always work?\r\nA wildcard that appears before or after the attribute value (such as in \"attr=*I*\") indicates that the server is to search for matching attribute values by using the attribute's substring matching rule. If the attribute's definition does not have a substring matching rule, then the server cannot find the attribute. You'll have to search by using an equality or \"present\" filter instead.\r\n12. Why do I get back only n number of entries when I know there are more in the directory? Some servers are configured to limit the number of entries that can be returned. Others also limit the number of entries that can be examined during a search. Check your server configuration.\r\n13. How do I pass controls with my search?\r\nControls are not explained in this tutorial. Check out the \r\nJNDI Tutorial.\r\n14. How do I find out how many search results I got back?\r\nYou must keep count as you enumerate through the results. The LDAP does not provide this information.\r\n15. Why do I get an empty string as a name in my \r\nSearchResult?\r\n\r\ngetName() always returns a name relative to the target context of the search. So, if the target context satisfies the search filter, then the name returned will be \"\" (the empty name) because that is the name relative to the target context. See the \r\nSearch Results section for details.\r\n16. Why do I get a URL string as a name in my \r\nSearchResult?\r\nThe LDAP entry was retrieved by following either an alias or a referral, so its name is a URL. See the \r\nSearch Results lesson for details.\r\n17. What type is the \r\nName argument passed to the \r\nContext and \r\nDirContext methods? - a \r\nCompoundName or a \r\nCompositeName?\r\nThe string forms accept the string representation of a composite name. That is, using a string name is equivalent to calling new CompositeName(stringName) and passing the results to the Context/DirContext method. The Name argument can be any object that implements the Name interface. If it is an instance of CompositeName, then the name is treated as a composite name; otherwise, it is treated as a compound name.\r\n18. Can I pass the name I got back from \r\nNameParser to \r\nContext methods?\r\nThis is related to the previous question. Yes, you can. \r\nNameParser.parse() returns a compound name that implements the Name interface. This name can be passed to the Context methods, which will interpret it as a compound name.\r\n19. What's the relationship between the name I use for the \r\nContext.SECURITY_PRINCIPAL property and the directory?\r\nYou can think of the principal name as coming from a different namespace than the directory. See \r\nRFC 2829 and the \r\nSecurity section for details on LDAP authentication mechanisms. The LDAP service provider in the JDK accepts a string principal name, which it passes directly to the LDAP server. Some LDAP servers accept DNs, whereas others support the schemes proposed by \r\nRFC 2829.\r\n20. Why are there strange quotation marks and escapes in the names that I read from the directory?\r\nThe LDAP name parser in the JDK is conservative with respect to quoting rules, but it nevertheless produces \"correct\" names. Also, remember that the names of entries returned by \r\nNamingEnumerations are composite names that can be passed back to the Context and DirContext methods. So, if the name contains a character that conflicts with the composite name syntax (such as the forward slash character \"/\"), then the LDAP provider will provide an encoding to ensure that the slash character will be treated as part of the LDAP name rather than as a composite name separator.\r\nStart using the \r\nLdapName and \r\nRdn classes that enable easy name manipulation.\r\n21. How do I get an LDAP entry's full DN?\r\nYou can use \r\nNameClassPair.getNameInNamespace().\r\n\r\n",
        "title": "Oracle_Frequently Asked Questions.txt",
        "type": "Oracle_"
    }, {
        "rank": 6,
        "text": "\r\n\r\nRandom access files permit nonsequential, or random, access to a file's contents. To access a file randomly, you open the file, seek a particular location, and read from or write to that file.\r\nThis functionality is possible with the \r\nSeekableByteChannel interface. The SeekableByteChannel interface extends channel I/O with the notion of a current position. Methods enable you to set or query the position, and you can then read the data from, or write the data to, that location. The API consists of a few, easy to use, methods:\r\n\r\n\r\nposition â\u20ac\u201c Returns the channel's current position\r\n\r\nposition(long) â\u20ac\u201c Sets the channel's position\r\n\r\nread(ByteBuffer) â\u20ac\u201c Reads bytes into the buffer from the channel\r\n\r\nwrite(ByteBuffer) â\u20ac\u201c Writes bytes from the buffer to the channel\r\n\r\ntruncate(long) â\u20ac\u201c Truncates the file (or other entity) connected to the channel\r\n\r\n\r\nReading and Writing Files With Channel I/O shows that the Path.newByteChannel methods return an instance of a SeekableByteChannel. On the default file system, you can use that channel as is, or you can cast it to a \r\nFileChannel giving you access to more advanced features, such as mapping a region of the file directly into memory for faster access, locking a region of the file, or reading and writing bytes from an absolute location without affecting the channel's current position.\r\nThe following code snippet opens a file for both reading and writing by using one of the newByteChannel methods. The SeekableByteChannel that is returned is cast to a FileChannel. Then, 12 bytes are read from the beginning of the file, and the string \"I was here!\" is written at that location. The current position in the file is moved to the end, and the 12 bytes from the beginning are appended. Finally, the string, \"I was here!\" is appended, and the channel on the file is closed.\r\n\r\nString s = \"I was here!\\n\";\r\nbyte data[] = s.getBytes();\r\nByteBuffer out = ByteBuffer.wrap(data);\r\n\r\nByteBuffer copy = ByteBuffer.allocate(12);\r\n\r\ntry (FileChannel fc = (FileChannel.open(file, READ, WRITE))) {\r\n    // Read the first 12\r\n    // bytes of the file.\r\n    int nread;\r\n    do {\r\n        nread = fc.read(copy);\r\n    } while (nread != -1 && copy.hasRemaining());\r\n\r\n    // Write \"I was here!\" at the beginning of the file.\r\n    fc.position(0);\r\n    while (out.hasRemaining())\r\n        fc.write(out);\r\n    out.rewind();\r\n\r\n    // Move to the end of the file.  Copy the first 12 bytes to\r\n    // the end of the file.  Then write \"I was here!\" again.\r\n    long length = fc.size();\r\n    fc.position(length-1);\r\n    copy.flip();\r\n    while (copy.hasRemaining())\r\n        fc.write(copy);\r\n    while (out.hasRemaining())\r\n        fc.write(out);\r\n} catch (IOException x) {\r\n    System.out.println(\"I/O Exception: \" + x);\r\n}\r\n\r\n",
        "title": "Oracle_Random Access Files.txt",
        "type": "Oracle_"
    }, {
        "rank": 7,
        "text": "\r\nSometimes people ask, after creating simple programs like the ones above, questions like:\r\n\r\nWhy did I have to tell theGraphicsinstance the color before each drawing routine?Why can't it remember my choice for the outlines and for the fill colors? The answer is simpler than it seems. But, to fully understand it, we need to focus on one little thing called theGraphics Context. The graphics context is the information that adheres to a single instance of theGraphicsclass. Such an instance remembers only one color at a time and that is why we need to make sure the context knows of the color we need to use by using thesetColor(Color)method.Can I manipulate the shapes, like tilt them and crop them?Hold your horses, cowboy! Everything is possible in Java, even tilting and cropping drawings. We will be focusing on these issues in a later section.Is making shapes like triangles, rhombuses and other complex ones tedious?Well, to be honest here, you need to go back to your dusty book cabinet and take out that High School Geometry book because we would be covering some geometry basics while dealing with such shapes. Why not read awikibook on Geometry?\r\n\r\n\r\nIf you have any questions regarding the content provided here, please feel free to comment in this page'sdiscussion.\r\n\r\n",
        "title": "Drawing shapes_Hmm everythings perfect but..._text.txt",
        "type": "text"
    }, {
        "rank": 8,
        "text": "\r\nOne of the main concerns of a developer writing hot re-deployable applications is to understand how class loading works. Within the internals of the class loading mechanism lies the answer to questions like:\r\n\r\nWhat happens if I pack a newer version of an utility library with my application, while an older version of the same library lingers somewhere in the server's lib directory?How can I use two different versions of the same utility library, simultaneously, within the same instance of the application server?What version of an utility class I am currently using?Why do I need to mess with all this class loading stuff anyway?\r\n\r\n\r\n\r\n\r\n\r\nTo do:Add some exercises like the ones inVariables\r\n\r\n\r\n\r\nOverloading Methods and ConstructorsJava ProgrammingObject LifecycleScope\r\n\r\n\r\n\r\n\r\n",
        "title": "Object Lifecycle_Class loading_text.txt",
        "type": "text"
    }, {
        "rank": 9,
        "text": "\r\nThe break Statement\r\nThe break statement has two forms: labeled and unlabeled. You saw the unlabeled form in the previous discussion of the switch statement. You can also use an unlabeled break to terminate a for, while, or do-while loop, as shown in the following \r\nBreakDemo program:\r\n\r\nclass BreakDemo {\r\n    public static void main(String[] args) {\r\n\r\n        int[] arrayOfInts = \r\n            { 32, 87, 3, 589,\r\n              12, 1076, 2000,\r\n              8, 622, 127 };\r\n        int searchfor = 12;\r\n\r\n        int i;\r\n        boolean foundIt = false;\r\n\r\n        for (i = 0; i < arrayOfInts.length; i++) {\r\n            if (arrayOfInts[i] == searchfor) {\r\n                foundIt = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (foundIt) {\r\n            System.out.println(\"Found \" + searchfor + \" at index \" + i);\r\n        } else {\r\n            System.out.println(searchfor + \" not in the array\");\r\n        }\r\n    }\r\n}\r\n\r\nThis program searches for the number 12 in an array. The break statement, shown in boldface, terminates the for loop when that value is found. Control flow then transfers to the statement after the for loop. This program's output is:\r\n\r\nFound 12 at index 4\r\n\r\nAn unlabeled break statement terminates the innermost switch, for, while, or do-while statement, but a labeled break terminates an outer statement. The following program, \r\nBreakWithLabelDemo, is similar to the previous program, but uses nested for loops to search for a value in a two-dimensional array. When the value is found, a labeled break terminates the outer for loop (labeled \"search\"):\r\n\r\n\r\nclass BreakWithLabelDemo {\r\n    public static void main(String[] args) {\r\n\r\n        int[][] arrayOfInts = { \r\n            { 32, 87, 3, 589 },\r\n            { 12, 1076, 2000, 8 },\r\n            { 622, 127, 77, 955 }\r\n        };\r\n        int searchfor = 12;\r\n\r\n        int i;\r\n        int j = 0;\r\n        boolean foundIt = false;\r\n\r\n    search:\r\n        for (i = 0; i < arrayOfInts.length; i++) {\r\n            for (j = 0; j < arrayOfInts[i].length;\r\n                 j++) {\r\n                if (arrayOfInts[i][j] == searchfor) {\r\n                    foundIt = true;\r\n                    break search;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (foundIt) {\r\n            System.out.println(\"Found \" + searchfor + \" at \" + i + \", \" + j);\r\n        } else {\r\n            System.out.println(searchfor + \" not in the array\");\r\n        }\r\n    }\r\n}\r\n\r\nThis is the output of the program.\r\n\r\nFound 12 at 1, 0\r\n\r\nThe break statement terminates the labeled statement; it does not transfer the flow of control to the label. Control flow is transferred to the statement immediately following the labeled (terminated) statement.\r\nThe continue Statement\r\nThe continue statement skips the current iteration of a for, while , or do-while loop. The unlabeled form skips to the end of the innermost loop's body and evaluates the boolean expression that controls the loop. The following program, \r\nContinueDemo , steps through a String, counting the occurences of the letter \"p\". If the current character is not a p, the continue statement skips the rest of the loop and proceeds to the next character. If it is a \"p\", the program increments the letter count.\r\n\r\n\r\nclass ContinueDemo {\r\n    public static void main(String[] args) {\r\n\r\n        String searchMe = \"peter piper picked a \" + \"peck of pickled peppers\";\r\n        int max = searchMe.length();\r\n        int numPs = 0;\r\n\r\n        for (int i = 0; i < max; i++) {\r\n            // interested only in p's\r\n            if (searchMe.charAt(i) != 'p')\r\n                continue;\r\n\r\n            // process p's\r\n            numPs++;\r\n        }\r\n        System.out.println(\"Found \" + numPs + \" p's in the string.\");\r\n    }\r\n}\r\n\r\nHere is the output of this program:\r\n\r\nFound 9 p's in the string.\r\n\r\nTo see this effect more clearly, try removing the continue statement and recompiling. When you run the program again, the count will be wrong, saying that it found 35 p's instead of 9.\r\nA labeled continue statement skips the current iteration of an outer loop marked with the given label. The following example program, ContinueWithLabelDemo, uses nested loops to search for a substring within another string. Two nested loops are required: one to iterate over the substring and one to iterate over the string being searched. The following program, \r\nContinueWithLabelDemo, uses the labeled form of continue to skip an iteration in the outer loop.\r\n\r\n\r\nclass ContinueWithLabelDemo {\r\n    public static void main(String[] args) {\r\n\r\n        String searchMe = \"Look for a substring in me\";\r\n        String substring = \"sub\";\r\n        boolean foundIt = false;\r\n\r\n        int max = searchMe.length() - \r\n                  substring.length();\r\n\r\n    test:\r\n        for (int i = 0; i <= max; i++) {\r\n            int n = substring.length();\r\n            int j = i;\r\n            int k = 0;\r\n            while (n-- != 0) {\r\n                if (searchMe.charAt(j++) != substring.charAt(k++)) {\r\n                    continue test;\r\n                }\r\n            }\r\n            foundIt = true;\r\n                break test;\r\n        }\r\n        System.out.println(foundIt ? \"Found it\" : \"Didn't find it\");\r\n    }\r\n}\r\n\r\nHere is the output from this program.\r\n\r\nFound it\r\n\r\nThe return Statement\r\nThe last of the branching statements is the return statement. The return statement exits from the current method, and control flow returns to where the method was invoked. The return statement has two forms: one that returns a value, and one that doesn't. To return a value, simply put the value (or an expression that calculates the value) after the return keyword.\r\n\r\nreturn ++count;\r\n\r\nThe data type of the returned value must match the type of the method's declared return value. When a method is declared void, use the form of return that doesn't return a value.\r\n\r\nreturn;\r\n\r\nThe \r\nClasses and Objects lesson will cover everything you need to know about writing methods.\r\n",
        "title": "Oracle_Branching Statements.txt",
        "type": "Oracle_"
    }, {
        "rank": 10,
        "text": "\r\n\r\nStrings, which are widely used in Java programming, are a sequence of characters. In the Java programming language, strings are objects.\r\nThe Java platform provides the \r\nString  class to create and manipulate strings.\r\nCreating Strings\r\nThe most direct way to create a string is to write:\r\n\r\nString greeting = \"Hello world!\";\r\n\r\nIn this case, \"Hello world!\" is a string literalâ\u20ac\u201da series of characters in your code that is enclosed in double quotes. Whenever it encounters a string literal in your code, the compiler creates a String object with its valueâ\u20ac\u201din this case, Hello world!.\r\nAs with any other object, you can create String objects by using the new keyword and a constructor. The String class has thirteen constructors that allow you to provide the initial value of the string using different sources, such as an array of characters:\r\n\r\nchar[] helloArray = { 'h', 'e', 'l', 'l', 'o', '.' };\r\nString helloString = new String(helloArray);\r\nSystem.out.println(helloString);\r\n\r\nThe last line of this code snippet displays hello.\r\nNote:Â The String class is immutable, so that once it is created a String object cannot be changed. The String class has a number of methods, some of which will be discussed below, that appear to modify strings. Since strings are immutable, what these methods really do is create and return a new string that contains the result of the operation.\r\n\r\nString Length\r\nMethods used to obtain information about an object are known as accessor methods. One accessor method that you can use with strings is the length() method, which returns the number of characters contained in the string object. After the following two lines of code have been executed, len equals 17:\r\n\r\nString palindrome = \"Dot saw I was Tod\";\r\nint len = palindrome.length();\r\n\r\nA palindrome is a word or sentence that is symmetricâ\u20ac\u201dit is spelled the same forward and backward, ignoring case and punctuation. Here is a short and inefficient program to reverse a palindrome string. It invokes the String method charAt(i), which returns the ith character in the string, counting from 0.\r\n\r\n\r\npublic class StringDemo {\r\n    public static void main(String[] args) {\r\n        String palindrome = \"Dot saw I was Tod\";\r\n        int len = palindrome.length();\r\n        char[] tempCharArray = new char[len];\r\n        char[] charArray = new char[len];\r\n        \r\n        // put original string in an \r\n        // array of chars\r\n        for (int i = 0; i < len; i++) {\r\n            tempCharArray[i] = \r\n                palindrome.charAt(i);\r\n        } \r\n        \r\n        // reverse array of chars\r\n        for (int j = 0; j < len; j++) {\r\n            charArray[j] =\r\n                tempCharArray[len - 1 - j];\r\n        }\r\n        \r\n        String reversePalindrome =\r\n            new String(charArray);\r\n        System.out.println(reversePalindrome);\r\n    }\r\n}\r\n\r\nRunning the program produces this output:\r\n\r\ndoT saw I was toD\r\n\r\nTo accomplish the string reversal, the program had to convert the string to an array of characters (first for loop), reverse the array into a second array (second for loop), and then convert back to a string. The \r\nString  class includes a method, getChars(), to convert a string, or a portion of a string, into an array of characters so we could replace the first for loop in the program above with\r\n\r\npalindrome.getChars(0, len, tempCharArray, 0);\r\n\r\nConcatenating Strings\r\nThe String class includes a method for concatenating two strings:\r\n\r\nstring1.concat(string2); \r\n\r\nThis returns a new string that is string1 with string2 added to it at the end.\r\nYou can also use the concat() method with string literals, as in:\r\n\r\n\"My name is \".concat(\"Rumplestiltskin\");\r\n\r\nStrings are more commonly concatenated with the + operator, as in\r\n\r\n\"Hello,\" + \" world\" + \"!\"\r\n\r\nwhich results in\r\n\r\n\"Hello, world!\"\r\n\r\nThe + operator is widely used in print statements. For example:\r\n\r\nString string1 = \"saw I was \";\r\nSystem.out.println(\"Dot \" + string1 + \"Tod\");\r\n\r\nwhich prints\r\n\r\nDot saw I was Tod\r\n\r\nSuch a concatenation can be a mixture of any objects. For each object that is not a String, its toString() method is called to convert it to a String.\r\nNote:Â The Java programming language does not permit literal strings to span lines in source files, so you must use the + concatenation operator at the end of each line in a multi-line string. For example:\r\n\r\nString quote = \r\n    \"Now is the time for all good \" +\r\n    \"men to come to the aid of their country.\";\r\n\r\nBreaking strings between lines using the + concatenation operator is, once again, very common in print statements.\r\n\r\nCreating Format Strings\r\nYou have seen the use of the printf() and format() methods to print output with formatted numbers. The String class has an equivalent class method, format(), that returns a String object rather than a PrintStream object.\r\nUsing String's static format() method allows you to create a formatted string that you can reuse, as opposed to a one-time print statement. For example, instead of\r\n\r\nSystem.out.printf(\"The value of the float \" +\r\n                  \"variable is %f, while \" +\r\n                  \"the value of the \" + \r\n                  \"integer variable is %d, \" +\r\n                  \"and the string is %s\", \r\n                  floatVar, intVar, stringVar); \r\n\r\nyou can write\r\n\r\nString fs;\r\nfs = String.format(\"The value of the float \" +\r\n                   \"variable is %f, while \" +\r\n                   \"the value of the \" + \r\n                   \"integer variable is %d, \" +\r\n                   \" and the string is %s\",\r\n                   floatVar, intVar, stringVar);\r\nSystem.out.println(fs);\r\n\r\n",
        "title": "Oracle_Strings.txt",
        "type": "Oracle_"
    }]
}

post3_rec = {
    "response": [{
        "rank": 1,
        "text": "\r\nOne issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an interface that contains only one method, then the syntax of anonymous classes may seem unwieldy and unclear. In these cases, you're usually trying to pass functionality as an argument to another method, such as what action should be taken when someone clicks a button. Lambda expressions enable you to do this, to treat functionality as method argument, or code as data.\r\nThe previous section,\r\nAnonymous Classes, shows you how to implement a base class without giving it a name.\r\nAlthough this is often more concise than a named class, for classes\r\nwith only one method, even an anonymous class seems a bit\r\nexcessive and cumbersome. Lambda expressions let you express instances of\r\nsingle-method classes more compactly.\r\nThis section covers the following topics:\r\n\r\nIdeal Use Case for Lambda Expressions\r\n\r\nApproach 1: Create Methods That Search for Members That Match One Characteristic\r\nApproach 2: Create More Generalized Search Methods\r\nApproach 3: Specify Search Criteria Code in a Local Class\r\nApproach 4: Specify Search Criteria Code in an Anonymous Class\r\nApproach 5: Specify Search Criteria Code with a Lambda Expression\r\nApproach 6: Use Standard Functional Interfaces with Lambda Expressions\r\nApproach 7: Use Lambda Expressions Throughout Your Application\r\nApproach 8: Use Generics More Extensively\r\nApproach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters\r\n\r\n\r\nLambda Expressions in GUI Applications\r\nSyntax of Lambda Expressions\r\nAccessing Local Variables of the Enclosing Scope\r\nTarget Typing\r\n\r\nTarget Types and Method Arguments\r\n\r\n\r\nSerialization\r\n\r\nIdeal Use Case for Lambda Expressions\r\nSuppose that you are creating a social networking application. You\r\nwant to create a feature that enables an administrator to perform\r\nany kind of action, such as sending a message, on members of the\r\nsocial networking application that satisfy certain criteria. The following table describes this use case in detail:\r\n\r\n\r\nField\r\nDescription\r\n\r\n\r\nName\r\nPerform action on selected members\r\n\r\n\r\nPrimary Actor\r\nAdministrator\r\n\r\n\r\nPreconditions\r\nAdministrator is logged in to the system.\r\n\r\n\r\nPostconditions\r\nAction is performed only on members that fit the specified criteria.\r\n\r\n\r\nMain Success Scenario\r\n\r\n\r\nAdministrator specifies criteria of members on which to perform a certain action.\r\nAdministrator specifies an action to perform on those selected members.\r\nAdministrator selects the Submit button.\r\nThe system finds all members that match the specified criteria.\r\nThe system performs the specified action on all matching members.\r\n\r\n\r\n\r\n\r\nExtensions\r\n\r\n1a. Administrator has an option to preview those members who match the specified criteria before he or she specifies the action to be performed or before selecting the Submit button.\r\n\r\n\r\n\r\nFrequency of Occurrence\r\nMany times during the day.\r\n\r\n\r\nSuppose that members of this social networking application are\r\nrepresented by the following\r\nPerson class:\r\npublic class Person {\r\n\r\n    public enum Sex {\r\n        MALE, FEMALE\r\n    }\r\n\r\n    String name;\r\n    LocalDate birthday;\r\n    Sex gender;\r\n    String emailAddress;\r\n\r\n    public int getAge() {\r\n        // ...\r\n    }\r\n\r\n    public void printPerson() {\r\n        // ...\r\n    }\r\n}\r\nSuppose that the members of your social networking application\r\nare stored in a List<Person> instance.\r\nThis section begins with a naive approach to this use case. It improves upon this approach with local and anonymous classes, and then finishes with an efficient and concise approach using lambda expressions. Find the code excerpts described in this section in the example\r\nRosterTest.\r\n\r\nApproach 1: Create Methods That Search for Members That Match One Characteristic\r\nOne simplistic approach is to create several methods; each method searches for members that match one characteristic, such as gender or age. The following method prints members that are older than a specified\r\nage:\r\npublic static void printPersonsOlderThan(List<Person> roster, int age) {\r\n    for (Person p : roster) {\r\n        if (p.getAge() >= age) {\r\n            p.printPerson();\r\n        }\r\n    }\r\n}\r\nNote: A\r\nList is an ordered\r\nCollection. A collection is an object\r\nthat groups multiple elements into a single unit. Collections are\r\nused to store, retrieve, manipulate, and communicate aggregate\r\ndata. For more information about collections, see the\r\nCollections trail.\r\nThis approach can potentially make your application brittle, which is the likelihood of an application not working because of the introduction of updates (such as newer data types). Suppose that you upgrade your application and change the structure of the Person class such that it contains different member variables; perhaps the class records and measures ages with a different data type or algorithm. You would have to rewrite a lot of your API to accommodate this change. In addition, this approach is unnecessarily restrictive; what if you\r\nwanted to print members younger than a certain age, for example?\r\n\r\nApproach 2: Create More Generalized Search Methods\r\nThe following method is more generic than printPersonsOlderThan; it prints members within a specified range of ages:\r\npublic static void printPersonsWithinAgeRange(\r\n    List<Person> roster, int low, int high) {\r\n    for (Person p : roster) {\r\n        if (low <= p.getAge() && p.getAge() < high) {\r\n            p.printPerson();\r\n        }\r\n    }\r\n}\r\nWhat if you want to print members of a specified sex, or a combination of a specified gender and age range? What if you decide to change the Person class and add other attributes such as relationship status or geographical location? Although this method is more generic than printPersonsOlderThan, trying to create a separate method for each possible search query can still lead to brittle code. You can instead separate the code that specifies the criteria for which you want to search in a different class.\r\n\r\nApproach 3: Specify Search Criteria Code in a Local Class\r\nThe following method prints members that match search criteria that you specify:\r\npublic static void printPersons(\r\n    List<Person> roster, CheckPerson tester) {\r\n    for (Person p : roster) {\r\n        if (tester.test(p)) {\r\n            p.printPerson();\r\n        }\r\n    }\r\n}\r\nThis method checks each Person instance contained in the List parameter roster whether it satisfies the search criteria specified in the CheckPerson parameter tester by invoking the method tester.test. If the method tester.test returns a true value, then the method printPersons is invoked on the Person instance.\r\nTo specify the search criteria, you implement the\r\nCheckPerson interface:\r\ninterface CheckPerson {\r\n    boolean test(Person p);\r\n}\r\nThe following class implements the CheckPerson interface by specifying an implementation for the method test. This method filters members that are eligible for Selective Service in the United States: it returns a true value if its Person parameter is male and between the ages of 18 and 25:\r\nclass CheckPersonEligibleForSelectiveService implements CheckPerson {\r\n    public boolean test(Person p) {\r\n        return p.gender == Person.Sex.MALE &&\r\n            p.getAge() >= 18 &&\r\n            p.getAge() <= 25;\r\n    }\r\n}\r\nTo use this class, you create a new\r\ninstance of it and invoke the printPersons method:\r\nprintPersons(\r\n    roster, new CheckPersonEligibleForSelectiveService());\r\nAlthough this approach is less brittleâ\u20ac\u201dyou don't have to rewrite methods if you change the structure of the Personâ\u20ac\u201dyou still have additional code: a new interface and a local class for each search you plan to perform in your application. Because CheckPersonEligibleForSelectiveService\r\nimplements an interface, you can use an anonymous class\r\ninstead of a local class and bypass the need to declare a new class for each search.\r\n\r\nApproach 4: Specify Search Criteria Code in an Anonymous Class\r\nOne of the arguments of the following invocation of the method printPersons is an anonymous class that filters members that are eligible for Selective Service in the United States: those who are male and between the ages of 18 and 25:\r\nprintPersons(\r\n    roster,\r\n    new CheckPerson() {\r\n        public boolean test(Person p) {\r\n            return p.getGender() == Person.Sex.MALE\r\n                && p.getAge() >= 18\r\n                && p.getAge() <= 25;\r\n        }\r\n    }\r\n);\r\nThis approach reduces the amount of code required because you don't have to create a new class for each search that you want to perform. However, the syntax of anonymous classes is bulky considering that the CheckPerson interface contains only one method. In this\r\ncase, you can use a lambda expression instead of an anonymous class, as\r\ndescribed in the next section.\r\n\r\nApproach 5: Specify Search Criteria Code with a Lambda Expression\r\nThe CheckPerson\r\ninterface is a functional interface. A functional\r\ninterface is any interface that contains only one\r\nabstract method. (A functional interface may contain one or more \r\ndefault methods or\r\nstatic methods.) Because\r\na functional interface contains only one abstract method, you can\r\nomit the name of that method\r\nwhen you implement it. To do this, instead of using an anonymous\r\nclass expression, you use a lambda\r\nexpression, which is\r\nhighlighted in the following method invocation:\r\nprintPersons(\r\n    roster,\r\n    (Person p) -> p.getGender() == Person.Sex.MALE\r\n        && p.getAge() >= 18\r\n        && p.getAge() <= 25\r\n);\r\nSee Syntax of Lambda Expressions for information about how to define lambda expressions.\r\nYou can use a standard functional interface in place of the interface CheckPerson, which reduces even further the amount of code required.\r\n\r\nApproach 6: Use Standard Functional Interfaces with Lambda Expressions\r\nReconsider the CheckPerson interface:\r\ninterface CheckPerson {\r\n    boolean test(Person p);\r\n}\r\nThis is a very\r\nsimple interface. It's a functional interface because it contains\r\nonly one abstract method. This method takes one parameter and returns a\r\nboolean value. The method is so simple that it might not be worth\r\nit to define one in your application. Consequently, the JDK\r\ndefines several standard functional interfaces, which you can\r\nfind in the package java.util.function.\r\nFor example, you can use the\r\nPredicate<T>\r\n\r\n interface in place of CheckPerson. This\r\ninterface contains the method boolean\r\ntest(T t):\r\ninterface Predicate<T> {\r\n    boolean test(T t);\r\n}\r\nThe interface Predicate<T> is an example of a generic interface. (For more information about generics, see the\r\nGenerics (Updated) lesson.) Generic types (such as generic interfaces) specify one or more type parameters within angle brackets (<>). This interface contains only one type parameter, T. When you declare or instantiate a generic type with actual type arguments, you have a parameterized type. For example, the parameterized type Predicate<Person> is the following:\r\ninterface Predicate<Person> {\r\n    boolean test(Person t);\r\n}\r\nThis parameterized type contains a method that has the same return type and parameters as CheckPerson.boolean test(Person p). Consequently, you can use Predicate<T> in place of CheckPerson as the following method demonstrates:\r\npublic static void printPersonsWithPredicate(\r\n    List<Person> roster, Predicate<Person> tester) {\r\n    for (Person p : roster) {\r\n        if (tester.test(p)) {\r\n            p.printPerson();\r\n        }\r\n    }\r\n}\r\nAs a result,\r\nthe following method invocation is the same as when you invoked\r\nprintPersons in Approach 3: Specify Search Criteria Code in a Local Class to obtain members who are eligible for Selective Service:\r\nprintPersonsWithPredicate(\r\n    roster,\r\n    p -> p.getGender() == Person.Sex.MALE\r\n        && p.getAge() >= 18\r\n        && p.getAge() <= 25\r\n);\r\nThis is not the only possible place in this method to use a lambda expression. The following approach suggests other ways to use lambda expressions.\r\n\r\nApproach 7: Use Lambda Expressions Throughout Your Application\r\nReconsider the method printPersonsWithPredicate\r\nto see where else you could use lambda expressions:\r\npublic static void printPersonsWithPredicate(\r\n    List<Person> roster, Predicate<Person> tester) {\r\n    for (Person p : roster) {\r\n        if (tester.test(p)) {\r\n            p.printPerson();\r\n        }\r\n    }\r\n}\r\nThis method checks each Person instance contained in the List parameter roster whether it satisfies the criteria specified in the Predicate parameter tester. If the Person instance does satisfy the criteria specified by tester, the method printPersron is invoked on the Person instance.\r\nInstead of invoking the method printPerson, you can specify a different action to perform on those Person instances that satisfy the criteria specified by tester. You can specify this action with a lambda expression. Suppose you want a lambda expression similar to printPerson, one that takes one argument (an object of type Person) and returns void. Remember, to use a lambda expression, you need to implement a functional interface. In this case, you need a functional interface that contains an abstract method that can take one argument of type Person and returns void. The\r\nConsumer<T>\r\n interface contains the method\r\nvoid accept(T t), which has these characteristics. The\r\nfollowing method replaces the invocation\r\np.printPerson() with an\r\ninstance of Consumer<Person> that invokes the method accept:\r\npublic static void processPersons(\r\n    List<Person> roster,\r\n    Predicate<Person> tester,\r\n    Consumer<Person> block) {\r\n        for (Person p : roster) {\r\n            if (tester.test(p)) {\r\n                block.accept(p);\r\n            }\r\n        }\r\n}\r\nAs a\r\nresult, the following method invocation is the same as when you invoked printPersons in Approach 3: Specify Search Criteria Code in a Local Class to obtain members who are eligible for Selective Service. The lambda expression used to\r\nprint members is highlighted:\r\nprocessPersons(\r\n     roster,\r\n     p -> p.getGender() == Person.Sex.MALE\r\n         && p.getAge() >= 18\r\n         && p.getAge() <= 25,\r\n     p -> p.printPerson()\r\n);\r\nWhat if you want to do more with your members' profiles than printing them out. Suppose that you want to validate the members' profiles or retrieve\r\ntheir contact information? In this case, you need a functional\r\ninterface that contains an abstract method that returns a value.\r\nThe\r\nFunction<T,R>\r\n interface contains the\r\nmethod R apply(T\r\nt). The following method retrieves the data\r\nspecified by the parameter mapper, and\r\nthen performs an action on it specified by the\r\nparameter block:\r\npublic static void processPersonsWithFunction(\r\n    List<Person> roster,\r\n    Predicate<Person> tester,\r\n    Function<Person, String> mapper,\r\n    Consumer<String> block) {\r\n    for (Person p : roster) {\r\n        if (tester.test(p)) {\r\n            String data = mapper.apply(p);\r\n            block.accept(data);\r\n        }\r\n    }\r\n}\r\nThe following method retrieves the email address from each member\r\ncontained in roster who is eligible for Selective Service and\r\nthen prints it:\r\nprocessPersonsWithFunction(\r\n    roster,\r\n    p -> p.getGender() == Person.Sex.MALE\r\n        && p.getAge() >= 18\r\n        && p.getAge() <= 25,\r\n    p -> p.getEmailAddress(),\r\n    email -> System.out.println(email)\r\n);\r\n\r\nApproach 8: Use Generics More Extensively\r\nReconsider the method processPersonsWithFunction. The following is a generic version of it that accepts, as a parameter, a collection that contains elements of any data type:\r\npublic static <X, Y> void processElements(\r\n    Iterable<X> source,\r\n    Predicate<X> tester,\r\n    Function <X, Y> mapper,\r\n    Consumer<Y> block) {\r\n    for (X p : source) {\r\n        if (tester.test(p)) {\r\n            Y data = mapper.apply(p);\r\n            block.accept(data);\r\n        }\r\n    }\r\n}\r\nTo print the e-mail address of members who are eligible for Selective Service, invoke the processElements method as follows:\r\nprocessElements(\r\n    roster,\r\n    p -> p.getGender() == Person.Sex.MALE\r\n        && p.getAge() >= 18\r\n        && p.getAge() <= 25,\r\n    p -> p.getEmailAddress(),\r\n    email -> System.out.println(email)\r\n);\r\nThis method invocation performs the following actions:\r\n\r\nObtains a source of objects from the collection source. In this example, it obtains a source of Person objects from the collection roster. Notice that the collection roster, which is a collection of type List, is also an object of type Iterable.\r\nFilters objects that match the Predicate object tester. In this example, the Predicate object is a lambda expression that specifies which members would be eligible for Selective Service.\r\nMaps each filtered object to a value as specified by the Function object mapper. In this example, the Function object is a lambda expression that returns the e-mail address of a member.\r\nPerforms an action on each mapped object as specified by the Consumer object block. In this example, the Consumer object is a lambda expression that prints a string, which is the e-mail address returned by the Function object.\r\n\r\nYou can replace each of these actions with an aggregate operation.\r\n\r\nApproach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters\r\nThe following example uses aggregate operations to print the e-mail addresses of those members contained in the collection roster who are eligible for Selective Service:\r\nroster\r\n    .stream()\r\n    .filter(\r\n        p -> p.getGender() == Person.Sex.MALE\r\n            && p.getAge() >= 18\r\n            && p.getAge() <= 25)\r\n    .map(p -> p.getEmailAddress())\r\n    .forEach(email -> System.out.println(email));\r\nThe following table maps each of the operations the method processElements performs with the corresponding aggregate operation:\r\n\r\n\r\nprocessElements Action\r\nAggregate Operation\r\n\r\n\r\nObtain a source of objects\r\nStream<E> stream()\r\n\r\n\r\nFilter objects that match a Predicate object\r\nStream<T> filter(Predicate<? super T> predicate)\r\n\r\n\r\nMap objects to another value as specified by a Function object\r\n<R> Stream<R> map(Function<? super T,? extends R> mapper)\r\n\r\n\r\nPerform an action as specified by a Consumer object\r\nvoid forEach(Consumer<? super T> action)\r\n\r\n\r\nThe operations filter, map, and forEach are aggregate operations. Aggregate operations process elements from a stream, not directly from a collection (which is the reason why the first method invoked in this example is stream). A stream is a sequence of elements. Unlike a collection, it is not a data structure that stores elements. Instead, a stream carries values from a source, such as collection, through a pipeline. A pipeline is a sequence of stream operations, which in this example is filter- map-forEach. In addition, aggregate operations typically accept lambda expressions as parameters, enabling you to customize how they behave.\r\nFor a more thorough discussion of aggregate operations, see the\r\nAggregate Operations lesson.\r\nLambda Expressions in GUI Applications\r\nTo process events in a graphical user interface (GUI) application, such as keyboard\r\nactions, mouse actions, and scroll actions, you typically create\r\nevent handlers, which usually involves implementing a particular\r\ninterface. Often, event handler interfaces are functional\r\ninterfaces; they tend to have only one method.\r\nIn the JavaFX example \r\nHelloWorld.java (discussed in the previous section\r\nAnonymous Classes), you can\r\nreplace the highlighted anonymous class with a lambda expression in this\r\nstatement:\r\n        btn.setOnAction(new EventHandler<ActionEvent>() {\r\n\r\n            @Override\r\n            public void handle(ActionEvent event) {\r\n                System.out.println(\"Hello World!\");\r\n            }\r\n        });\r\nThe method invocation btn.setOnAction specifies what\r\nhappens when you select the button represented by the btn object. This method requires\r\nan object of type EventHandler<ActionEvent>. The EventHandler<ActionEvent>\r\ninterface contains only one method, void handle(T event).\r\nThis interface is a functional interface, so you could use the following highlighted lambda expression to replace it:\r\n        btn.setOnAction(\r\n          event -> System.out.println(\"Hello World!\")\r\n        );\r\nSyntax of Lambda Expressions\r\nA lambda expression consists of the following:\r\n\r\nA\r\ncomma-separated list of formal parameters enclosed in\r\nparentheses. The CheckPerson.test method contains one parameter,\r\np, which represents an instance of the\r\nPerson class.\r\nNote: You can\r\nomit the data type of the parameters in a lambda expression. In\r\naddition, you can omit the parentheses if there is only one\r\nparameter. For example, the following lambda expression is also\r\nvalid:\r\np -> p.getGender() == Person.Sex.MALE \r\n    && p.getAge() >= 18\r\n    && p.getAge() <= 25\r\nThe arrow token, ->\r\nA\r\nbody, which consists of a single expression or a statement block. This example uses the following expression:\r\np.getGender() == Person.Sex.MALE \r\n    && p.getAge() >= 18\r\n    && p.getAge() <= 25\r\nIf you\r\nspecify a single expression, then the Java runtime evaluates the\r\nexpression and then returns its value. Alternatively, you can use\r\na return statement:\r\np -> {\r\n    return p.getGender() == Person.Sex.MALE\r\n        && p.getAge() >= 18\r\n        && p.getAge() <= 25;\r\n}\r\nA return statement is not an expression; in a lambda expression,\r\nyou must enclose statements in braces ({}). However, you do not have to enclose a void method invocation in braces. For example, the following is a valid lambda expression:\r\nemail -> System.out.println(email)\r\n\r\n\r\nNote that a lambda expression looks a lot like a method\r\ndeclaration; you can consider lambda expressions as anonymous\r\nmethodsâ\u20ac\u201dmethods without a name.\r\nThe following example,\r\nCalculator, is an example of lambda expressions that take\r\nmore than one formal parameter:\r\n\r\n\r\npublic class Calculator {\r\n  \r\n    interface IntegerMath {\r\n        int operation(int a, int b);   \r\n    }\r\n  \r\n    public int operateBinary(int a, int b, IntegerMath op) {\r\n        return op.operation(a, b);\r\n    }\r\n \r\n    public static void main(String... args) {\r\n    \r\n        Calculator myApp = new Calculator();\r\n        IntegerMath addition = (a, b) -> a + b;\r\n        IntegerMath subtraction = (a, b) -> a - b;\r\n        System.out.println(\"40 + 2 = \" +\r\n            myApp.operateBinary(40, 2, addition));\r\n        System.out.println(\"20 - 10 = \" +\r\n            myApp.operateBinary(20, 10, subtraction));    \r\n    }\r\n}\r\n\r\n\r\nThe method operateBinary performs a\r\nmathematical operation on two integer operands. The operation\r\nitself is specified by an instance of IntegerMath. The example defines two operations with lambda expressions, addition and subtraction. The example prints\r\nthe following:\r\n40 + 2 = 42\r\n20 - 10 = 10\r\nAccessing Local Variables of the Enclosing Scope\r\nLike local and anonymous classes, lambda expressions can\r\ncapture variables; they have the same access to local variables of the enclosing scope. However, unlike local and anonymous classes, lambda expressions do not have any shadowing issues (see\r\nShadowing for more information). Lambda expressions are lexically scoped. This means that they do not inherit any names from a supertype or introduce a new level of scoping. Declarations in a lambda expression are interpreted just as they are in the enclosing environment. The following example,\r\nLambdaScopeTest, demonstrates this:\r\n\r\n\r\nimport java.util.function.Consumer;\r\n\r\npublic class LambdaScopeTest {\r\n\r\n    public int x = 0;\r\n\r\n    class FirstLevel {\r\n\r\n        public int x = 1;\r\n\r\n        void methodInFirstLevel(int x) {\r\n            \r\n            // The following statement causes the compiler to generate\r\n            // the error \"local variables referenced from a lambda expression\r\n            // must be final or effectively final\" in statement A:\r\n            //\r\n            // x = 99;\r\n            \r\n            Consumer<Integer> myConsumer = (y) -> \r\n            {\r\n                System.out.println(\"x = \" + x); // Statement A\r\n                System.out.println(\"y = \" + y);\r\n                System.out.println(\"this.x = \" + this.x);\r\n                System.out.println(\"LambdaScopeTest.this.x = \" +\r\n                    LambdaScopeTest.this.x);\r\n            };\r\n\r\n            myConsumer.accept(x);\r\n\r\n        }\r\n    }\r\n\r\n    public static void main(String... args) {\r\n        LambdaScopeTest st = new LambdaScopeTest();\r\n        LambdaScopeTest.FirstLevel fl = st.new FirstLevel();\r\n        fl.methodInFirstLevel(23);\r\n    }\r\n}\r\n\r\nThis example generates the following output:\r\n\r\nx = 23\r\ny = 23\r\nthis.x = 1\r\nLambdaScopeTest.this.x = 0\r\nIf you substitute the parameter x in place of y in the declaration of the lambda expression myConsumer, then the compiler generates an error:\r\nConsumer<Integer> myConsumer = (x) -> {\r\n    // ...\r\n}\r\nThe compiler generates the error \"variable x is already defined in method methodInFirstLevel(int)\" because the lambda expression does not introduce a new level of scoping. Consequently, you can directly access fields, methods, and local variables of the enclosing scope. For example, the lambda expression directly accesses the parameter x of the method methodInFirstLevel. To access variables in the enclosing class, use the keyword this. In this example, this.x refers to the member variable FirstLevel.x.\r\nHowever, like local and anonymous classes, a lambda expression can only access local variables and parameters of the enclosing block that are final or\r\neffectively final. For example, suppose that you add\r\nthe following assignment statement immediately after the methodInFirstLevel definition statement:\r\nvoid methodInFirstLevel(int x) {\r\n    x = 99;\r\n    // ...\r\n}\r\nBecause of this assignment\r\nstatement, the variable FirstLevel.x is not effectively final anymore. As a result, the Java compiler generates an error message similar to\r\n\"local variables referenced from a lambda expression must be final or effectively final\" where the lambda expression myConsumer tries to access the FirstLevel.x variable:\r\nSystem.out.println(\"x = \" + x);\r\nTarget Typing\r\nHow do you determine the type of a lambda expression? Recall\r\nthe lambda expression that selected members who are male and\r\nbetween the ages 18 and 25 years:\r\np -> p.getGender() == Person.Sex.MALE\r\n    && p.getAge() >= 18\r\n    && p.getAge() <= 25\r\nThis lambda expression was used in the following two methods:\r\n\r\npublic static void printPersons(List<Person> roster, CheckPerson tester) in Approach 3: Specify Search Criteria Code in a Local Class\r\npublic void printPersonsWithPredicate(List<Person> roster, Predicate<Person> tester) in Approach 6: Use Standard Functional Interfaces with Lambda Expressions\r\n\r\nWhen the Java runtime invokes the method printPersons, it's expecting a data type of CheckPerson, so the\r\nlambda expression is of this type. However,\r\nwhen the Java runtime invokes the method printPersonsWithPredicate,\r\nit's expecting a data type of Predicate<Person>,\r\nso the lambda expression is of this type. The data type that\r\nthese methods expect is called the target type. To determine the type of a lambda\r\nexpression, the Java compiler uses the target type of the context\r\nor situation in which the lambda expression was found. It follows\r\nthat you can only use lambda expressions in situations in which\r\nthe Java compiler can determine a target type:\r\n\r\nVariable declarations\r\nAssignments\r\nReturn statements\r\nArray initializers\r\nMethod or constructor arguments\r\nLambda expression bodies\r\nConditional expressions, ?:\r\nCast expressions\r\n\r\nTarget Types and Method Arguments\r\nFor method arguments, the Java compiler determines the target\r\ntype with two other language features: overload resolution and\r\ntype argument inference.\r\nConsider the following two functional interfaces (\r\njava.lang.Runnable and\r\njava.util.concurrent.Callable<V>):\r\npublic interface Runnable {\r\n    void run();\r\n}\r\n\r\npublic interface Callable<V> {\r\n    V call();\r\n}\r\nThe method Runnable.run does not return a value, whereas Callable<V>.call does.\r\nSuppose that you have overloaded the method invoke as follows\r\n(see\r\nDefining Methods for more information about overloading methods):\r\nvoid invoke(Runnable r) {\r\n    r.run();\r\n}\r\n\r\n<T> T invoke(Callable<T> c) {\r\n    return c.call();\r\n}\r\nWhich method will be invoked in the following statement?\r\nString s = invoke(() -> \"done\");\r\nThe method invoke(Callable<T>) will be\r\ninvoked because that method returns a value; the method\r\ninvoke(Runnable) does not. In this case, the type of the lambda expression () -> \"done\" is Callable<T>.\r\nSerialization\r\nYou can \r\nserialize a lambda expression if its target type and its captured arguments are serializable. However, like\r\ninner classes, the serialization of lambda expressions is strongly discouraged.\r\n",
        "title": "Oracle_Lambda Expressions.txt",
        "type": "Oracle_"
    }, {
        "rank": 2,
        "text": "\r\nYou use\r\nlambda expressions to create anonymous methods. Sometimes, however, a lambda expression does nothing but call an existing method. In those cases, it's often clearer to refer to the existing method by name. Method references enable you to do this; they are compact, easy-to-read lambda expressions for methods that already have a name.\r\nConsider again the\r\nPerson class discussed in the section\r\nLambda Expressions:\r\npublic class Person {\r\n\r\n    public enum Sex {\r\n        MALE, FEMALE\r\n    }\r\n\r\n    String name;\r\n    LocalDate birthday;\r\n    Sex gender;\r\n    String emailAddress;\r\n\r\n    public int getAge() {\r\n        // ...\r\n    }\r\n    \r\n    public Calendar getBirthday() {\r\n        return birthday;\r\n    }    \r\n\r\n    public static int compareByAge(Person a, Person b) {\r\n        return a.birthday.compareTo(b.birthday);\r\n    }}\r\nSuppose that the members of your social networking application are contained in an array, and you want to sort the array by age. You could use the following code (find the code excerpts described in this section in the example\r\nMethodReferencesTest):\r\nPerson[] rosterAsArray = roster.toArray(new Person[roster.size()]);\r\n\r\nclass PersonAgeComparator implements Comparator<Person> {\r\n    public int compare(Person a, Person b) {\r\n        return a.getBirthday().compareTo(b.getBirthday());\r\n    }\r\n}\r\n        \r\nArrays.sort(rosterAsArray, new PersonAgeComparator());\r\nThe method signature of this invocation of sort is the following:\r\nstatic <T> void sort(T[] a, Comparator<? super T> c)\r\nNotice that the interface Comparator is a functional interface. Therefore, you could use a lambda expression instead of defining and then creating a new instance of a class that implements Comparator:\r\nArrays.sort(rosterAsArray,\r\n    (Person a, Person b) -> {\r\n        return a.getBirthday().compareTo(b.getBirthday());\r\n    }\r\n);\r\nHowever, this method to compare the birth dates of two Person instances already exists as Person.compareByAge. You can invoke this method instead in the body of the lambda expression:\r\nArrays.sort(rosterAsArray,\r\n    (a, b) -> Person.compareByAge(a, b)\r\n);\r\nBecause this lambda expression invokes an existing method, you can use a method reference instead of a lambda expression:\r\nArrays.sort(rosterAsArray, Person::compareByAge);\r\nThe method reference Person::compareByAge is semantically the same as the lambda expression (a, b) -> Person.compareByAge(a, b). Each has the following characteristics:\r\n\r\nIts formal parameter list is copied from Comparator<Person>.compare, which is (Person, Person).\r\nIts body calls the method Person.compareByAge.\r\n\r\nKinds of Method References\r\nThere are four kinds of method references:\r\n\r\n\r\nKind\r\nExample\r\n\r\n\r\nReference to a static method\r\nContainingClass::staticMethodName\r\n\r\n\r\nReference to an instance method of a particular object\r\ncontainingObject::instanceMethodName\r\n\r\n\r\nReference to an instance method of an arbitrary object of a particular type\r\nContainingType::methodName\r\n\r\n\r\nReference to a constructor\r\nClassName::new\r\n\r\n\r\nReference to a Static Method\r\nThe method reference Person::compareByAge is a reference to a static method.\r\nReference to an Instance Method of a Particular Object\r\nThe following is an example of a reference to an instance method of a particular object:\r\nclass ComparisonProvider {\r\n    public int compareByName(Person a, Person b) {\r\n        return a.getName().compareTo(b.getName());\r\n    }\r\n        \r\n    public int compareByAge(Person a, Person b) {\r\n        return a.getBirthday().compareTo(b.getBirthday());\r\n    }\r\n}\r\nComparisonProvider myComparisonProvider = new ComparisonProvider();\r\nArrays.sort(rosterAsArray, myComparisonProvider::compareByName);\r\nThe method reference myComparisonProvider::compareByName invokes the method compareByName that is part of the object myComparisonProvider. The JRE infers the method type arguments, which in this case are (Person, Person).\r\nReference to an Instance Method of an Arbitrary Object of a Particular Type\r\nThe following is an example of a reference to an instance method of an arbitrary object of a particular type:\r\nString[] stringArray = { \"Barbara\", \"James\", \"Mary\", \"John\",\r\n    \"Patricia\", \"Robert\", \"Michael\", \"Linda\" };\r\nArrays.sort(stringArray, String::compareToIgnoreCase);\r\nThe equivalent lambda expression for the method reference String::compareToIgnoreCase would have the formal parameter list (String a, String b), where a and b are arbitrary names used to better describe this example. The method reference would invoke the method a.compareToIgnoreCase(b).\r\nReference to a Constructor\r\nYou can reference a constructor in the same way as a static method by using the name new. The following method copies elements from one collection to another:\r\npublic static <T, SOURCE extends Collection<T>, DEST extends Collection<T>>\r\n    DEST transferElements(\r\n        SOURCE sourceCollection,\r\n        Supplier<DEST> collectionFactory) {\r\n        \r\n        DEST result = collectionFactory.get();\r\n        for (T t : sourceCollection) {\r\n            result.add(t);\r\n        }\r\n        return result;\r\n}\r\nThe functional interface Supplier contains one method get that takes no arguments and returns an object. Consequently, you can invoke the method transferElements with a lambda expression as follows:\r\nSet<Person> rosterSetLambda =\r\n    transferElements(roster, () -> { return new HashSet<>(); });\r\nYou can use a constructor reference in place of the lambda expression as follows:\r\nSet<Person> rosterSet = transferElements(roster, HashSet::new);\r\nThe Java compiler infers that you want to create a HashSet collection that contains elements of type Person. Alternatively, you can specify this as follows:\r\nSet<Person> rosterSet = transferElements(roster, HashSet<Person>::new);\r\n",
        "title": "Oracle_Method References.txt",
        "type": "Oracle_"
    }, {
        "rank": 3,
        "text": "\r\n\r\nAn abstract class is a class that is declared abstractâ\u20ac\u201dit may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.\r\nAn abstract method is a method that is declared without an implementation (without braces, and followed by a semicolon), like this:\r\n\r\nabstract void moveTo(double deltaX, double deltaY);\r\n\r\nIf a class includes abstract methods, then the class itself must be declared abstract, as in:\r\n\r\npublic abstract class GraphicObject {\r\n   // declare fields\r\n   // declare nonabstract methods\r\n   abstract void draw();\r\n}\r\n\r\nWhen an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, then the subclass must also be declared abstract.\r\nNote:Â Methods in an interface (see the \r\nInterfaces section) that are not declared as default or static are implicitly abstract, so the abstract modifier is not used with interface methods. (It can be used, but it is unnecessary.)\r\n\r\nAbstract Classes Compared to Interfaces\r\nAbstract classes are similar to interfaces. You cannot instantiate them, and they may contain a mix of methods declared with or without an implementation. However, with abstract classes, you can declare fields that are not static and final, and define public, protected, and private concrete methods. With interfaces, all fields are automatically public, static, and final, and all methods that you declare or define (as default methods) are public. In addition, you can extend only one class, whether or not it is abstract, whereas you can implement any number of interfaces.\r\nWhich should you use, abstract classes or interfaces?\r\n\r\nConsider using abstract classes if any of these statements apply to your situation:\r\n    \r\nYou want to share code among several closely related classes.\r\nYou expect that classes that extend your abstract class have many common methods or fields, or require access modifiers other than public (such as protected and private).\r\nYou want to declare non-static or non-final fields. This enables you to define methods that can access and modify the state of the object to which they belong.\r\n\r\n\r\nConsider using interfaces if any of these statements apply to your situation:\r\n    \r\nYou expect that unrelated classes would implement your interface. For example, the interfaces\r\nComparable and\r\nCloneable are implemented by many unrelated classes.\r\nYou want to specify the behavior of a particular data type, but not concerned about who implements its behavior.\r\nYou want to take advantage of multiple inheritance of type.\r\n\r\n\r\n\r\nAn example of an abstract class in the JDK is\r\nAbstractMap, which is part of the Collections Framework. Its subclasses (which include HashMap, TreeMap, and ConcurrentHashMap) share many methods (including get, put, isEmpty, containsKey, and containsValue) that AbstractMap defines.\r\nAn example of a class in the JDK that implements several interfaces is \r\nHashMap, which implements the interfaces Serializable, Cloneable, and Map<K, V>. By reading this list of interfaces, you can infer that an instance of HashMap (regardless of the developer or company who implemented the class) can be cloned, is serializable (which means that it can be converted into a byte stream; \r\nsee the section\r\nSerializable Objects), and has the functionality of a map. In addition, the Map<K, V> interface has been enhanced with many default methods such as merge and forEach that older classes that have implemented this interface do not have to define.\r\nNote that many software libraries use both abstract classes and interfaces; the HashMap class implements several interfaces and also extends the abstract class AbstractMap.\r\nAn Abstract Class Example\r\nIn an object-oriented drawing application, you can draw circles, rectangles, lines, Bezier curves, and many other graphic objects. These objects all have certain states (for example: position, orientation, line color, fill color) and behaviors (for example: moveTo, rotate, resize, draw) in common. Some of these states and behaviors are the same for all graphic objects (for example: position, fill color, and moveTo). Others require different implementations (for example, resize or draw). All GraphicObjects must be able to draw or resize themselves; they just differ in how they do it. This is a perfect situation for an abstract superclass. You can take advantage of the similarities and declare all the graphic objects to inherit from the same abstract parent object (for example, GraphicObject) as shown in \r\nthe following figure.\r\n",
        "title": "Oracle_Abstract Methods and Classes.txt",
        "type": "Oracle_"
    }, {
        "rank": 4,
        "text": "\r\nA \r\nMap is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value. It models the mathematical function abstraction. The Map interface includes methods for \r\nbasic operations (such as put, get, remove, \r\ncontainsKey, containsValue, size, and empty),\r\nbulk operations (such as putAll and clear), and\r\ncollection views (such as keySet, entrySet, and values).\r\n\r\n\r\nThe Java platform contains three general-purpose Map implementations: \r\nHashMap, \r\nTreeMap, and \r\nLinkedHashMap. Their behavior and performance are precisely analogous to HashSet, TreeSet, and LinkedHashSet, as described in \r\nThe Set Interface section. \r\n\r\nThe remainder of this page discusses the Map interface in detail. \r\nBut first, here are some more examples of collecting to Maps using JDK 8 aggregate operations. Modeling real-world objects is a common task in object-oriented programming, so it is reasonable to think that some programs might, for example, group employees by department:\r\n\r\n\r\n// Group employees by department\r\nMap<Department, List<Employee>> byDept = employees.stream()\r\n.collect(Collectors.groupingBy(Employee::getDepartment));\r\n\r\n\r\nOr compute the sum of all salaries by department:\r\n\r\n\r\n// Compute sum of salaries by department\r\nMap<Department, Integer> totalByDept = employees.stream()\r\n.collect(Collectors.groupingBy(Employee::getDepartment,\r\nCollectors.summingInt(Employee::getSalary)));\r\n\r\n\r\nOr perhaps group students by passing or failing grades:\r\n\r\n\r\n// Partition students into passing and failing\r\nMap<Boolean, List<Student>> passingFailing = students.stream()\r\n.collect(Collectors.partitioningBy(s -> s.getGrade()>= PASS_THRESHOLD)); \r\n\r\n\r\nYou could also group people by city:\r\n\r\n\r\n// Classify Person objects by city\r\nMap<String, List<Person>> peopleByCity\r\n         = personStream.collect(Collectors.groupingBy(Person::getCity));\r\n\r\n\r\nOr even cascade two collectors to classify people by state and city:\r\n\r\n\r\n// Cascade Collectors \r\nMap<String, Map<String, List<Person>>> peopleByStateAndCity\r\n  = personStream.collect(Collectors.groupingBy(Person::getState,\r\n  Collectors.groupingBy(Person::getCity)))\r\n\r\n\r\nAgain, these are but a few examples of how to use the new JDK 8 APIs. For in-depth\r\ncoverage of lambda expressions and aggregate operations see the lesson entitled\r\n\r\nAggregate Operations.\r\n\r\n\r\nMap Interface Basic Operations\r\nThe basic operations of Map (put, get, containsKey, containsValue, size, and isEmpty) behave exactly like their counterparts in Hashtable. The \r\nfollowing program generates a frequency table of the words found in its argument list. The frequency table maps each word to the number of times it occurs in the argument list.\r\n\r\nimport java.util.*;\r\n\r\npublic class Freq {\r\n    public static void main(String[] args) {\r\n        Map<String, Integer> m = new HashMap<String, Integer>();\r\n\r\n        // Initialize frequency table from command line\r\n        for (String a : args) {\r\n            Integer freq = m.get(a);\r\n            m.put(a, (freq == null) ? 1 : freq + 1);\r\n        }\r\n\r\n        System.out.println(m.size() + \" distinct words:\");\r\n        System.out.println(m);\r\n    }\r\n}\r\n\r\nThe only tricky thing about this program is the second argument of the put statement. That argument is a conditional expression that has the effect of setting the frequency to one if the word has never been seen before or one more than its current value if the word has already been seen. Try running this program with the command:\r\n\r\njava Freq if it is to be it is up to me to delegate\r\n\r\nThe program yields the following output.\r\n\r\n8 distinct words:\r\n{to=3, delegate=1, be=1, it=2, up=1, if=1, me=1, is=2}\r\n\r\nSuppose you'd prefer to see the frequency table in alphabetical order. All you have to do is change the implementation type of the Map from HashMap to TreeMap. Making this four-character change causes the program to generate the following output from the same command line.\r\n\r\n8 distinct words:\r\n{be=1, delegate=1, if=1, is=2, it=2, me=1, to=3, up=1}\r\n\r\nSimilarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to LinkedHashMap. Doing so results in the following output.\r\n\r\n8 distinct words:\r\n{if=1, it=2, is=2, to=3, be=1, up=1, me=1, delegate=1}\r\n\r\nThis flexibility provides a potent illustration of the power of an interface-based framework.\r\nLike the \r\nSetand \r\nListinterfaces, Map strengthens the requirements on the equals and hashCode methods so that two Map objects can be compared for logical equality without regard to their implementation types. Two Map instances are equal if they represent the same key-value mappings.\r\nBy convention, all general-purpose Map implementations provide constructors that take a Map object and initialize the new Map to contain all the key-value mappings in the specified Map. This standard Map conversion constructor is entirely analogous to the standard Collection constructor: It allows the caller to create a Map of a desired implementation type that initially contains all of the mappings in another Map, regardless of the other Map's implementation type. For example, suppose you have a Map, named m. The following one-liner creates a new HashMap initially containing all of the same key-value mappings as m.\r\n\r\nMap<K, V> copy = new HashMap<K, V>(m);\r\n\r\nMap Interface Bulk Operations\r\nThe clear operation does exactly what you would think it could do: It removes all the mappings from the Map. The putAll operation is the Map analogue of the Collection interface's addAll operation. In addition to its obvious use of dumping one Map into another, it has a second, more subtle use. Suppose a Map is used to represent a collection of attribute-value pairs; the putAll operation, in combination with the Map conversion constructor, provides a neat way to implement attribute map creation with default values. The following is a static factory method that demonstrates this technique.\r\n\r\nstatic <K, V> Map<K, V> newAttributeMap(Map<K, V>defaults, Map<K, V> overrides) {\r\n    Map<K, V> result = new HashMap<K, V>(defaults);\r\n    result.putAll(overrides);\r\n    return result;\r\n}\r\n\r\nCollection Views\r\nThe Collection view methods allow a Map to be viewed as a Collection in these three ways:\r\n\r\nkeySet â\u20ac\u201d the Set of keys contained in the Map.\r\nvalues â\u20ac\u201d The Collection of values contained in the Map. This Collection is not a Set, because multiple keys can map to the same value.\r\nentrySet â\u20ac\u201d the Set of key-value pairs contained in the Map. The Map interface provides a small nested interface called Map.Entry, the type of the elements in this Set.\r\n\r\nThe Collection views provide the only means to iterate over a Map. This example illustrates the standard idiom for iterating over the keys in a Map with a for-each construct:\r\n\r\nfor (KeyType key : m.keySet())\r\n    System.out.println(key);\r\n\r\nand with an iterator:\r\n\r\n// Filter a map based on some \r\n// property of its keys.\r\nfor (Iterator<Type> it = m.keySet().iterator(); it.hasNext(); )\r\n    if (it.next().isBogus())\r\n        it.remove();\r\n\r\nThe idiom for iterating over values is analogous. Following is the idiom for iterating over key-value pairs.\r\n\r\nfor (Map.Entry<KeyType, ValType> e : m.entrySet())\r\n    System.out.println(e.getKey() + \": \" + e.getValue());\r\n\r\nAt first, many people worry that these idioms may be slow because the Map has to create a new Collection instance each time a Collection view operation is called. Rest easy: There's no reason that a Map cannot always return the same object each time it is asked for a given Collection view. This is precisely what all the Map implementations in java.util do.\r\nWith all three Collection views, calling an Iterator's remove operation removes the associated entry from the backing Map, assuming that the backing Map supports element removal to begin with. This is illustrated by the preceding filtering idiom.\r\nWith the entrySet view, it is also possible to change the value associated with a key by calling a Map.Entry's setValue method during iteration (again, assuming the Map supports value modification to begin with). Note that these are the only safe ways to modify a Map during iteration; the behavior is unspecified if the underlying Map is modified in any other way while the iteration is in progress.\r\nThe Collection views support element removal in all its many forms â\u20ac\u201d remove, removeAll, retainAll, and clear operations, as well as the Iterator.remove operation. (Yet again, this assumes that the backing Map supports element removal.)\r\nThe Collection views do not support element addition under any circumstances. It would make no sense for the keySet and values views, and it's unnecessary for the entrySet view, because the backing Map's put and putAll methods provide the same functionality.\r\nFancy Uses of Collection Views: Map Algebra\r\nWhen applied to the Collection views, bulk operations (containsAll, removeAll, and retainAll) are surprisingly potent tools. For starters, suppose you want to know whether one Map is a submap of another â\u20ac\u201d that is, whether the first Map contains all the key-value mappings in the second. The following idiom does the trick.\r\n\r\nif (m1.entrySet().containsAll(m2.entrySet())) {\r\n    ...\r\n}\r\n\r\nAlong similar lines, suppose you want to know whether two Map objects contain mappings for all of the same keys.\r\n\r\nif (m1.keySet().equals(m2.keySet())) {\r\n    ...\r\n}\r\n\r\nSuppose you have a Map that represents a collection of attribute-value pairs, and two Sets representing required attributes and permissible attributes. (The permissible attributes include the required attributes.) The following snippet determines whether the attribute map conforms to these constraints and prints a detailed error message if it doesn't.\r\n\r\nstatic <K, V> boolean validate(Map<K, V> attrMap, Set<K> requiredAttrs, Set<K>permittedAttrs) {\r\n    boolean valid = true;\r\n    Set<K> attrs = attrMap.keySet();\r\n\r\n    if (! attrs.containsAll(requiredAttrs)) {\r\n        Set<K> missing = new HashSet<K>(requiredAttrs);\r\n        missing.removeAll(attrs);\r\n        System.out.println(\"Missing attributes: \" + missing);\r\n        valid = false;\r\n    }\r\n    if (! permittedAttrs.containsAll(attrs)) {\r\n        Set<K> illegal = new HashSet<K>(attrs);\r\n        illegal.removeAll(permittedAttrs);\r\n        System.out.println(\"Illegal attributes: \" + illegal);\r\n        valid = false;\r\n    }\r\n    return valid;\r\n}\r\n\r\nSuppose you want to know all the keys common to two Map objects.\r\n\r\nSet<KeyType>commonKeys = new HashSet<KeyType>(m1.keySet());\r\ncommonKeys.retainAll(m2.keySet());\r\n\r\nA similar idiom gets you the common values.\r\nAll the idioms presented thus far have been nondestructive; that is, they don't modify the backing Map. Here are a few that do. Suppose you want to remove all of the key-value pairs that one Map has in common with another.\r\n\r\nm1.entrySet().removeAll(m2.entrySet());\r\n\r\nSuppose you want to remove from one Map all of the keys that have mappings in another.\r\n\r\nm1.keySet().removeAll(m2.keySet());\r\n\r\nWhat happens when you start mixing keys and values in the same bulk operation? Suppose you have a Map, managers, that maps each employee in a company to the employee's manager. We'll be deliberately vague about the types of the key and the value objects. It doesn't matter, as long as they're the same. Now suppose you want to know who all the \"individual contributors\" (or nonmanagers) are. The following snippet tells you exactly what you want to know.\r\n\r\nSet<Employee> individualContributors = new HashSet<Employee>(managers.keySet());\r\nindividualContributors.removeAll(managers.values());\r\n\r\nSuppose you want to fire all the employees who report directly to some manager, Simon.\r\n\r\nEmployee simon = ... ;\r\nmanagers.values().removeAll(Collections.singleton(simon));\r\n\r\nNote that this idiom makes use of Collections.singleton, a static factory method that returns an immutable Set with the single, specified element.\r\nOnce you've done this, you may have a bunch of employees whose managers no longer work for the company (if any of Simon's direct-reports were themselves managers). The following code will tell you which employees have managers who no longer works for the company.\r\n\r\nMap<Employee, Employee> m = new HashMap<Employee, Employee>(managers);\r\nm.values().removeAll(managers.keySet());\r\nSet<Employee> slackers = m.keySet();\r\n\r\nThis example is a bit tricky. First, it makes a temporary copy of the Map, and it removes from the temporary copy all entries whose (manager) value is a key in the original Map. Remember that the original Map has an entry for each employee. Thus, the remaining entries in the temporary Map comprise all the entries from the original Map whose (manager) values are no longer employees. The keys in the temporary copy, then, represent precisely the employees that we're looking for.\r\nThere are many more idioms like the ones contained in this section, but it would be impractical and tedious to list them all. Once you get the hang of it, it's not that difficult to come up with the right one when you need it.\r\nMultimaps\r\nA multimap is like a Map but it can map each key to multiple values. The Java Collections Framework doesn't include an interface for multimaps because they aren't used all that commonly. It's a fairly simple matter to use a Map whose values are List instances as a multimap. This technique is demonstrated in the next code example, which reads a word list containing one word per line (all lowercase) and prints out all the anagram groups that meet a size criterion. An anagram group is a bunch of words, all of which contain exactly the same letters but in a different order. The program takes two arguments on the command line: (1) the name of the dictionary file and (2) the minimum size of anagram group to print out. Anagram groups containing fewer words than the specified minimum are not printed.\r\nThere is a standard trick for finding anagram groups: For each word in the dictionary, alphabetize the letters in the word (that is, reorder the word's letters into alphabetical order) and put an entry into a multimap, mapping the alphabetized word to the original word. For example, the word bad causes an entry mapping abd into bad to be put into the multimap. A moment's reflection will show that all the words to which any given key maps form an anagram group. It's a simple matter to iterate over the keys in the multimap, printing out each anagram group that meets the size constraint.\r\n\r\nThe following program is a straightforward implementation of this technique.\r\n\r\nimport java.util.*;\r\nimport java.io.*;\r\n\r\npublic class Anagrams {\r\n    public static void main(String[] args) {\r\n        int minGroupSize = Integer.parseInt(args[1]);\r\n\r\n        // Read words from file and put into a simulated multimap\r\n        Map<String, List<String>> m = new HashMap<String, List<String>>();\r\n\r\n        try {\r\n            Scanner s = new Scanner(new File(args[0]));\r\n            while (s.hasNext()) {\r\n                String word = s.next();\r\n                String alpha = alphabetize(word);\r\n                List<String> l = m.get(alpha);\r\n                if (l == null)\r\n                    m.put(alpha, l=new ArrayList<String>());\r\n                l.add(word);\r\n            }\r\n        } catch (IOException e) {\r\n            System.err.println(e);\r\n            System.exit(1);\r\n        }\r\n\r\n        // Print all permutation groups above size threshold\r\n        for (List<String> l : m.values())\r\n            if (l.size() >= minGroupSize)\r\n                System.out.println(l.size() + \": \" + l);\r\n    }\r\n\r\n    private static String alphabetize(String s) {\r\n        char[] a = s.toCharArray();\r\n        Arrays.sort(a);\r\n        return new String(a);\r\n    }\r\n}\r\n\r\nRunning this program on a 173,000-word dictionary file with a minimum anagram group size of eight produces the following output.\r\n\r\n9: [estrin, inerts, insert, inters, niters, nitres, sinter,\r\n     triens, trines]\r\n8: [lapse, leaps, pales, peals, pleas, salep, sepal, spale]\r\n8: [aspers, parses, passer, prases, repass, spares, sparse,\r\n     spears]\r\n10: [least, setal, slate, stale, steal, stela, taels, tales,\r\n      teals, tesla]\r\n8: [enters, nester, renest, rentes, resent, tenser, ternes,\r\n     treens]\r\n8: [arles, earls, lares, laser, lears, rales, reals, seral]\r\n8: [earings, erasing, gainers, reagins, regains, reginas,\r\n     searing, seringa]\r\n8: [peris, piers, pries, prise, ripes, speir, spier, spire]\r\n12: [apers, apres, asper, pares, parse, pears, prase, presa,\r\n      rapes, reaps, spare, spear]\r\n11: [alerts, alters, artels, estral, laster, ratels, salter,\r\n      slater, staler, stelar, talers]\r\n9: [capers, crapes, escarp, pacers, parsec, recaps, scrape,\r\n     secpar, spacer]\r\n9: [palest, palets, pastel, petals, plates, pleats, septal,\r\n     staple, tepals]\r\n9: [anestri, antsier, nastier, ratines, retains, retinas,\r\n     retsina, stainer, stearin]\r\n8: [ates, east, eats, etas, sate, seat, seta, teas]\r\n8: [carets, cartes, caster, caters, crates, reacts, recast,\r\n     traces]\r\n\r\n\r\nMany of these words seem a bit bogus, but that's not the program's fault; they're in the dictionary file. \r\nHere's the\r\ndictionary file we used.\r\nIt was derived from the Public Domain ENABLE benchmark reference word list.\r\n\r\n",
        "title": "Oracle_The Map Interface.txt",
        "type": "Oracle_"
    }, {
        "rank": 5,
        "text": "\r\nThe section\r\nAggregate Operations describes the following pipeline of operations, which calculates the average age of all male members in the collection roster:\r\ndouble average = roster\r\n    .stream()\r\n    .filter(p -> p.getGender() == Person.Sex.MALE)\r\n    .mapToInt(Person::getAge)\r\n    .average()\r\n    .getAsDouble();\r\nThe JDK contains many terminal operations (such as\r\naverage,\r\nsum,\r\nmin,\r\nmax, and\r\ncount) that return one value by combining the contents of a stream. These operations are called reduction operations. The JDK also contains reduction operations that return a collection instead of a single value. Many reduction operations perform a specific task, such as finding the average of values or grouping elements into categories. However, the JDK provides you with the general-purpose reduction operations\r\nreduce and\r\ncollect, which this section describes in detail.\r\nThis section covers the following topics:\r\n\r\nThe Stream.reduce Method\r\nThe Stream.collect Method\r\n\r\nYou can find the code excerpts described in this section in the example\r\nReductionExamples.\r\nThe Stream.reduce Method\r\nThe\r\nStream.reduce method is a general-purpose reduction operation. Consider the following pipeline, which calculates the sum of the male members' ages in the collection roster. It uses the\r\nStream.sum reduction operation:\r\nInteger totalAge = roster\r\n    .stream()\r\n    .mapToInt(Person::getAge)\r\n    .sum();\r\nCompare this with the following pipeline, which uses the Stream.reduce operation to calculate the same value:\r\nInteger totalAgeReduce = roster\r\n   .stream()\r\n   .map(Person::getAge)\r\n   .reduce(\r\n       0,\r\n       (a, b) -> a + b);\r\nThe reduce operation in this example takes two arguments:\r\n\r\nidentity: The identity element is both the initial value of the reduction and the default result if there are no elements in the stream. In this example, the identity element is 0; this is the initial value of the sum of ages and the default value if no members exist in the collection roster.\r\naccumulator: The accumulator function takes two parameters: a partial result of the reduction (in this example, the sum of all processed integers so far) and the next element of the stream (in this example, an integer). It returns a new partial result. In this example, the accumulator function is a lambda expression that adds two Integer values and returns an Integer value:\r\n(a, b) -> a + b\r\n\r\nThe reduce operation always returns a new value. However, the accumulator function also returns a new value every time it processes an element of a stream. Suppose that you want to reduce the elements of a stream to a more complex object, such as a collection. This might hinder the performance of your application. If your reduce operation involves adding elements to a collection, then every time your accumulator function processes an element, it creates a new collection that includes the element, which is inefficient. It would be more efficient for you to update an existing collection instead. You can do this with the\r\nStream.collect method, which the next section describes.\r\nThe Stream.collect Method\r\nUnlike the reduce method, which always creates a new value when it processes an element, the\r\ncollect method modifies, or mutates, an existing value.\r\nConsider how to find the average of values in a stream. You require two pieces of data: the total number of values and the sum of those values. However, like the reduce method and all other reduction methods, the collect method returns only one value. You can create a new data type that contains member variables that keep track of the total number of values and the sum of those values, such as the following class,\r\nAverager:\r\nclass Averager implements IntConsumer\r\n{\r\n    private int total = 0;\r\n    private int count = 0;\r\n        \r\n    public double average() {\r\n        return count > 0 ? ((double) total)/count : 0;\r\n    }\r\n        \r\n    public void accept(int i) { total += i; count++; }\r\n    public void combine(Averager other) {\r\n        total += other.total;\r\n        count += other.count;\r\n    }\r\n}\r\nThe following pipeline uses the Averager class and the collect method to calculate the average age of all male members:\r\nAverager averageCollect = roster.stream()\r\n    .filter(p -> p.getGender() == Person.Sex.MALE)\r\n    .map(Person::getAge)\r\n    .collect(Averager::new, Averager::accept, Averager::combine);\r\n                   \r\nSystem.out.println(\"Average age of male members: \" +\r\n    averageCollect.average());\r\nThe collect operation in this example takes three arguments:\r\n\r\nsupplier: The supplier is a factory function; it constructs new instances. For the collect operation, it creates instances of the result container. In this example, it is a new instance of the Averager class.\r\naccumulator: The accumulator function incorporates a stream element into a result container. In this example, it modifies the Averager result container by incrementing the count variable by one and adding to the total member variable the value of the stream element, which is an integer representing the age of a male member.\r\ncombiner: The combiner function takes two result containers and merges their contents. In this example, it modifies an  Averager result container by incrementing the count variable by the count member variable of the other Averager instance and adding to the total member variable the value of the other Averager instance's total member variable.\r\nNote the following:\r\n\r\nThe supplier is a lambda expression (or a method reference) as opposed to a value like the identity element in the reduce operation.\r\nThe accumulator and combiner functions do not return a value.\r\nYou can use the collect operations with parallel streams; see the section\r\nParallelism for more information. (If you run the collect method with a parallel stream, then the JDK creates a new thread whenever the combiner function creates a new object, such as an Averager object in this example. Consequently, you do not have to worry about synchronization.)\r\n\r\nAlthough the JDK provides you with the average operation to calculate the average value of elements in a stream, you can use the collect operation and a custom class if you need to calculate several values from the elements of a stream.\r\nThe collect operation is best suited for collections. The following example puts the names of the male members in a collection with the collect operation:\r\nList<String> namesOfMaleMembersCollect = roster\r\n    .stream()\r\n    .filter(p -> p.getGender() == Person.Sex.MALE)\r\n    .map(p -> p.getName())\r\n    .collect(Collectors.toList());\r\nThis version of the collect operation takes one parameter of type\r\nCollector. This class encapsulates the functions used as arguments in the collect operation that requires three arguments (supplier, accumulator, and combiner functions).\r\nThe\r\nCollectors class contains many useful reduction operations, such as accumulating elements into collections and summarizing elements according to various criteria. These reduction operations return instances of the class Collector, so you can use them as a parameter for the collect operation.\r\nThis example uses the\r\nCollectors.toList operation, which accumulates the stream elements into a new instance of List. As with most operations in the Collectors class, the toList operator returns an instance of Collector, not a collection.\r\nThe following example groups members of the collection roster by gender:\r\nMap<Person.Sex, List<Person>> byGender =\r\n    roster\r\n        .stream()\r\n        .collect(\r\n            Collectors.groupingBy(Person::getGender));\r\nThe\r\ngroupingBy operation returns a map whose keys are the values that result from applying the lambda expression specified as its parameter (which is called a classification function). In this example, the returned map contains two keys, Person.Sex.MALE and Person.Sex.FEMALE. The keys' corresponding values are instances of List that contain the stream elements that, when processed by the classification function, correspond to the key value. For example, the value that corresponds to key Person.Sex.MALE is an instance of List that contains all male members.\r\nThe following example retrieves the names of each member in the collection roster and groups them by gender:\r\nMap<Person.Sex, List<String>> namesByGender =\r\n    roster\r\n        .stream()\r\n        .collect(\r\n            Collectors.groupingBy(\r\n                Person::getGender,                      \r\n                Collectors.mapping(\r\n                    Person::getName,\r\n                    Collectors.toList())));\r\nThe\r\ngroupingBy operation in this example takes two parameters, a classification function and an instance of Collector. The Collector parameter is called a downstream collector. This is a collector that the Java runtime applies to the results of another collector. Consequently, this groupingBy operation enables you to apply a collect method to the List values created by the groupingBy operator. This example applies the collector \r\nmapping, which applies the mapping function Person::getName to each element of the stream. Consequently, the resulting stream consists of only the names of members. A pipeline that contains one or more downstream collectors, like this example, is called a multilevel reduction.\r\nThe following example retrieves the total age of members of each gender:\r\nMap<Person.Sex, Integer> totalAgeByGender =\r\n    roster\r\n        .stream()\r\n        .collect(\r\n            Collectors.groupingBy(\r\n                Person::getGender,                      \r\n                Collectors.reducing(\r\n                    0,\r\n                    Person::getAge,\r\n                    Integer::sum)));\r\nThe \r\nreducing operation takes three parameters:\r\n\r\nidentity: Like the Stream.reduce operation, the identity element is both the initial value of the reduction and the default result if there are no elements in the stream. In this example, the identity element is 0; this is the initial value of the sum of ages and the default value if no members exist.\r\nmapper: The reducing operation applies this mapper function to all stream elements. In this example, the mapper retrieves the age of each member.\r\noperation: The operation function is used to reduce the mapped values. In this example, the operation function adds Integer values.\r\n\r\nThe following example retrieves the average age of members of each gender:\r\nMap<Person.Sex, Double> averageAgeByGender = roster\r\n    .stream()\r\n    .collect(\r\n        Collectors.groupingBy(\r\n            Person::getGender,                      \r\n            Collectors.averagingInt(Person::getAge)));\r\n",
        "title": "Oracle_Reduction.txt",
        "type": "Oracle_"
    }, {
        "rank": 6,
        "text": "\r\n\r\nTo use Java generics effectively, you must consider the following restrictions:\r\n\r\n\r\nCannot Instantiate Generic Types with Primitive Types\r\n\r\nCannot Create Instances of Type Parameters\r\n\r\nCannot Declare Static Fields Whose Types are Type Parameters\r\n\r\nCannot Use Casts or instanceof With Parameterized Types\r\n\r\nCannot Create Arrays of Parameterized Types\r\n\r\nCannot Create, Catch, or Throw Objects of Parameterized Types\r\n\r\nCannot Overload a Method Where the Formal Parameter Types of Each Overload Erase to the Same Raw Type\r\n\r\nCannot Instantiate Generic Types with Primitive Types\r\n\r\nConsider the following parameterized type:\r\n\r\nclass Pair<K, V> {\r\n\r\n    private K key;\r\n    private V value;\r\n\r\n    public Pair(K key, V value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n\r\n    // ...\r\n}\r\n\r\n\r\nWhen creating a Pair object, you cannot substitute a primitive type for the type parameter K or V:\r\n\r\nPair<int, char> p = new Pair<>(8, 'a');  // compile-time error\r\n\r\n\r\nYou can substitute only non-primitive types for the type parameters K and V:\r\n\r\nPair<Integer, Character> p = new Pair<>(8, 'a');\r\n\r\n\r\nNote that the Java compiler autoboxes 8 to Integer.valueOf(8) and 'a' to Character('a'):\r\n\r\nPair<Integer, Character> p = new Pair<>(Integer.valueOf(8), new Character('a'));\r\n\r\nFor more information on autoboxing, see\r\nAutoboxing and Unboxing in the\r\nNumbers and Strings lesson.\r\nCannot Create Instances of Type Parameters\r\n\r\nYou cannot create an instance of a type parameter. For example, the following code causes a compile-time error:\r\n\r\npublic static <E> void append(List<E> list) {\r\n    E elem = new E();  // compile-time error\r\n    list.add(elem);\r\n}\r\n\r\n\r\nAs a workaround, you can create an object of a type parameter through reflection:\r\n\r\npublic static <E> void append(List<E> list, Class<E> cls) throws Exception {\r\n    E elem = cls.newInstance();   // OK\r\n    list.add(elem);\r\n}\r\n\r\n\r\nYou can invoke the append method as follows:\r\n\r\nList<String> ls = new ArrayList<>();\r\nappend(ls, String.class);\r\n\r\nCannot Declare Static Fields Whose Types are Type Parameters\r\n\r\nA class's static field is a class-level variable shared by all non-static objects of the class.  Hence, static fields of type parameters are not allowed. Consider the following class:\r\n\r\npublic class MobileDevice<T> {\r\n    private static T os;\r\n\r\n    // ...\r\n}\r\n\r\n\r\nIf static fields of type parameters were allowed, then the following code would be confused:\r\n\r\nMobileDevice<Smartphone> phone = new MobileDevice<>();\r\nMobileDevice<Pager> pager = new MobileDevice<>();\r\nMobileDevice<TabletPC> pc = new MobileDevice<>();\r\n\r\n\r\nBecause the static field os is shared by phone, pager, and pc, what is the actual type of os? It cannot be Smartphone, Pager, and TabletPC at the same time. You cannot, therefore, create static fields of type parameters.\r\nCannot Use Casts or instanceof with Parameterized Types\r\n\r\nBecause the Java compiler erases all type parameters in generic code, you cannot verify which parameterized type for a generic type is being used at runtime:\r\n\r\npublic static <E> void rtti(List<E> list) {\r\n    if (list instanceof ArrayList<Integer>) {  // compile-time error\r\n        // ...\r\n    }\r\n}\r\n\r\n\r\nThe set of parameterized types passed to the rtti method is:\r\n\r\nS = { ArrayList<Integer>, ArrayList<String> LinkedList<Character>, ... }\r\n\r\n\r\nThe runtime does not keep track of type parameters, so it cannot tell the difference between an ArrayList<Integer> and an ArrayList<String>. The most you can do is to use an unbounded wildcard to verify that the list is an ArrayList:\r\n\r\npublic static void rtti(List<?> list) {\r\n    if (list instanceof ArrayList<?>) {  // OK; instanceof requires a reifiable type\r\n        // ...\r\n    }\r\n}\r\n\r\n\r\nTypically, you cannot cast to a parameterized type unless it is parameterized by unbounded wildcards. For example:\r\n\r\nList<Integer> li = new ArrayList<>();\r\nList<Number>  ln = (List<Number>) li;  // compile-time error\r\n\r\n\r\nHowever, in some cases the compiler knows that a type parameter is always valid and allows the cast.  For example:\r\n\r\nList<String> l1 = ...;\r\nArrayList<String> l2 = (ArrayList<String>)l1;  // OK\r\n\r\nCannot Create Arrays of Parameterized Types\r\n\r\nYou cannot create arrays of parameterized types. For example, the following code does not compile:\r\n\r\nList<Integer>[] arrayOfLists = new List<Integer>[2];  // compile-time error\r\n\r\n\r\nThe following code illustrates what happens when different types are inserted into an array:\r\n\r\nObject[] strings = new String[2];\r\nstrings[0] = \"hi\";   // OK\r\nstrings[1] = 100;    // An ArrayStoreException is thrown.\r\n\r\n\r\nIf you try the same thing with a generic list, there would be a problem:\r\n\r\nObject[] stringLists = new List<String>[];  // compiler error, but pretend it's allowed\r\nstringLists[0] = new ArrayList<String>();   // OK\r\nstringLists[1] = new ArrayList<Integer>();  // An ArrayStoreException should be thrown,\r\n                                            // but the runtime can't detect it.\r\n\r\n\r\nIf arrays of parameterized lists were allowed, the previous code would fail to throw the desired ArrayStoreException.\r\nCannot Create, Catch, or Throw Objects of Parameterized Types\r\n\r\nA generic class cannot extend the Throwable class directly or indirectly.  For example, the following classes will not compile:\r\n\r\n// Extends Throwable indirectly\r\nclass MathException<T> extends Exception { /* ... */ }    // compile-time error\r\n\r\n// Extends Throwable directly\r\nclass QueueFullException<T> extends Throwable { /* ... */ // compile-time error\r\n\r\n\r\nA method cannot catch an instance of a type parameter:\r\n\r\npublic static <T extends Exception, J> void execute(List<J> jobs) {\r\n    try {\r\n        for (J job : jobs)\r\n            // ...\r\n    } catch (T e) {   // compile-time error\r\n        // ...\r\n    }\r\n}\r\n\r\n\r\nYou can, however, use a type parameter in a throws clause:\r\n\r\nclass Parser<T extends Exception> {\r\n    public void parse(File file) throws T {     // OK\r\n        // ...\r\n    }\r\n}\r\n\r\nCannot Overload a Method Where the Formal Parameter Types of Each Overload Erase to the Same Raw Type\r\n\r\nA class cannot have two overloaded methods that will have the same signature after type erasure.\r\n\r\npublic class Example {\r\n    public void print(Set<String> strSet) { }\r\n    public void print(Set<Integer> intSet) { }\r\n}\r\n\r\n\r\nThe overloads would all share the same classfile representation and will generate a compile-time error.\r\n",
        "title": "Oracle_Restrictions on Generics.txt",
        "type": "Oracle_"
    }, {
        "rank": 7,
        "text": "\r\nNote: To better understand the concepts in this section, review the sections\r\nLambda Expressions and\r\nMethod References.\r\nFor what do you use collections? You don't simply store objects in a collection and leave them there. In most cases, you use collections to retrieve items stored in them.\r\nConsider again the scenario described in the section\r\nLambda Expressions. Suppose that you are creating a social networking application. You want to create a feature that enables an administrator to perform any kind of action, such as sending a message, on members of the social networking application that satisfy certain criteria.\r\nAs before, suppose that members of this social networking application are represented by the following\r\nPerson class:\r\npublic class Person {\r\n\r\n    public enum Sex {\r\n        MALE, FEMALE\r\n    }\r\n\r\n    String name;\r\n    LocalDate birthday;\r\n    Sex gender;\r\n    String emailAddress;\r\n    \r\n    // ...\r\n\r\n    public int getAge() {\r\n        // ...\r\n    }\r\n\r\n    public String getName() {\r\n        // ...\r\n    }\r\n}\r\nThe following example prints the name of all members contained in the collection roster with a for-each loop:\r\nfor (Person p : roster) {\r\n    System.out.println(p.getName());\r\n}\r\nThe following example prints all members contained in the collection roster but with the aggregate operation forEach:\r\nroster\r\n    .stream()\r\n    .forEach(e -> System.out.println(e.getName());\r\nAlthough, in this example, the version that uses aggregate operations is longer than the one that uses a for-each loop, you will see that versions that use bulk-data operations will be more concise for more complex tasks.\r\nThe following topics are covered:\r\n\r\nPipelines and Streams\r\nDifferences Between Aggregate Operations and Iterators\r\n\r\nFind the code excerpts described in this section in the example\r\nBulkDataOperationsExamples.\r\nPipelines and Streams\r\nA pipeline is a sequence of aggregate operations. The following example prints the male members contained in the collection roster with a pipeline that consists of the aggregate operations filter and forEach:\r\nroster\r\n    .stream()\r\n    .filter(e -> e.getGender() == Person.Sex.MALE)\r\n    .forEach(e -> System.out.println(e.getName()));\r\nCompare this example to the following that prints the male members contained in the collection roster with a for-each loop:\r\nfor (Person p : roster) {\r\n    if (p.getGender() == Person.Sex.MALE) {\r\n        System.out.println(p.getName());\r\n    }\r\n}\r\nA pipeline contains the following components:\r\n\r\nA source: This could be a collection, an array, a generator function, or an I/O channel. In this example, the source is the collection roster.\r\nZero or more intermediate operations. An intermediate operation, such as filter, produces a new stream.\r\nA stream is a sequence of elements. Unlike a collection, it is not a data structure that stores elements. Instead, a stream carries values from a source through a pipeline. This example creates a stream from the collection roster by invoking the method stream.\r\nThe filter operation returns a new stream that contains elements that match its predicate (this operation's parameter). In this example, the predicate is the lambda expression e -> e.getGender() == Person.Sex.MALE. It returns the boolean value true if the gender field of object e has the value Person.Sex.MALE. Consequently, the filter operation in this example returns a stream that contains all male members in the collection roster.\r\nA terminal operation. A terminal operation, such as forEach,  produces a non-stream result, such as a primitive value (like a double value), a collection, or in the case of forEach, no value at all. In this example, the parameter of the forEach operation is the lambda expression e -> System.out.println(e.getName()), which invokes the method getName on the object e. (The Java runtime and compiler infer that the type of the object e is Person.)\r\n\r\nThe following example calculates the average age of all male members contained in the collection roster with a pipeline that consists of the aggregate operations filter, mapToInt, and average:\r\ndouble average = roster\r\n    .stream()\r\n    .filter(p -> p.getGender() == Person.Sex.MALE)\r\n    .mapToInt(Person::getAge)\r\n    .average()\r\n    .getAsDouble();\r\nThe mapToInt operation returns a new stream of type IntStream (which is a stream that contains only integer values). The operation applies the function specified in its parameter to each element in a particular stream. In this example, the function is Person::getAge, which is a method reference that returns the age of the member. (Alternatively, you could use the lambda expression e -> e.getAge().) Consequently, the mapToInt operation in this example returns a stream that contains the ages of all male members in the collection roster.\r\nThe average operation calculates the average value of the elements contained in a stream of type IntStream. It returns an object of type OptionalDouble. If the stream contains no elements, then the average operation returns an empty instance of OptionalDouble, and invoking the method getAsDouble throws a NoSuchElementException. The JDK contains many terminal operations such as average that return one value by combining the contents of a stream. These operations are called reduction operations; see the section\r\nReduction for more information.\r\nDifferences Between Aggregate Operations and Iterators\r\nAggregate operations, like forEach, appear to be like iterators. However, they have several fundamental differences:\r\n\r\n\r\nThey use internal iteration: Aggregate operations do not contain a method like next to instruct them to process the next element of the collection. With internal delegation, your application determines what collection it iterates, but the JDK determines how to iterate the collection. With external iteration, your application determines both what collection it iterates and how it iterates it. However, external iteration can only iterate over the  elements of a collection sequentially. Internal iteration does not have this limitation. It can more easily take advantage of parallel computing, which involves dividing a problem into subproblems, solving those problems simultaneously, and then combining the results of the solutions to the subproblems. See the section\r\nParallelism for more information.\r\n\r\nThey process elements from a stream: Aggregate operations process elements from a stream, not directly from a collection. Consequently, they are also called stream operations.\r\n\r\nThey support behavior as parameters: You can specify\r\nlambda expressions as parameters for most aggregate operations. This enables you to customize the behavior of a particular aggregate operation.\r\n\r\n",
        "title": "Oracle_Aggregate Operations.txt",
        "type": "Oracle_"
    }, {
        "rank": 8,
        "text": "\r\n\r\nConsider the problem of writing a routine that prints out all the elements in a collection. Here's how you might write it in an older version of the language (i.e., a pre-5.0 release):\r\n\r\nvoid printCollection(Collection c) {\r\n    Iterator i = c.iterator();\r\n    for (k = 0; k < c.size(); k++) {\r\n        System.out.println(i.next());\r\n    }\r\n}\r\n\r\nAnd here is a naive attempt at writing it using generics (and the new for loop syntax):\r\n\r\nvoid printCollection(Collection<Object> c) {\r\n    for (Object e : c) {\r\n        System.out.println(e);\r\n    }\r\n}\r\n\r\nThe problem is that this new version is much less useful than the old one. Whereas the old code could be called with any kind of collection as a parameter, the new code only takes Collection<Object>, which, as we've just demonstrated, is not a supertype of all kinds of collections!\r\nSo what is the supertype of all kinds of collections? It's written Collection<?> (pronounced \"collection of unknown\"), that is, a collection whose element type matches anything. It's called a wildcard type for obvious reasons. We can write:\r\n\r\nvoid printCollection(Collection<?> c) {\r\n    for (Object e : c) {\r\n        System.out.println(e);\r\n    }\r\n}\r\n\r\nand now, we can call it with any type of collection. Notice that inside printCollection(), we can still read elements from c and give them type Object. This is always safe, since whatever the actual type of the collection, it does contain objects. It isn't safe to add arbitrary objects to it however:\r\n\r\nCollection<?> c = new ArrayList<String>();\r\nc.add(new Object()); // Compile time error\r\n\r\nSince we don't know what the element type of c stands for, we cannot add objects to it. The add() method takes arguments of type E, the element type of the collection. When the actual type parameter is ?, it stands for some unknown type. Any parameter we pass to add would have to be a subtype of this unknown type. Since we don't know what type that is, we cannot pass anything in. The sole exception is null, which is a member of every type.\r\nOn the other hand, given a List<?>, we can call get() and make use of the result. The result type is an unknown type, but we always know that it is an object. It is therefore safe to assign the result of get() to a variable of type Object or pass it as a parameter where the type Object is expected.\r\nBounded Wildcards\r\nConsider a simple drawing application that can draw shapes such as rectangles and circles. To represent these shapes within the program, you could define a class hierarchy such as this:\r\n\r\npublic abstract class Shape {\r\n    public abstract void draw(Canvas c);\r\n}\r\n\r\npublic class Circle extends Shape {\r\n    private int x, y, radius;\r\n    public void draw(Canvas c) {\r\n        ...\r\n    }\r\n}\r\n\r\npublic class Rectangle extends Shape {\r\n    private int x, y, width, height;\r\n    public void draw(Canvas c) {\r\n        ...\r\n    }\r\n}\r\n\r\nThese classes can be drawn on a canvas:\r\n\r\npublic class Canvas {\r\n    public void draw(Shape s) {\r\n        s.draw(this);\r\n   }\r\n}\r\n\r\nAny drawing will typically contain a number of shapes. Assuming that they are represented as a list, it would be convenient to have a method in Canvas that draws them all:\r\n\r\npublic void drawAll(List<Shape> shapes) {\r\n    for (Shape s: shapes) {\r\n        s.draw(this);\r\n   }\r\n}\r\n\r\nNow, the type rules say that drawAll() can only be called on lists of exactly Shape: it cannot, for instance, be called on a List<Circle>. That is unfortunate, since all the method does is read shapes from the list, so it could just as well be called on a List<Circle>. What we really want is for the method to accept a list of any kind of shape:\r\n\r\npublic void drawAll(List<? extends Shape> shapes) {\r\n    ...\r\n}\r\n\r\nThere is a small but very important difference here: we have replaced the type List<Shape> with List<? extends Shape>. Now drawAll() will accept lists of any subclass of Shape, so we can now call it on a List<Circle> if we want.\r\nList<? extends Shape> is an example of a bounded wildcard. The ? stands for an unknown type, just like the wildcards we saw earlier. However, in this case, we know that this unknown type is in fact a subtype of Shape. (Note: It could be Shape itself, or some subclass; it need not literally extend Shape.) We say that Shape is the upper bound of the wildcard.\r\nThere is, as usual, a price to be paid for the flexibility of using wildcards. That price is that it is now illegal to write into shapes in the body of the method. For instance, this is not allowed:\r\n\r\npublic void addRectangle(List<? extends Shape> shapes) {\r\n    // Compile-time error!\r\n    shapes.add(0, new Rectangle());\r\n}\r\n\r\nYou should be able to figure out why the code above is disallowed. The type of the second parameter to shapes.add() is ? extends Shape-- an unknown subtype of Shape. Since we don't know what type it is, we don't know if it is a supertype of Rectangle; it might or might not be such a supertype, so it isn't safe to pass a Rectangle there.\r\nBounded wildcards are just what one needs to handle the example of the DMV passing its data to the census bureau. Our example assumes that the data is represented by mapping from names (represented as strings) to people (represented by reference types such as Person or its subtypes, such as Driver). Map<K,V> is an example of a generic type that takes two type arguments, representing the keys and values of the map.\r\nAgain, note the naming convention for formal type parameters--K for keys and V for values.\r\n\r\npublic class Census {\r\n    public static void addRegistry(Map<String, ? extends Person> registry) {\r\n}\r\n...\r\n\r\nMap<String, Driver> allDrivers = ... ;\r\nCensus.addRegistry(allDrivers);\r\n\r\n",
        "title": "Oracle_Wildcards.txt",
        "type": "Oracle_"
    }, {
        "rank": 9,
        "text": "\r\nIn this trail you'll learn how the built-in Javaâ\u201e¢ security features protect you from malevolent programs. You'll see how to use tools to control access to resources, to generate and to check digital signatures, and to create and to manage keys needed for signature generation and checking. You'll also see how to incorporate cryptography services, such as digital signature generation and checking, into your programs.\r\nThe security features provided by the Java Development Kit (JDKâ\u201e¢) are intended for a variety of audiences:\r\n\r\n\r\nUsers running programs:\r\nBuilt-in security functionality protects you from malevolent programs (including viruses), maintains the privacy of your files and information about you, and authenticates the identity of each code provider. You can subject applications and applets to security controls when you need to.\r\n\r\n\r\nDevelopers:\r\nYou can use API methods to incorporate security functionality into your programs, including cryptography services and security checks. The API framework enables you to define and integrate your own permissions (controlling access to specific resources), cryptography service implementations, security manager implementations, and policy implementations. In addition, classes are provided for management of your public/private key pairs and public key certificates from people you trust.\r\n\r\n\r\nSystems administrators, developers, and users:\r\nJDK tools manage your keystore (database of keys and certificates); generate digital signatures for JAR files, and verify the authenticity of such signatures and the integrity of the signed contents; and create and modify the policy files that define your installation's security policy.\r\n\r\n\r\nNote:Â For developers that want to create applets and Java Web Start applications, see \r\nJava Applets for security information.\r\n\r\nTrail Lessons\r\n\r\n\r\nÂ \r\nCreating a Policy File shows how resource accesses can be controlled by a policy file. For latest information on policy configuration files, see \r\n\r\nPolicy Guide page.\r\n\r\n\r\n\r\nÂ \r\nQuick Tour of Controlling Applications builds on the previous lesson, showing how resource accesses, such as reading or writing a file, are not permitted for applications that are run under a security manager unless explicitly allowed by a permission in a policy file.\r\n\r\nÂ \r\nAPI and Tools Use for Secure Code and File Exchanges defines digital signatures, certificates, and keystores and discusses why they are needed. It also reviews information applicable to the next three lessons regarding the steps commonly needed for using the tools or the API to generate signatures, export/import certificates, and so on.\r\n\r\nÂ \r\nSigning Code and Granting It Permissions illustrates the use of all the security-related tools. It shows the steps that a developer would take to sign and to distribute code for others to run. The lesson also shows how someone who will run the code (or a system administrator) could add an entry in a policy file to grant the code permission for the resource accesses it needs.\r\n\r\nÂ \r\nExchanging Files shows use of the tools by one person to sign an important document, such as a contract, and to export the public key certificate for the public key corresponding to the private key used to sign the contract. Then the lesson shows how another person, who receives the contract, the signature, and the public key certificate, can import the certificate and verify the signature.\r\n\r\n\r\nÂ \r\nGenerating and Verifying Signatures walks you step by step through an example of writing a Java program using the JDK Security API to generate keys, to generate a digital signature for data using the private key, and to export the public key and the signature to files. Then the example shows writing a second program, which may be expected to run on a different person's computer, that imports the public key and verifies the authenticity of the signature. Finally, the example discusses potential weaknesses of the approach used by the basic programs and demonstrates possible alternative approaches and methods of supplying and importing keys, including in certificates.\r\n\r\n\r\nÂ \r\nImplementing Your Own Permission demonstrates how to write a class that defines its own special permission.\r\nFor More Information\r\nJDK security release documentation can be found at the \r\nSecurity guides page. This index page lists Specifications which present detailed information about latest security features, including architecture specifications, usage guides, API documentation, and tool documentation.\r\n",
        "title": "Oracle_Security Features in Java SE.txt",
        "type": "Oracle_"
    }, {
        "rank": 10,
        "text": "\r\n\r\nThe sample program SAXLocalNameCount uses the non-validating parser by default, but it can also activate validation. Activating validation allows the application to tell whether the XML document contains the right tags or whether those tags are in the right sequence. In other words, it can tell you whether the document is valid. If validation is not activated, however, it can only tell whether or not the document is well-formed, as was shown in the previous section when you deleted the closing tag from an XML element. For validation to be possible, the XML document needs to be associated to a DTD or an XML schema. Both options are possible with the SAXLocalNameCount program.\r\n\r\nChoosing the Parser Implementation\r\nIf no other factory class is specified, the default SAXParserFactory class is used. To use a parser from a different manufacturer, you can change the value of the environment variable that points to it. You can do that from the command line:\r\njava -Djavax.xml.parsers.SAXParserFactory=yourFactoryHere [...]\r\nThe factory name you specify must be a fully qualified class name (all package prefixes included). For more information, see the documentation in the newInstance() method of the SAXParserFactory class.\r\n\r\nUsing the Validating Parser\r\nUp until this point, this lesson has concentrated on the non-validating parser. This section examines the validating parser to find out what happens when you use it to parse the sample program.\r\nTwo things must be understood about the validating parser:\r\n\r\n\r\nA schema or DTD is required.\r\n\r\n\r\nBecause the schema or DTD is present, the ContentHandler.ignorableWhitespace() method is invoked whenever possible.\r\n\r\n\r\n\r\nIgnorable White Space\r\nWhen a DTD is present, the parser will no longer call the characters() method on white space that it knows to be irrelevant. From the standpoint of an application that is interested in processing only the XML data, that is a good thing because the application is never bothered with white space that exists purely to make the XML file readable.\r\nOn the other hand, if you are writing an application that filters an XML data file and if you want to output an equally readable version of the file, then that white space would no longer be irrelevant: it would be essential. To get those characters, you would add the ignorableWhitespace method to your application. To process any (generally) ignorable white space that the parser sees, you would need to add something like the following code to implement the ignorableWhitespace event handler.\r\npublic void ignorableWhitespace (char buf[], int start, int length) throws SAXException { emit(\"IGNORABLE\"); }\r\nThis code simply generates a message to let you know that ignorable white space was seen. However, not all parsers are created equal. The SAX specification does not require that this method be invoked. The Java XML implementation does so whenever the DTD makes it possible.\r\n\r\nConfiguring the Factory\r\nThe SAXParserFactory needs to be set up such that it uses a validating parser instead of the default non-validating parser. The following code from the SAXLocalNameCount example's main() method shows how to configure the factory so that it implements the validating parser.\r\n\r\nstatic public void main(String[] args) throws Exception {\r\n\r\n    String filename = null;\r\n    boolean dtdValidate = false;\r\n    boolean xsdValidate = false;\r\n    String schemaSource = null;\r\n\r\n    for (int i = 0; i < args.length; i++) {\r\n\r\n        if (args[i].equals(\"-dtd\")) {\r\n            dtdValidate = true;\r\n        }\r\n        else if (args[i].equals(\"-xsd\")) {\r\n            xsdValidate = true;\r\n        } \r\n        else if (args[i].equals(\"-xsdss\")) {\r\n            if (i == args.length - 1) {\r\n               usage();\r\n            }\r\n            xsdValidate = true;\r\n            schemaSource = args[++i];\r\n        } \r\n        else if (args[i].equals(\"-usage\")) {\r\n            usage();\r\n        }\r\n        else if (args[i].equals(\"-help\")) {\r\n            usage();\r\n        }\r\n        else {\r\n            filename = args[i];\r\n            if (i != args.length - 1) {\r\n                usage();\r\n            }\r\n        }\r\n    }\r\n\r\n    if (filename == null) {\r\n        usage();\r\n    }\r\n\r\n    SAXParserFactory spf = SAXParserFactory.newInstance();\r\n    spf.setNamespaceAware(true);\r\n    spf.setValidating(dtdValidate || xsdValidate);\r\n    SAXParser saxParser = spf.newSAXParser();\r\n\r\n    // ... \r\n}\r\n\r\nHere, the SAXLocalNameCount program is configured to take additional arguments when it is started, which tell it to implement no validation, DTD validation, XML Schema Definition (XSD) validation, or XSD validation against a specific schema source file. (Descriptions of these options, -dtd, -xsd, and -xsdss are also added to the usage() method, but are not shown here.) Then, the factory is configured so that it will produce the appropriate validating parser when newSAXParser is invoked. As seen in \r\nSetting up the Parser, you can also use setNamespaceAware(true) to configure the factory to return a namespace-aware parser. Sun's implementation supports any combination of configuration options. (If a combination is not supported by a particular implementation, it is required to generate a factory configuration error).\r\n\r\nValidating with XML Schema\r\nAlthough a full treatment of XML Schema is beyond the scope of this tutorial, this section shows you the steps you take to validate an XML document using an existing schema written in the XML Schema language. To learn more about XML Schema, you can review the online tutorial, XML Schema Part 0: Primer, at \r\nhttp://www.w3.org/TR/xmlschema-0/.\r\n\r\nNote - There are multiple schema-definition languages, including RELAX NG, Schematron, and the W3C \"XML Schema\" standard. (Even a DTD qualifies as a \"schema,\" although it is the only one that does not use XML syntax to describe schema constraints.) However, \"XML Schema\" presents us with a terminology challenge. Although the phrase \"XML Schema schema\" would be precise, we will use the phrase \"XML Schema definition\" to avoid the appearance of redundancy.\r\n\r\nTo be notified of validation errors in an XML document, the parser factory must be configured to create a validating parser, as shown in the preceding section. In addition, the following must be true:\r\n\r\n\r\nThe appropriate properties must be set on the SAX parser.\r\n\r\n\r\nThe appropriate error handler must be set.\r\n\r\n\r\nThe document must be associated with a schema.\r\n\r\n\r\n\r\nSetting the SAX Parser Properties\r\nIt is helpful to start by defining the constants you will use when setting the properties. The SAXLocalNameCount example sets the following constants.\r\n\r\npublic class SAXLocalNameCount extends DefaultHandler {\r\n\r\n    static final String JAXP_SCHEMA_LANGUAGE =\r\n        \"http://java.sun.com/xml/jaxp/properties/schemaLanguage\";\r\n    \r\n    static final String W3C_XML_SCHEMA =\r\n        \"http://www.w3.org/2001/XMLSchema\";\r\n\r\n    static final String JAXP_SCHEMA_SOURCE =\r\n        \"http://java.sun.com/xml/jaxp/properties/schemaSource\";\r\n}\r\n\r\n\r\nNote - The parser factory must be configured to generate a parser that is namespace-aware as well as validating. This was shown in Configuring the Factory. More information about namespaces is provided in \r\nDocument Object Model but for now, understand that schema validation is a namespace-oriented process. Because JAXP-compliant parsers are not namespace-aware by default, it is necessary to set the property for schema validation to work.\r\n\r\nThen you must configure the parser to tell it which schema language to use. In SAXLocalNameCount, validation can be performed either against a DTD or against an XML Schema. The following code uses the constants defined above to specify the W3C's XML Schema language as the one to use if the -xsd option is specified when the program is started.\r\n\r\n// ...\r\nif (xsdValidate) {\r\n    saxParser.setProperty(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);\r\n    // ...\r\n}\r\n\r\nIn addition to the error handling described in \r\nSetting up Error Handling, there is one error that can occur when configuring the parser for schema-based validation. If the parser is not compliant with the JAXP spec, and therefore does not support XML Schema, it can throw a SAXNotRecognizedException. To handle that case, the setProperty() statement is wrapped in a try/catch block, as shown in the code below.\r\n\r\n// ...\r\nif (xsdValidate) {\r\n    try {\r\n        saxParser.setProperty(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);\r\n    }\r\n    catch (SAXNotRecognizedException x){\r\n        System.err.println(\"Error: JAXP SAXParser property not recognized: \"\r\n                           + JAXP_SCHEMA_LANGUAGE);\r\n\r\n        System.err.println( \"Check to see if parser conforms to the JAXP spec.\");\r\n        System.exit(1);\r\n    }\r\n}\r\n// ...\r\n\r\n\r\nAssociating a Document with a Schema\r\nTo validate the data using an XML Schema definition, it is necessary to ensure that the XML document is associated with one. There are two ways to do that.\r\n\r\nBy including a schema declaration in the XML document.\r\nBy specifying the schema to use in the application.\r\n\r\n\r\nNote - When the application specifies the schema to use, it overrides any schema declaration in the document.\r\n\r\nTo specify the schema definition in the document, you would create XML such as this:\r\n\r\n<documentRoot\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:noNamespaceSchemaLocation='YourSchemaDefinition.xsd'>\r\n\r\nThe first attribute defines the XML namespace (xmlns) prefix, xsi, which stands for XML Schema instance. The second line specifies the schema to use for elements in the document that do not have a namespace prefix, namely for the elements that are typically defined in any simple, uncomplicated XML document.\r\n\r\nNote - More information about namespaces is included in Validating with XML Schema in \r\nDocument Object Model. For now, think of these attributes as the \"magic incantation\" you use to validate a simple XML file that does not use them. After you have learned more about namespaces, you will see how to use XML Schema to validate complex documents that do use them. Those ideas are discussed in Validating with Multiple Namespaces in \r\nDocument Object Model.\r\n\r\nYou can also specify the schema file in the application, as is the case in SAXLocalNameCount.\r\n\r\n// ...\r\nif (schemaSource != null) {\r\n    saxParser.setProperty(JAXP_SCHEMA_SOURCE, new File(schemaSource));\r\n}\r\n\r\n// ...\r\n\r\nIn the code above, the variable schemaSource relates to a schema source file that you can point the SAXLocalNameCount application to by starting it with the -xsdss option and providing the name of the schema source file to be used.\r\n\r\nError Handling in the Validating Parser\r\nIt is important to recognize that the only reason an exception is thrown when a file fails validation is as a result of the error-handling code shown in \r\nSetting up Error Handling. That code is reproduced here as a reminder:\r\n\r\n// ...\r\n\r\npublic void warning(SAXParseException spe) throws SAXException {\r\n    out.println(\"Warning: \" + getParseExceptionInfo(spe));\r\n}\r\n        \r\npublic void error(SAXParseException spe) throws SAXException {\r\n    String message = \"Error: \" + getParseExceptionInfo(spe);\r\n    throw new SAXException(message);\r\n}\r\n\r\npublic void fatalError(SAXParseException spe) throws SAXException {\r\n    String message = \"Fatal Error: \" + getParseExceptionInfo(spe);\r\n    throw new SAXException(message);\r\n}\r\n\r\n// ...\r\n\r\nIf these exceptions are not thrown, the validation errors are simply ignored. In general, a SAX parsing error is a validation error, although it can also be generated if the file specifies a version of XML that the parser is not prepared to handle. Remember that your application will not generate a validation exception unless you supply an error handler such as the one here.\r\n\r\nDTD Warnings\r\nAs mentioned earlier, warnings are generated only when the SAX parser is processing a DTD. Some warnings are generated only by the validating parser. The non-validating parser's main goal is to operate as rapidly as possible, but it too generates some warnings.\r\nThe XML specification suggests that warnings should be generated as a result of the following:\r\n\r\n\r\nProviding additional declarations for entities, attributes, or notations. (Such declarations are ignored. Only the first is used. Also, note that duplicate definitions of elements always produce a fatal error when validating, as you saw earlier.)\r\n\r\n\r\nReferencing an undeclared element type. (A validity error occurs only if the undeclared type is actually used in the XML document. A warning results when the undeclared element is referenced in the DTD.)\r\n\r\n\r\nDeclaring attributes for undeclared element types.\r\n\r\n\r\nThe Java XML SAX parser also emits warnings in other cases:\r\n\r\n\r\nNo <!DOCTYPE ...> when validating.\r\n\r\n\r\nReferences to an undefined parameter entity when not validating. (When validating, an error results. Although nonvalidating parsers are not required to read parameter entities, the Java XML parser does so. Because it is not a requirement, the Java XML parser generates a warning, rather than an error.)\r\n\r\n\r\nCertain cases where the character-encoding declaration does not look right.\r\n\r\n\r\n\r\nRunning the SAX Parser Examples with Validation\r\nIn this section, the SAXLocalNameCount sample program used previously will be used again, except this time it will be run with validation against an XML Schema or a DTD. The best way to demonstrate the different types of validation is to modify the code of the XML file being parsed, as well as the associated schema and DTDs, to break the processing and get the application to generate exceptions.\r\n\r\nExperimenting with DTD Validation Errors\r\nAs stated above, these examples reuse the SAXLocalNameCount program. The locations where you will find the sample and its associated files are given in \r\nRunning the SAX Parser Example without Validation.\r\n\r\nIf you have not already done so, navigate to the samples directory. % cd install-dir/jaxp-1_4_2-release-date/samples\r\nIf you have not already done so, compile the example class.% javac sax/*\r\nOpen the file data/rich_iii.xml in a text editor.\r\nThis is the same XML file that was processed without validation in \r\nTo Run the SAXLocalNameCount Example without Validation. At the beginning of data/rich_iii.xml, you will see that the DOCTYPE declaration points a validating parser to a DTD file called play.dtd. If DTD validation is activated, the structure of the XML file being parsed will be checked against the structure provided in play.dtd.\r\n\r\nDelete the declaration <!DOCTYPE PLAY SYSTEM \"play.dtd\"> from the beginning of the file.\r\nDo not forget to save the modification, but leave the file open, as it will be needed again later.\r\n\r\nRun the SAXLocalNameCount program, with DTD validation activated.\r\nTo do this, you must specify the -dtd option when you run the program.\r\n% java sax/SAXLocalNameCount -dtd data/rich_iii.xml\r\nThe result you see will look something like this:\r\n\r\nException in thread \"main\" org.xml.sax.SAXException:\r\nError: URI=file:install-dir/JAXP_sources/jaxp-1_4_2-release-date\r\n/samples/data/rich_iii.xml \r\nLine=12: Document is invalid: no grammar found.\r\n\r\n\r\nNote - This message was generated by the JAXP 1.4.2 libraries. If you are using a different parser, the error message is likely to be somewhat different.\r\n\r\nThis message says that there is no grammar against which the document rich_iii.txt can be validated, so therefore it is automatically invalid. In other words, the message is saying that you are trying to validate the document, but no DTD has been declared, because no DOCTYPE declaration is present. So now you know that a DTD is a requirement for a valid document. That makes sense.\r\n\r\nRestore the <!DOCTYPE PLAY SYSTEM \"play.dtd\"> declaration to data/rich_iii.xml.\r\nAgain, do not forget to save the file, but leave it open.\r\n\r\nReturn to data/rich_iii.xml and modify the tags for the character \"KING EDWARD The Fourth\" in line 26.\r\nChange the start and end tags from <PERSONA> and <\/PERSONA> to <PERSON> and <\/PERSON>. Line 26 should now look like this:\r\n26:<PERSON>KING EDWARD The Fourth<\/PERSON>\r\nAgain, do not forget to save the modification, and leave the file open.\r\n\r\nRun the SAXLocalNameCount program, with DTD validation activated.\r\nThis time, you will see a different error when you run the program:\r\n\r\n% java sax/SAXLocalNameCount -dtd data/rich_iii.xml\r\nException in thread \"main\" org.xml.sax.SAXException: \r\nError: URI=file:install-dir/JAXP_sources/jaxp-1_4_2-release-date\r\n/samples/data/rich_iii.xml \r\nLine=26: Element type \"PERSON\" must be declared.\r\n\r\nHere you can see that the parser has objected to an element that is not included in the DTD data/play.dtd.\r\n\r\nIn data/rich_iii.xml correct the tags for \"KING EDWARD The Fourth\".\r\nReturn the start and end tags to their original versions, <PERSONA> and <\/PERSONA>.\r\n\r\nIn data/rich_iii.xml, delete <TITLE>Dramatis Personae<\/TITLE> from line 24.\r\nOnce more, do not forget to save the modification.\r\n\r\nRun the SAXLocalNameCount program, with DTD validation activated.\r\nAs before, you will see another validation error:\r\n\r\njava sax/SAXLocalNameCount -dtd data/rich_iii.xml\r\nException in thread \"main\" org.xml.sax.SAXException: \r\nError: URI=file:install-dir/JAXP_sources/jaxp-1_4_2-release-date\r\n/samples/data/rich_iii.xml \r\nLine=85: The content of element type \"PERSONAE\" must match \"(TITLE,(PERSONA|PGROUP)+)\".\r\n\r\nBy deleting the <TITLE> element from line 24, the <PERSONAE> element is rendered invalid because it does not contain the sub-elements that the DTD expects of a <PERSONAE> element. Note that the error message states that the error is in line 85 of data/rich_iii.xml, even though you deleted the <TITLE> element from line 24. This is because the closing tag of the <PERSONAE> element is located at line 85 and the parser only throws the exception when it reaches the end of the element it parsing.\r\n\r\nOpen the DTD file, data/play.dtd in a text editor.\r\nIn the DTD file, you can see the declaration of the <PERSONAE> element, as well as all the other elements that can be used in XML documents that conform to the play DTD. The declaration of <PERSONAE> looks like this.\r\n\r\n<!ELEMENT PERSONAE (TITLE, (PERSONA | PGROUP)+)>\r\n\r\nAs you can see, the <PERSONAE> element requires a <TITLE> sub-element. The pipe (|) key means that either <PERSONA> or <PGROUP> sub-elements can be included in a <PERSONAE> element, and the plus (+) key after the (PERSONA | PGROUP) grouping means that at least one or more of either of these sub-elements must be included.\r\n\r\nAdd a question mark (?) key after TITLE in the declaration of <PERSONAE>.\r\nAdding a question mark to a sub-element's declaration in a DTD makes the presence of one instance of that sub-element optional.\r\n\r\n<!ELEMENT PERSONAE (TITLE?, (PERSONA | PGROUP)+)>\r\n\r\nIf you were add an asterisk (*) after the element, you could include either zero or multiple instances of that sub-element. However, in this case it does not make sense to have more than one title in a section of a document.\r\nDo not forget to save the modification you have made to data/play.dtd.\r\n\r\nRun the SAXLocalNameCount program, with DTD validation activated.% java sax/SAXLocalNameCount -dtd data/rich_iii.xml\r\nThis time, you should see the proper output of SAXLocalNameCount, with no errors.\r\n\r\n\r\n\r\nExperimenting with Schema Validation Errors\r\nThe previous exercise demonstrated using SAXLocalNameCount to validate an XML file against a DTD. In this exercise you will use SAXLocalNameCount to validate a different XML file against both the standard XML Schema definition and a custom schema source file. Again, this type of validation will be demonstrated by breaking the parsing process by modifying the XML file and the schema, so that the parser throws errors.\r\nAs stated above, these examples reuse the SAXLocalNameCount program. The locations where you will find the sample and its associated files are given in \r\nRunning the SAX Parser Example without Validation.\r\n\r\nIf you have not already done so, navigate to the samples directory.% cd install-dir/jaxp-1_4_2-release-date/samples\r\nIf you have not already done so, compile the example class.% javac sax/*\r\nOpen the file data/personal-schema.xml in a text editor.\r\nThis is a simple XML file that provides the names and contact details for the employees of a small company. In this XML file, you will see that it has been associated with a schema definition file personal.xsd.\r\n<personnel xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation='personal.xsd'>\r\nOpen the file data/personal.xsd in a text editor.\r\nThis schema defines what kinds of information are required about each employee in order for an XML document associated with the schema to be considered valid. For example, by examining the schema definition, you can see that each person element requires a name, and that each person's name must comprise a family name and a given name. Employees can also optionally have email addresses and URLs.\r\n\r\nIn data/personal.xsd, change the minimum number of email addresses required for a person element from 0 to 1.\r\nThe declaration of the email element is now as follows.\r\n<xs:element ref=\"email\" minOccurs='1' maxOccurs='unbounded'/>\r\nIn data/personal-schema.xml, delete the email element from the person element one.worker.\r\nWorker One now looks like this:\r\n\r\n<person id=\"one.worker\">\r\n  <name><family>Worker<\/family> <given>One<\/given><\/name>\r\n  <link manager=\"Big.Boss\"/>\r\n<\/person>\r\n\r\n\r\nRun SAXLocalNameCount against personal-schema.xml, with no schema validation.% java sax/SAXLocalNameCount data/personal-schema.xml\r\nSAXLocalNameCount informs you of the number of times each element occurs in personal-schema.xml.\r\n\r\nLocal Name \"email\" occurs 5 times\r\nLocal Name \"name\" occurs 6 times\r\nLocal Name \"person\" occurs 6 times\r\nLocal Name \"family\" occurs 6 times\r\nLocal Name \"link\" occurs 6 times\r\nLocal Name \"personnel\" occurs 1 times\r\nLocal Name \"given\" occurs 6 times\r\n\r\nYou see that email only occurs five times, whereas there are six person elements in personal-schema.xml. So, because we set the minimum occurrences of the email element to 1 per person element, we know that this document is invalid. However, because SAXLocalNameCount was not told to validate against a schema, no error is reported.\r\n\r\nRun SAXLocalNameCount again, this time specifying that the personalâ\u20ac\u201dschema.xml document should be validated against a the personal.xsd schema definition.\r\nAs you saw in Validating with XML Schema above, SAXLocalNameCount has an option to enable schema validation. Run SAXLocalNameCount with the following command.\r\n% java sax/SAXLocalNameCount -xsd data/personal-schema.xml\r\nThis time, you will see the following error message.\r\n\r\nException in thread \"main\" org.xml.sax.SAXException: Error: \r\nURI=file:install_dir/samples/data/personal-schema.xml \r\nLine=19: cvc-complex-type.2.4.a: Invalid content was found starting with \r\nelement 'link'. \r\nOne of '{email}' is expected.\r\n\r\n\r\nRestore the email element to the person element one.worker.\r\nRun SAXLocalNameCount a third time, again specifying that the personalâ\u20ac\u201dschema.xml document should be validated against a the personal.xsd schema definition.% java sax/SAXLocalNameCount -xsd data/personal-schema.xml\r\nThis time you will see the correct output, with no errors.\r\n\r\nOpen personal-schema.xml in a text editor again.\r\nDelete the declaration of the schema definition personal.xsd from the personnel element.\r\nRemove the italicized code from the personnel element.\r\n<personnel xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation='personal.xsd'/>\r\nRun SAXLocalNameCount, again specifying schema validation.% java sax/SAXLocalNameCount -xsd data/personal-schema.xml\r\nObviously, this will not work, as the schema definition against which to validate the XML file has not been declared. You will see the following error.\r\n\r\nException in thread \"main\" org.xml.sax.SAXException: \r\nError: URI=file:install_dir/samples/data/personal-schema.xml \r\nLine=8: cvc-elt.1: Cannot find the declaration of element 'personnel'.\r\n\r\n\r\nRun SAXLocalNameCount again, this time passing it the schema definition file at the command line.% java sax/SAXLocalNameCount -xsdss data/personal.xsd data/personal-schema.xml\r\nThis time you use the SAXLocalNameCount option that allows you to specify a schema definition that is not hard-coded into the application. You should see the correct output.\r\n\r\n\r\n",
        "title": "Oracle_Implementing SAX Validation.txt",
        "type": "Oracle_"
    }]
}

post4_rec = {
    "response": [{
        "rank": 1,
        "text": "\r\nProgramming is essentially thinking of solutions to problems in real life as a system. With any programming language, you need to know how to address real-life problems into something that could be accurately represented within a computer system. In order to begin programming with the Java programming language (or in fact, with any programming language), a programmer must first understand the basics of abstraction.\r\nAbstractionis the process ofrepresentingreal-life problems and objects into your programs.\r\nSuppose a novelist, a painter and a programmer were asked toabstract(i.e.,represent) a real-life object in their work. Suppose, the real-life object that needs to be abstracted isan animal. Abstraction for a novelist would include writing the description of the animal whilst the painter would draw a picture of the animal â\u20ac\u201c but what about a computer programmer?\r\nThe Java programming language uses a programming paradigm calledobject-oriented programming (OOP), which shows you exactly what a programmer needs to be doing. According to OOP, every object or problem in real-life can be translated into a virtual object within your computer system.\r\n\r\nThinking in objects[edit]\r\n\r\nIn OOP, every abstraction of a real-life object is simply called anobjectwithin your code. An object is essentially the most basic representation of a real-life object as part of a computer system. With Java being an object-oriented language, everything within Java is represented as an object. To demonstrate this effect, if you were to define an abstraction of an animal in your code, you would write the following lines of code (as you would for any other abstraction):\r\n\r\n\r\n\r\nThe code above creates a space within your code where you can startdefiningan object; this space is called aclass (ortype) definition. All objects need to be defined using a class definition in order for them to be used in your program. Notice the curly brackets â\u20ac\u201c anything you write within these brackets would serve as a definition or specification for your object. In the case of the example above, we created a class definition calledAnimalfor objects that could serve as an abstract representation of any animal in real-life. The way that a Java environment evaluates this code to be a class definition is by looking at the prefix word we used to begin our class definition (i.e.,class). Such predefined words in the Java language are known askeywordsand make up the grammar for the language (known asprogramming syntax).\r\n\r\nNote:Class definitions have different names in different languages. They are sometimes calledtype definitions,object specificationsortemplatesas well\r\n\r\nUnderstanding class definitions and types[edit]\r\n\r\nAristotlewas perhaps the first person to think of abstract types or typologies of objects. He started calling them classes â\u20ac\u201c e.g., classes of birds, classes of mammals. Class definitions therefore serve the purpose well in defining the common characteristics or types of objects you would be creating. Upon declaring a class definition, you can create objects based on that definition. In order to do so however, you need to write a special syntax that goes like this:\r\n\r\n\r\nThe code above effectively creates an object calleddogbased on the class definition forAnimal. In non-programmer parlance, the code above would translate into something akin to saying, \"Create a new objectdogof typeAnimal.\" A single class definition enables you to create multiple objects as the code below indicates:\r\n\r\n\r\nBasically, you just have to write the code for your class or type definition once, and then use it to create countless numbers of objects based on that specification. Although you might not grasp the importance of doing so, this little exercise saves you a lot of time (a luxury that was not readily available to programmers in the pre-Java days).\r\n\r\nExpanding your class definitions[edit]\r\n\r\nAlthough each object you create from a class definition is essentially the same, there has to be a way of differentiating those objects in your code. Object fields (or simplyfields) are what makes your objects unique from other objects. Let's take our present abstraction for instance. An animal could be a dog, cat, camel or a duck but since this abstraction is of a very generic kind, you need to define fields that are common to all of these animals and yet makes the animals stand apart. For instance, you can have two fields:name(a common name given to any one of these animals) andlegs(the number of limbs any one of these animals would require to walk). As you start defining your objects, they start to look like this:\r\n\r\n\r\n\r\nIn the code above you defined two object fields:\r\n\r\na field callednameof typeString; and,a field calledlegsof typeint.\r\n\r\nThese special pre-defined types are calleddata types. TheStringdata type is used for fields that can holdtextualvalues like names, while theint(integer) data type is used for fields that can holdnumericvalues\r\n\r\nNote:Fields are called different things in different languages. They may be calledstate identifiers,propertiesormember variablesin other programming language syntax. Java uses the wordsfieldsandpropertiesin different contexts, as would be understood from upcoming sections.\r\n\r\nFigure 3:In order to denote theAnimalobject as a system within the Java Environment,you present it as such. Note how fields are presented.\r\n\r\nIn order to demonstrate how fields work, we will go ahead and create objects from this amended version of our class definition as such:\r\n\r\n\r\nYou can access the fields of your created objects by using the.(dot) ormembership operator. In the example above, we created two objects:animal1andanimal2of typeAnimal. And since, we had established that eachAnimalhas two fields namelynameandlegs, we accessed and modified these fields for each of our objects using the membership operator to set the two apart. By declaring different values for different objects, we can manipulate their currentstate. So, for instance:\r\n\r\ntheanimal1object is a\"dog\"with4legs to walk with; while,theanimal2object is a\"duck\"with2legs to walk with.\r\n\r\nWhat sets the two objects apart is their current state. Both the objects have different states and thus stand out as two different objects even though they were created from the same template or class definition.\r\n\r\nAdding behavior to objects[edit]\r\n\r\nAt this point, your objects do nothing more than declare a bunch of fields. Being a system, your objects should have the ability to interact with its environment and other systems as well. To add this capability for interaction, you need to add interactive behavior to your object class definitions as well. Such behavior is added to class definitions using a programming construct calledmethod.\r\nIn the case of theAnimal, you require your virtual representation of an animal to be able to move through its environment. Let's say, as an analogy, you want yourAnimalobject to be able to walk in its environment. Thus, you need to add a method namedwalkto our object. To do so, we need to write the following code:\r\n\r\n\r\n\r\nAs you write this code, one thing becomes immediately apparent. Just like the class description, a method has curly brackets as well. Generally, curly brackets are used to define an area (orscope) within your object. So the first set of curly brackets defined a scope for your class definition called theclass-level scope. This new set of curly brackets alongside a method defines a scope for the further definition of your method called themethod-level scope.\r\nIn this instance, the name of our method iswalk. Notice however that the name of our method also features a set of round brackets as well. More than just being visual identifiers for methods, these round brackets are used to provide our methods with additional input information calledarguments.\r\nA method therefore enables an object to:\r\n\r\nAccept input: Receive some argument(s);Process information: work on the received argument(s) within its curly brackets; and,Generate ouput:occasionally, return something back.\r\n\r\nIn essence, methods are what makes an object behave more like a system.\r\nNotice the keywordvoidbefore the name of the method â\u20ac\u201c this tells us that the methodwalkreturnsnothing. You can set a method to return any data type â\u20ac\u201c it can be aStringor anintas well.\r\n\r\nNote:Methods are known by different names in different programming language. They might be calledfunctions,procedures,routinesorbehaviors.\r\n\r\nFigure 4:TheAnimalobject can now be denoted as having an interaction behavior within the Java Environmentas illustrated here. Note the difference between the presentation of fields and methods.\r\n\r\n\r\n\r\n",
        "title": "Getting started_The process of abstraction_text.txt",
        "type": "text"
    }, {
        "rank": 2,
        "text": "\r\n\r\nTo use Java generics effectively, you must consider the following restrictions:\r\n\r\n\r\nCannot Instantiate Generic Types with Primitive Types\r\n\r\nCannot Create Instances of Type Parameters\r\n\r\nCannot Declare Static Fields Whose Types are Type Parameters\r\n\r\nCannot Use Casts or instanceof With Parameterized Types\r\n\r\nCannot Create Arrays of Parameterized Types\r\n\r\nCannot Create, Catch, or Throw Objects of Parameterized Types\r\n\r\nCannot Overload a Method Where the Formal Parameter Types of Each Overload Erase to the Same Raw Type\r\n\r\nCannot Instantiate Generic Types with Primitive Types\r\n\r\nConsider the following parameterized type:\r\n\r\nclass Pair<K, V> {\r\n\r\n    private K key;\r\n    private V value;\r\n\r\n    public Pair(K key, V value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n\r\n    // ...\r\n}\r\n\r\n\r\nWhen creating a Pair object, you cannot substitute a primitive type for the type parameter K or V:\r\n\r\nPair<int, char> p = new Pair<>(8, 'a');  // compile-time error\r\n\r\n\r\nYou can substitute only non-primitive types for the type parameters K and V:\r\n\r\nPair<Integer, Character> p = new Pair<>(8, 'a');\r\n\r\n\r\nNote that the Java compiler autoboxes 8 to Integer.valueOf(8) and 'a' to Character('a'):\r\n\r\nPair<Integer, Character> p = new Pair<>(Integer.valueOf(8), new Character('a'));\r\n\r\nFor more information on autoboxing, see\r\nAutoboxing and Unboxing in the\r\nNumbers and Strings lesson.\r\nCannot Create Instances of Type Parameters\r\n\r\nYou cannot create an instance of a type parameter. For example, the following code causes a compile-time error:\r\n\r\npublic static <E> void append(List<E> list) {\r\n    E elem = new E();  // compile-time error\r\n    list.add(elem);\r\n}\r\n\r\n\r\nAs a workaround, you can create an object of a type parameter through reflection:\r\n\r\npublic static <E> void append(List<E> list, Class<E> cls) throws Exception {\r\n    E elem = cls.newInstance();   // OK\r\n    list.add(elem);\r\n}\r\n\r\n\r\nYou can invoke the append method as follows:\r\n\r\nList<String> ls = new ArrayList<>();\r\nappend(ls, String.class);\r\n\r\nCannot Declare Static Fields Whose Types are Type Parameters\r\n\r\nA class's static field is a class-level variable shared by all non-static objects of the class.  Hence, static fields of type parameters are not allowed. Consider the following class:\r\n\r\npublic class MobileDevice<T> {\r\n    private static T os;\r\n\r\n    // ...\r\n}\r\n\r\n\r\nIf static fields of type parameters were allowed, then the following code would be confused:\r\n\r\nMobileDevice<Smartphone> phone = new MobileDevice<>();\r\nMobileDevice<Pager> pager = new MobileDevice<>();\r\nMobileDevice<TabletPC> pc = new MobileDevice<>();\r\n\r\n\r\nBecause the static field os is shared by phone, pager, and pc, what is the actual type of os? It cannot be Smartphone, Pager, and TabletPC at the same time. You cannot, therefore, create static fields of type parameters.\r\nCannot Use Casts or instanceof with Parameterized Types\r\n\r\nBecause the Java compiler erases all type parameters in generic code, you cannot verify which parameterized type for a generic type is being used at runtime:\r\n\r\npublic static <E> void rtti(List<E> list) {\r\n    if (list instanceof ArrayList<Integer>) {  // compile-time error\r\n        // ...\r\n    }\r\n}\r\n\r\n\r\nThe set of parameterized types passed to the rtti method is:\r\n\r\nS = { ArrayList<Integer>, ArrayList<String> LinkedList<Character>, ... }\r\n\r\n\r\nThe runtime does not keep track of type parameters, so it cannot tell the difference between an ArrayList<Integer> and an ArrayList<String>. The most you can do is to use an unbounded wildcard to verify that the list is an ArrayList:\r\n\r\npublic static void rtti(List<?> list) {\r\n    if (list instanceof ArrayList<?>) {  // OK; instanceof requires a reifiable type\r\n        // ...\r\n    }\r\n}\r\n\r\n\r\nTypically, you cannot cast to a parameterized type unless it is parameterized by unbounded wildcards. For example:\r\n\r\nList<Integer> li = new ArrayList<>();\r\nList<Number>  ln = (List<Number>) li;  // compile-time error\r\n\r\n\r\nHowever, in some cases the compiler knows that a type parameter is always valid and allows the cast.  For example:\r\n\r\nList<String> l1 = ...;\r\nArrayList<String> l2 = (ArrayList<String>)l1;  // OK\r\n\r\nCannot Create Arrays of Parameterized Types\r\n\r\nYou cannot create arrays of parameterized types. For example, the following code does not compile:\r\n\r\nList<Integer>[] arrayOfLists = new List<Integer>[2];  // compile-time error\r\n\r\n\r\nThe following code illustrates what happens when different types are inserted into an array:\r\n\r\nObject[] strings = new String[2];\r\nstrings[0] = \"hi\";   // OK\r\nstrings[1] = 100;    // An ArrayStoreException is thrown.\r\n\r\n\r\nIf you try the same thing with a generic list, there would be a problem:\r\n\r\nObject[] stringLists = new List<String>[];  // compiler error, but pretend it's allowed\r\nstringLists[0] = new ArrayList<String>();   // OK\r\nstringLists[1] = new ArrayList<Integer>();  // An ArrayStoreException should be thrown,\r\n                                            // but the runtime can't detect it.\r\n\r\n\r\nIf arrays of parameterized lists were allowed, the previous code would fail to throw the desired ArrayStoreException.\r\nCannot Create, Catch, or Throw Objects of Parameterized Types\r\n\r\nA generic class cannot extend the Throwable class directly or indirectly.  For example, the following classes will not compile:\r\n\r\n// Extends Throwable indirectly\r\nclass MathException<T> extends Exception { /* ... */ }    // compile-time error\r\n\r\n// Extends Throwable directly\r\nclass QueueFullException<T> extends Throwable { /* ... */ // compile-time error\r\n\r\n\r\nA method cannot catch an instance of a type parameter:\r\n\r\npublic static <T extends Exception, J> void execute(List<J> jobs) {\r\n    try {\r\n        for (J job : jobs)\r\n            // ...\r\n    } catch (T e) {   // compile-time error\r\n        // ...\r\n    }\r\n}\r\n\r\n\r\nYou can, however, use a type parameter in a throws clause:\r\n\r\nclass Parser<T extends Exception> {\r\n    public void parse(File file) throws T {     // OK\r\n        // ...\r\n    }\r\n}\r\n\r\nCannot Overload a Method Where the Formal Parameter Types of Each Overload Erase to the Same Raw Type\r\n\r\nA class cannot have two overloaded methods that will have the same signature after type erasure.\r\n\r\npublic class Example {\r\n    public void print(Set<String> strSet) { }\r\n    public void print(Set<Integer> intSet) { }\r\n}\r\n\r\n\r\nThe overloads would all share the same classfile representation and will generate a compile-time error.\r\n",
        "title": "Oracle_Restrictions on Generics.txt",
        "type": "Oracle_"
    }, {
        "rank": 3,
        "text": "\r\nAs we have seen above, generics give the impression that a new container type is created with each different type parameter. We have also seen that in addition to the normal type checking, the type parameter has to match as well when we assign generics variables.\r\nIn some cases this is too restrictive.  What if we would like to relax this additional checking? What if we would like to define a collection variable that can hold any generic collection, regardless of the parameter type it holds?\r\nThe wildcard type is represented by the character<?>, and pronouncedUnknown, orAny-Type. Any-Type can be expressed also by<? extends Object>. Any-Type includes Interfaces, not only Classes.\r\nSo now we can define a collection whose element type matches anything. See below:\r\n\r\n\r\nUpper bounded wildcards[edit]\r\n\r\nYou can specify a restriction on the types of classes that may be used. For example,<? extends ClassName>only allows objects of classClassNameor a subclass.\r\nFor example, to create a collection that may only contain \"Serializable\" objects, specify:\r\n\r\n\r\nThe above code is valid because theStringclass is serializable. Use of a class that is not serializable would cause a compilation error. The added items can be retrieved asSerializableobject. You can call methods of theSerializableinterface or cast it toString. The following collection can only contain objects that extend the classAnimal.\r\n\r\n\r\n\r\nLower bounded wildcards[edit]\r\n\r\n<? super ClassName>specifies a restriction on the types of classes that may be used.\r\nFor example, to declare a Comparator that can compare Dogs, you use:\r\n\r\n\r\nNow suppose you define a comparator that can compare Animals:\r\n\r\n\r\nSinceDogsareAnimals, you can use this comparator to compare Dogs also. Comparators for any superclass of Dog can also compare Dog; but comparators for any strict subclass cannot.\r\n\r\n\r\nThe above code is valid because theAnimalclass is a supertype of theDogclass. Use of a class that is not a supertype would cause a compilation error.\r\n\r\nUnbounded wildcard[edit]\r\n\r\nThe advantage of the unbounded wildcard (i.e.<?>) compared to a raw type (i.e. without generic) is to explicitly say that the parameterized type is unknown, notany type. That way, all the operations that implies to know the type are forbidden to avoid unsafe operation. Consider the following code:\r\n\r\n\r\nThis code will compile but this code may corrupt the collection if the collection only contains strings:\r\n\r\n\r\nThis situation could have been avoided if theaddAtBottom(Collection)method was defined with an unbounded wildcard:addAtBottom(Collection<?>). With this signature, it is impossible to compile a code that is dependent of the parameterized type. Only independent methods of a collection (clear(),isEmpty(),iterator(),remove(Object o),size(), ...) can be called. For instance,addAtBottom(Collection<?>)could contain the following code:\r\n\r\n\r\n",
        "title": "Generics_Wildcard Types_text.txt",
        "type": "text"
    }, {
        "rank": 4,
        "text": "\r\nA JDBC RowSet object holds tabular data in a way that makes it more flexible and easier to use than a result set.\r\nOracle has defined five RowSet interfaces for some of the more popular uses of a RowSet, and standard reference are available for these RowSet interfaces. In this tutorial you will learn how to use these reference implementations.\r\nThese versions of the RowSet interface and their implementations have been provided as a convenience for programmers. Programmers are free to write their own versions of the javax.sql.RowSet interface, to extend the implementations of the five RowSet interfaces, or to write their own implementations. However, many programmers will probably find that the standard reference implementations already fit their needs and will use them as is.\r\nThis section introduces you to the RowSet interface and the following interfaces that extend this interface:\r\n\r\nJdbcRowSet\r\nCachedRowSet\r\nWebRowSet\r\nJoinRowSet\r\nFilteredRowSet\r\n\r\nThe following topics are covered:\r\n\r\nWhat Can RowSet Objects Do?\r\nKinds of RowSet Objects\r\n\r\n\r\nWhat Can RowSet Objects Do?\r\nAll RowSet objects are derived from the ResultSet interface and therefore share its capabilities. What makes JDBC RowSet objects special is that they add these new capabilities:\r\n\r\nFunction as JavaBeans Component\r\nAdd Scrollability or Updatability\r\n\r\n\r\nFunction as JavaBeans Component\r\nAll RowSet objects are JavaBeans components. This means that they have the following:\r\n\r\nProperties\r\nJavaBeans Notification Mechanism\r\n\r\n\r\nProperties\r\nAll RowSet objects have properties. A property is a field that has corresponding getter and setter methods. Properties are exposed to builder tools (such as those that come with the IDEs JDveloper and Eclipse) that enable you to visually manipulate beans. For more information, see the \r\nProperties lesson in the \r\nJavaBeans trail.\r\nJavaBeans Notification Mechanism\r\nRowSet objects use the JavaBeans event model, in which registered components are notified when certain events occur. For all RowSet objects, three events trigger notifications:\r\n\r\nA cursor movement\r\nThe update, insertion, or deletion of a row\r\nA change to the entire RowSet contents\r\n\r\nThe notification of an event goes to all listeners, components that have implemented the RowSetListener interface and have had themselves added to the RowSet object's list of components to be notified when any of the three events occurs.\r\nA listener could be a GUI component such as a bar graph. If the bar graph is tracking data in a RowSet object, the listener would want to know the new data values whenever the data changed. The listener would therefore implement the RowSetListener methods to define what it will do when a particular event occurs. Then the listener also must be added to the RowSet object's list of listeners. The following line of code registers the bar graph component bg with the RowSet object rs.\r\n\r\nrs.addListener(bg);\r\n\r\nNow bg will be notified each time the cursor moves, a row is changed, or all of rs gets new data.\r\n\r\nAdd Scrollability or Updatability\r\nSome DBMSs do not support result sets that can be scrolled (scrollable), and some do not support result sets that can be updated (updatable). If a driver for that DBMS does not add the ability to scroll or update result sets, you can use a RowSet object to do it. A RowSet object is scrollable and updatable by default, so by populating a RowSet object with the contents of a result set, you can effectively make the result set scrollable and updatable.\r\n\r\nKinds of RowSet Objects\r\nA RowSet object is considered either connected or disconnected. A connected RowSet object uses a JDBC driver to make a connection to a relational database and maintains that connection throughout its life span. A disconnected RowSet object makes a connection to a data source only to read in data from a ResultSet object or to write data back to the data source. After reading data from or writing data to its data source, the RowSet object disconnects from it, thus becoming \"disconnected.\" During much of its life span, a disconnected RowSet object has no connection to its data source and operates independently. The next two sections tell you what being connected or disconnected means in terms of what a RowSet object can do.\r\nConnected RowSet Objects\r\nOnly one of the standard RowSet implementations is a connected RowSet object: JdbcRowSet. Always being connected to a database, a JdbcRowSet object is most similar to a ResultSet object and is often used as a wrapper to make an otherwise non-scrollable and read-only ResultSet object scrollable and updatable.\r\nAs a JavaBeans component, a JdbcRowSet object can be used, for example, in a GUI tool to select a JDBC driver. A JdbcRowSet object can be used this way because it is effectively a wrapper for the driver that obtained its connection to the database.\r\nDisconnected RowSet Objects\r\nThe other four implementations are disconnected RowSet implementations. Disconnected RowSet objects have all the capabilities of connected RowSet objects plus they have the additional capabilities available only to disconnected RowSet objects. For example, not having to maintain a connection to a data source makes disconnected RowSet objects far more lightweight than a JdbcRowSet object or a ResultSet object. Disconnected RowSet objects are also serializable, and the combination of being both serializable and lightweight makes them ideal for sending data over a network. They can even be used for sending data to thin clients such as PDAs and mobile phones.\r\nThe CachedRowSet interface defines the basic capabilities available to all disconnected RowSet objects. The other three are extensions of the CachedRowSet interface, which provide more specialized capabilities. The following information shows how they are related:\r\nA CachedRowSet object has all the capabilities of a JdbcRowSet object plus it can also do the following:\r\n\r\nObtain a connection to a data source and execute a query\r\nRead the data from the resulting ResultSet object and populate itself with that data\r\nManipulate data and make changes to data while it is disconnected\r\nReconnect to the data source to write changes back to it\r\nCheck for conflicts with the data source and resolve those conflicts\r\n\r\nA WebRowSet object has all the capabilities of a CachedRowSet object plus it can also do the following:\r\n\r\nWrite itself as an XML document\r\nRead an XML document that describes a WebRowSet object\r\n\r\nA JoinRowSet object has all the capabilities of a WebRowSet object (and therefore also those of a CachedRowSet object) plus it can also do the following:\r\n\r\nForm the equivalent of a SQL JOIN without having to connect to a data source\r\n\r\nA FilteredRowSet object likewise has all the capabilities of a WebRowSet object (and therefore also a CachedRowSet object) plus it can also do the following:\r\n\r\nApply filtering criteria so that only selected data is visible. This is equivalent to executing a query on a RowSet object without having to use a query language or connect to a data source.\r\n\r\n",
        "title": "Oracle_Using RowSet Objects.txt",
        "type": "Oracle_"
    }, {
        "rank": 5,
        "text": "\r\n\r\nThis page maps sections in the Java Tutorials to topics covered in the Java SE 8 Programmer II exam.  This exam is associated with the Oracle Certified Professional, Java SE 8 Programmer certificate. The topics covered in this exam are:\r\n\r\nJava Class Design\r\nAdvanced Class Design\r\nGenerics and Collections\r\nLambda Built-In Functional Interfaces\r\nJava Stream API\r\nExceptions and Assertions\r\nUse Java SE 8 Date/Time API\r\nJava I/O Fundamentals\r\nJava File I/O (NIO.2)\r\nConcurrency\r\nBuilding Database Applications with JDBC\r\nLocalization\r\n\r\n\r\nSection 1: Java Class Design\r\n\r\nItem 1: Implement encapsulation.\r\n\r\n\r\nWhat Is an Object?\r\n\r\n\r\nItem 2: Implement inheritance including visibility modifiers and composition.\r\n\r\n\r\nInheritance\r\n\r\nOverriding and Hiding Methods\r\n\r\n\r\nItem 3: Implement polymorphism.\r\n\r\n\r\nPolymorphism\r\n\r\n\r\nItem 4: Override hasCode, equals, and toString methods from Object class.\r\n\r\n\r\nObject as a Superclass\r\n\r\n\r\nItem 5: Create and use singleton classes and immutable classes.\r\n\r\n\r\nThe Singleton Design Pattern\r\n\r\nA Strategy for Defining Immutable Objects\r\n\r\n\r\nItem 6: Develop code that uses the static keyword on initialize blocks, variables, methods, and classes.\r\n\r\n\r\nUnderstanding Class Members\r\n\r\nInitializing Fields\r\n\r\nOverriding and Hiding Methods\r\n\r\nDefault Methods\r\n\r\n\r\nSection 2: Advanced Class Design\r\nItem 1: Develop code that uses abstract classes and methods.\r\n\r\n\r\nAbstract Methods and Classes\r\n\r\n\r\nItem 2: Develop code that uses the final.\r\n\r\n\r\nVariables\r\n\r\nUnderstanding Class Members\r\n\r\n\r\nItem 3: Create inner classes including static inner classes, local classes, nested classes, and anonymous innter classes.\r\n\r\n\r\nNested Classes\r\n\r\nInner Class Example\r\n\r\nLocal Classes\r\n\r\nAnonymous Classes\r\n\r\nWhen to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions \r\n\r\n\r\nItem 4: Use enumerated types including methods, and constructors in an enum type\r\n\r\n\r\nEnum Types\r\n\r\nDefault Methods\r\n\r\nEnumerated Types\r\n\r\n\r\nItem 5: Develop code that declares, implements and/or extends interfaces and use the @Override annotation.\r\n\r\n\r\nPredefined Annotation Types\r\n\r\n\r\nItem 6: Create and use lambda expressions.\r\n\r\n\r\nLambda Expressions\r\n\r\n\r\nSection 3: Generics and Collections\r\nThe\r\nGenerics (Updated) lesson, the\r\nCollections trail and, in particular, the specified pages.\r\n\r\nItem 1: Create and use a generic class.\r\n\r\n\r\nGeneric Types\r\n\r\n\r\nItem 2: Create and use ArrayList, TreeSet, TreeMap, and ArrayDeque objects.\r\n\r\n\r\nThe List Interface\r\n\r\nThe Set Interface\r\n\r\nThe Map Interface\r\n\r\nThe Deque Interface\r\n\r\n\r\nItem 3: Use java.util.Comparator and java.lang.Comparable interfaces.\r\n\r\n\r\nObject Ordering\r\n\r\n\r\nItem 4: Collections, streams, and filters.\r\n\r\n\r\nAggregate Operations\r\n\r\n\r\nItem 5: Iterate using forEach methods of Streams and List.\r\n\r\n\r\nThe Collection Interface\r\n\r\nAggregate Operations\r\n\r\n\r\nItem 6: Describe the Stream interface and the Stream pipeline.\r\n\r\n\r\nAggregate Operations\r\n\r\n\r\nItem 7: Filter a collection by using lambda expressions.\r\n\r\n\r\nThe Collection Interface\r\n\r\nAggregate Operations\r\n\r\n\r\nItem 8: Use method references with streams.\r\n\r\n\r\nMethod References\r\n\r\n\r\nSection 4: Lambda Built-In Functional Interfaces\r\nThe sections  \r\nLambda Expressions and\r\nAggregate Operations cover some of the following items:\r\n\r\nItem 1: Use the built-in interfaces included in the java.util.function package such as Predicate, Consumer, Function, and Supplier.\r\n\r\nItem 2: Develop code that uses primitive versions of functional interfaces.\r\n\r\nItem 3: Develop code that uses binary versions of functional interfaces.\r\n\r\nItem 4: Develop code that uses the UnaryOperator interface.\r\n\r\nSection 5: Java Stream API\r\nThe sections  \r\nLambda Expressions and\r\nAggregate Operations cover some of the following items:\r\n\r\nItem 1: Develop code to extract data from an object using peek() and map() methods including primitive versions of the map() method.\r\n\r\nItem 2: Search for data by using search methods of the Stream classes including findFirst, findAny, anyMatch, allMatch, noneMatch.\r\n\r\nItem 3: Develop code that uses the Optional class.\r\n\r\nItem 4: Develop code that uses Stream data methods and calculation methods.\r\n\r\nItem 5: Sort a collection using Stream API.\r\n\r\nItem 6: Save results to a collection using the collect method and group/partition data using the Collectors class.\r\n\r\nItem 7: Use flatMap() methods in the Stream API.\r\n\r\n\r\nSection 6: Exceptions and Assertions\r\nItem 1: Use try-catch and throws statements.\r\n\r\n\r\nSpecifying the Exceptions Thrown by a Method\r\n\r\nHow to Throw Exceptions\r\n\r\n\r\nItem 2: Use catch, multi-catch, and finally clauses.\r\n\r\n\r\nCatching and Handling Exceptions\r\n\r\nThe try Block\r\n\r\nThe catch Blocks\r\n\r\nThe finally Block\r\n\r\nPutting It All Together\r\n\r\n\r\nItem 3: Use autoclose resources with a try-with-resources statement.\r\n\r\n\r\nThe try-with-resources Statement\r\n\r\n\r\nItem 4: Create custom exceptions and autocloseable resources.\r\n\r\n\r\nCreating Exception Classes\r\n\r\n\r\nItem 5: Test invariants by using assertions.\r\n\r\n\r\nQuestions and Exercises: Classes (assertion example)\r\n\r\n\r\nSection 7: Use Java SE 8 Date/Time API \r\n\r\nItem 1: Create and manage date-based and time-based events including a combination of date and time into a single object using LocalDate, LocalTime, LocalDateTime, Instant, Period, and Duration.\r\n\r\n\r\nDate Classes\r\n\r\nDate and Time Classes\r\n\r\nInstant Class\r\n\r\nPeriod and Duration\r\n\r\n\r\nItem 2: Work with dates and times across timezones and manage changes resulting from daylight savings including Format date and times values.\r\n\r\n\r\nTime Zone and Offset Classes\r\n\r\n\r\nItem 3: Define and create and manage date-based and time-based events using Instant, Period, Duration, and TemporalUnit.\r\n\r\n\r\nInstant Class\r\n\r\nPeriod and Duration\r\n\r\nThe Temporal Package\r\n\r\n\r\nSection 8: Java I/O Fundamentals\r\nItem 1: Read and write data from the console.\r\nThe \r\nI/O Streams lesson and, in particular, the following pages:\r\n\r\n\r\nByte Streams\r\n\r\nI/O from the Command Line\r\n\r\n\r\nItem 2: Use BufferedReader, BufferedWriter, File, FileReader, FileWriter, FileInputStream, FileOutputStream, ObjectOutputStream, ObjectInputStream, and PrintWriter in the java.io package.\r\nThe \r\nFile I/O (Featuring NIO.2) lesson, and in particular, the following pages:\r\n\r\n\r\nReading, Writing, and Creating Files\r\n\r\nCreating and Reading Directories\r\n\r\nRandom Access Files\r\n\r\n\r\nSection 9: Java File I/O (NIO.2)\r\nItem 1: Use the Path interface to operate on file and directory paths.\r\n\r\n\r\nWhat Is a Path? (And Other File System Facts)\r\n\r\nPath Operations\r\n\r\n\r\nItem 2: Use the Files class to check, read, delete, copy, move, and manage metadata a file or directory.\r\n\r\n\r\nFile Operations\r\n\r\nChecking a File or Directory\r\n\r\nDeleting a File or Directory\r\n\r\nCopying a File or Directory\r\n\r\nMoving a File or Directory\r\n\r\nManaging Metadata (File and File Store Attributes)\r\n\r\nWalking the File Tree\r\n\r\nFinding Files\r\n\r\nWhat is a Glob?\r\n\r\nWatching a Directory for Changes\r\n\r\n\r\nItem 3: Use Stream API with NIO.2.\r\n\r\nSection 3: Object-Oriented Design Principles\r\nThe Java Tutorials do not cover Design Patterns topics. The following references cover design patterns using the Java programming language:\r\n\r\nHead First Design Patterns by Elizabeth Freeman, et al.\r\nJava Design Pattern Essentials by Tony Bevis\r\n\r\nItem 1: Write code that declares, implements and/or extends interfaces.\r\n\r\n\r\nDefining an Interface\r\n\r\nInterfaces\r\n\r\nImplementing an Interface\r\n\r\n\r\nItem 2: Choose between interface inheritance and class inheritance.\r\n\r\nItem 3: Develop code that implements \"is-a\" and/or \"has-a\" relationships.\r\n\r\nItem 4: Apply object composition principles.\r\n\r\nItem 5: Design a class using the Singleton design pattern.\r\n\r\nItem 6: Write code to implement the DAO pattern.\r\n\r\nItem 7: Design and create objects using a factory, and use factories from the API.\r\n\r\n\r\nSection 5: String Processing\r\nItem 1: Search, parse and build strings.\r\n\r\n\r\nStrings\r\n\r\nConverting Between Numbers and Strings\r\n\r\nComparing Strings and Portions of Strings\r\n\r\nManipulating Characters in a String\r\n\r\n\r\nItem 2: Search, parse, and replace strings by using regular expressions.\r\n\r\n\r\nMethods of the Pattern Class\r\n\r\nMethods of the Matcher Class\r\n\r\n\r\nItem 3: Use string formatting.\r\n\r\n\r\nStrings\r\n\r\nFormatting Numeric Print Output\r\n\r\n\r\nSection 10: Concurrency\r\n\r\nItem 1: Create worker threads using Runnable, Callable and use an ExecutorService to concurrently execute tasks.\r\n\r\n\r\nExecutors\r\n\r\nExecutor Interfaces\r\n\r\nThread Pools\r\n\r\n\r\nItem 2: Identify potential threading problems among deadlock, starvation, livelock, and race conditions.\r\n\r\n\r\nMemory Consistency Errors\r\n\r\nDeadlock\r\n\r\n\r\nItem 3: Use synchronized keyword and java.util.concurrent.atomic package to control the order of thread execution.\r\n\r\n\r\nAtomic Variables\r\n\r\n\r\nItem 4: Use java.util.concurrent collections and classes including CyclicBarrier and CopyOnWriteArrayList.\r\n\r\n\r\nConcurrent Collections\r\n\r\n\r\nItem 5: Use parallel Fork/Join Framework.\r\n\r\n\r\nFork/Join\r\n\r\n\r\nItem 6: Use parallel Streams including reduction, decomposition, merging processes, pipelines and performance.\r\n\r\nSection 11: Building Database Applicatons with JDBC\r\nItem 1:  Describe the interfaces that make up the core of the JDBC API including the Driver, Connection, Statement, and ResultSet interfaces and their relationship to provider implementations.\r\n\r\n\r\nJDBC Basics: Getting Started\r\n\r\n\r\nItem 2: Identify the components required to connect to a database using the DriverManager class including the JDBC URL.\r\n\r\n\r\nEstablishing a Connection\r\n\r\nConnecting with DataSource Objects\r\n\r\n\r\nItem 3:  Submit queries and read results from the database including creating statements, returning result sets, iterating through the results, and properly closing result sets, statements, and connections.\r\n\r\n\r\nProcessing SQL Statements with JDBC\r\n\r\nUsing Transactions\r\n\r\nUsing RowSet Objects\r\n\r\nUsing JdbcRowSet Objects\r\n\r\n\r\nSection 12: Localization\r\nItem 1: Read and set the locale by using the Locale object..\r\n\r\n\r\nSetting the Locale\r\n\r\nCreating a Locale\r\n\r\n\r\nItem 2: Create and read a Properties file.\r\n\r\n\r\nAbout the ResourceBundle Class\r\n\r\nBacking a ResourceBundle with Properties Files\r\n\r\n\r\nItem 3: Build a resource bundle for each locale and load a resource bundle in an application.\r\n\r\n\r\nCustomizing Resource Bundle Loading\r\n\r\n",
        "title": "Oracle_Java SE 8 Programmer II Exam.txt",
        "type": "Oracle_"
    }, {
        "rank": 6,
        "text": "\r\n\r\nAn abstract class is a class that is declared abstractâ\u20ac\u201dit may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.\r\nAn abstract method is a method that is declared without an implementation (without braces, and followed by a semicolon), like this:\r\n\r\nabstract void moveTo(double deltaX, double deltaY);\r\n\r\nIf a class includes abstract methods, then the class itself must be declared abstract, as in:\r\n\r\npublic abstract class GraphicObject {\r\n   // declare fields\r\n   // declare nonabstract methods\r\n   abstract void draw();\r\n}\r\n\r\nWhen an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, then the subclass must also be declared abstract.\r\nNote:Â Methods in an interface (see the \r\nInterfaces section) that are not declared as default or static are implicitly abstract, so the abstract modifier is not used with interface methods. (It can be used, but it is unnecessary.)\r\n\r\nAbstract Classes Compared to Interfaces\r\nAbstract classes are similar to interfaces. You cannot instantiate them, and they may contain a mix of methods declared with or without an implementation. However, with abstract classes, you can declare fields that are not static and final, and define public, protected, and private concrete methods. With interfaces, all fields are automatically public, static, and final, and all methods that you declare or define (as default methods) are public. In addition, you can extend only one class, whether or not it is abstract, whereas you can implement any number of interfaces.\r\nWhich should you use, abstract classes or interfaces?\r\n\r\nConsider using abstract classes if any of these statements apply to your situation:\r\n    \r\nYou want to share code among several closely related classes.\r\nYou expect that classes that extend your abstract class have many common methods or fields, or require access modifiers other than public (such as protected and private).\r\nYou want to declare non-static or non-final fields. This enables you to define methods that can access and modify the state of the object to which they belong.\r\n\r\n\r\nConsider using interfaces if any of these statements apply to your situation:\r\n    \r\nYou expect that unrelated classes would implement your interface. For example, the interfaces\r\nComparable and\r\nCloneable are implemented by many unrelated classes.\r\nYou want to specify the behavior of a particular data type, but not concerned about who implements its behavior.\r\nYou want to take advantage of multiple inheritance of type.\r\n\r\n\r\n\r\nAn example of an abstract class in the JDK is\r\nAbstractMap, which is part of the Collections Framework. Its subclasses (which include HashMap, TreeMap, and ConcurrentHashMap) share many methods (including get, put, isEmpty, containsKey, and containsValue) that AbstractMap defines.\r\nAn example of a class in the JDK that implements several interfaces is \r\nHashMap, which implements the interfaces Serializable, Cloneable, and Map<K, V>. By reading this list of interfaces, you can infer that an instance of HashMap (regardless of the developer or company who implemented the class) can be cloned, is serializable (which means that it can be converted into a byte stream; \r\nsee the section\r\nSerializable Objects), and has the functionality of a map. In addition, the Map<K, V> interface has been enhanced with many default methods such as merge and forEach that older classes that have implemented this interface do not have to define.\r\nNote that many software libraries use both abstract classes and interfaces; the HashMap class implements several interfaces and also extends the abstract class AbstractMap.\r\nAn Abstract Class Example\r\nIn an object-oriented drawing application, you can draw circles, rectangles, lines, Bezier curves, and many other graphic objects. These objects all have certain states (for example: position, orientation, line color, fill color) and behaviors (for example: moveTo, rotate, resize, draw) in common. Some of these states and behaviors are the same for all graphic objects (for example: position, fill color, and moveTo). Others require different implementations (for example, resize or draw). All GraphicObjects must be able to draw or resize themselves; they just differ in how they do it. This is a perfect situation for an abstract superclass. You can take advantage of the similarities and declare all the graphic objects to inherit from the same abstract parent object (for example, GraphicObject) as shown in \r\nthe following figure.\r\n",
        "title": "Oracle_Abstract Methods and Classes.txt",
        "type": "Oracle_"
    }, {
        "rank": 7,
        "text": "\r\n\r\nThe dictionary definition of polymorphism refers to a principle in biology in which an organism or species can have many different forms or stages. This principle can also be applied to object-oriented programming and languages like the Java language. Subclasses of a class can define their own unique behaviors and yet share some of the same functionality of the parent class.\r\nPolymorphism can be demonstrated with a minor modification to the Bicycle class. For example, a printDescription method could be added to the class that displays all the data currently stored in an instance.\r\n\r\npublic void printDescription(){\r\n    System.out.println(\"\\nBike is \" + \"in gear \" + this.gear\r\n        + \" with a cadence of \" + this.cadence +\r\n        \" and travelling at a speed of \" + this.speed + \". \");\r\n}\r\n\r\nTo demonstrate polymorphic features in the Java language, extend the Bicycle class with a MountainBike and a RoadBike class. For MountainBike, add a field for suspension, which is a String value that indicates if the bike has a front shock absorber, Front. Or, the bike has a front and back shock absorber, Dual.\r\nHere is the updated class:\r\n\r\npublic class MountainBike extends Bicycle {\r\n    private String suspension;\r\n\r\n    public MountainBike(\r\n               int startCadence,\r\n               int startSpeed,\r\n               int startGear,\r\n               String suspensionType){\r\n        super(startCadence,\r\n              startSpeed,\r\n              startGear);\r\n        this.setSuspension(suspensionType);\r\n    }\r\n\r\n    public String getSuspension(){\r\n      return this.suspension;\r\n    }\r\n\r\n    public void setSuspension(String suspensionType) {\r\n        this.suspension = suspensionType;\r\n    }\r\n\r\n    public void printDescription() {\r\n        super.printDescription();\r\n        System.out.println(\"The \" + \"MountainBike has a\" +\r\n            getSuspension() + \" suspension.\");\r\n    }\r\n} \r\n\r\nNote the overridden printDescription method. In addition to the information provided before, additional data about the suspension is included to the output.\r\nNext, create the RoadBike class. Because road or racing bikes have skinny tires, add an attribute to track the tire width. Here is the RoadBike class:\r\n\r\npublic class RoadBike extends Bicycle{\r\n    // In millimeters (mm)\r\n    private int tireWidth;\r\n\r\n    public RoadBike(int startCadence,\r\n                    int startSpeed,\r\n                    int startGear,\r\n                    int newTireWidth){\r\n        super(startCadence,\r\n              startSpeed,\r\n              startGear);\r\n        this.setTireWidth(newTireWidth);\r\n    }\r\n\r\n    public int getTireWidth(){\r\n      return this.tireWidth;\r\n    }\r\n\r\n    public void setTireWidth(int newTireWidth){\r\n        this.tireWidth = newTireWidth;\r\n    }\r\n\r\n    public void printDescription(){\r\n        super.printDescription();\r\n        System.out.println(\"The RoadBike\" + \" has \" + getTireWidth() +\r\n            \" MM tires.\");\r\n    }\r\n}\r\n\r\nNote that once again, the printDescription method has been overridden. This time, information about the tire width is displayed.\r\nTo summarize, there are three classes: Bicycle, MountainBike, and RoadBike. The two subclasses override the printDescription method and print unique information.\r\nHere is a test program that creates three Bicycle variables. Each variable is assigned to one of the three bicycle classes. Each variable is then printed.\r\n\r\npublic class TestBikes {\r\n  public static void main(String[] args){\r\n    Bicycle bike01, bike02, bike03;\r\n\r\n    bike01 = new Bicycle(20, 10, 1);\r\n    bike02 = new MountainBike(20, 10, 5, \"Dual\");\r\n    bike03 = new RoadBike(40, 20, 8, 23);\r\n\r\n    bike01.printDescription();\r\n    bike02.printDescription();\r\n    bike03.printDescription();\r\n  }\r\n}\r\n\r\nThe following is the output from the test program:\r\n\r\nBike is in gear 1 with a cadence of 20 and travelling at a speed of 10. \r\n\r\nBike is in gear 5 with a cadence of 20 and travelling at a speed of 10. \r\nThe MountainBike has a Dual suspension.\r\n\r\nBike is in gear 8 with a cadence of 40 and travelling at a speed of 20. \r\nThe RoadBike has 23 MM tires.\r\n\r\nThe Java virtual machine (JVM) calls the appropriate method for the object that is referred to in each variable. It does not call the method that is defined by the variable's type. This behavior is referred to as virtual method invocation and demonstrates an aspect of the important polymorphism features in the Java language.\r\n",
        "title": "Oracle_Polymorphism.txt",
        "type": "Oracle_"
    }, {
        "rank": 8,
        "text": "\r\n\r\nInstance Methods\r\nAn instance method in a subclass with the same signature (name, plus the number and the type of its parameters) and return type as an instance method in the superclass overrides the superclass's method.\r\nThe ability of a subclass to override a method allows a class to inherit from a superclass whose behavior is \"close enough\" and then to modify behavior as needed. The overriding method has the same name, number and type of parameters, and return type as the method that it overrides. An overriding method can also return a subtype of the type returned by the overridden method. This subtype is called a covariant return type.\r\nWhen overriding a method, you might want to use the @Override annotation that instructs the compiler that you intend to override a method in the superclass. If, for some reason, the compiler detects that the method does not exist in one of the superclasses, then it will generate an error. For more information on @Override, see \r\nAnnotations.\r\nStatic Methods\r\nIf a subclass defines a static method with the same signature as a static method in the superclass, then the method in the subclass hides the one in the superclass.\r\nThe distinction between hiding a static method and overriding an instance method has important implications:\r\n\r\nThe version of the overridden instance method that gets invoked is the one in the subclass.\r\nThe version of the hidden static method that gets invoked depends on whether it is invoked from the superclass or the subclass.\r\n\r\nConsider an example that contains two classes. The first is Animal, which contains one instance method and one static method:\r\n\r\npublic class Animal {\r\n    public static void testClassMethod() {\r\n        System.out.println(\"The static method in Animal\");\r\n    }\r\n    public void testInstanceMethod() {\r\n        System.out.println(\"The instance method in Animal\");\r\n    }\r\n}\r\n\r\nThe second class, a subclass of Animal, is called Cat:\r\n\r\npublic class Cat extends Animal {\r\n    public static void testClassMethod() {\r\n        System.out.println(\"The static method in Cat\");\r\n    }\r\n    public void testInstanceMethod() {\r\n        System.out.println(\"The instance method in Cat\");\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Cat myCat = new Cat();\r\n        Animal myAnimal = myCat;\r\n        Animal.testClassMethod();\r\n        myAnimal.testInstanceMethod();\r\n    }\r\n}\r\n\r\nThe Cat class overrides the instance method in Animal and hides the static method in Animal. The main method in this class creates an instance of Cat and invokes testClassMethod() on the class and testInstanceMethod() on the instance.\r\nThe output from this program is as follows:\r\n\r\nThe static method in Animal\r\nThe instance method in Cat\r\n\r\nAs promised, the version of the hidden static method that gets invoked is the one in the superclass, and the version of the overridden instance method that gets invoked is the one in the subclass.\r\n\r\nInterface Methods\r\n\r\nDefault methods and \r\nabstract methods in interfaces are inherited like instance methods. However, when the supertypes of a class or interface provide multiple default methods with the same signature, the Java compiler follows inheritance rules to resolve the name conflict. These rules are driven by the following two principles:\r\n\r\n\r\nInstance methods are preferred over interface default methods.\r\nConsider the following classes and interfaces:\r\npublic class Horse {\r\n    public String identifyMyself() {\r\n        return \"I am a horse.\";\r\n    }\r\n}\r\npublic interface Flyer {\r\n    default public String identifyMyself() {\r\n        return \"I am able to fly.\";\r\n    }\r\n}\r\npublic interface Mythical {\r\n    default public String identifyMyself() {\r\n        return \"I am a mythical creature.\";\r\n    }\r\n}\r\npublic class Pegasus extends Horse implements Flyer, Mythical {\r\n    public static void main(String... args) {\r\n        Pegasus myApp = new Pegasus();\r\n        System.out.println(myApp.identifyMyself());\r\n    }\r\n}\r\nThe method Pegasus.identifyMyself returns the string I am a horse.\r\n\r\nMethods that are already overridden by other candidates are ignored. This circumstance can arise when supertypes share a common ancestor.\r\nConsider the following interfaces and classes:\r\npublic interface Animal {\r\n    default public String identifyMyself() {\r\n        return \"I am an animal.\";\r\n    }\r\n}\r\npublic interface EggLayer extends Animal {\r\n    default public String identifyMyself() {\r\n        return \"I am able to lay eggs.\";\r\n    }\r\n}\r\npublic interface FireBreather extends Animal { }\r\npublic class Dragon implements EggLayer, FireBreather {\r\n    public static void main (String... args) {\r\n        Dragon myApp = new Dragon();\r\n        System.out.println(myApp.identifyMyself());\r\n    }\r\n}\r\nThe method Dragon.identifyMyself returns the string I am able to lay eggs.\r\n\r\n\r\nIf two or more independently defined default methods conflict, or a default method conflicts with an abstract method, then the Java compiler produces a compiler error. You must explicitly override the supertype methods.\r\nConsider the example about computer-controlled cars that can now fly. You have two interfaces (OperateCar and FlyCar) that provide default implementations for the same method, (startEngine):\r\npublic interface OperateCar {\r\n    // ...\r\n    default public int startEngine(EncryptedKey key) {\r\n        // Implementation\r\n    }\r\n}\r\npublic interface FlyCar {\r\n    // ...\r\n    default public int startEngine(EncryptedKey key) {\r\n        // Implementation\r\n    }\r\n}\r\nA class that implements both OperateCar and FlyCar must override the method startEngine. You could invoke any of the of the default implementations with the super keyword.\r\npublic class FlyingCar implements OperateCar, FlyCar {\r\n    // ...\r\n    public int startEngine(EncryptedKey key) {\r\n        FlyCar.super.startEngine(key);\r\n        OperateCar.super.startEngine(key);\r\n    }\r\n}\r\nThe name preceding super (in this example, FlyCar or OperateCar) must refer to a direct superinterface that defines or inherits a default for the invoked method. This form of method invocation is not restricted to differentiating between multiple implemented interfaces that contain default methods with the same signature. You can use the super keyword to invoke a default method in both classes and interfaces.\r\nInherited instance methods from classes can override abstract interface methods. Consider the following interfaces and classes:\r\n\r\npublic interface Mammal {\r\n    String identifyMyself();\r\n}\r\n\r\n\r\npublic class Horse {\r\n    public String identifyMyself() {\r\n        return \"I am a horse.\";\r\n    }\r\n}\r\n\r\n\r\npublic class Mustang extends Horse implements Mammal {\r\n    public static void main(String... args) {\r\n        Mustang myApp = new Mustang();\r\n        System.out.println(myApp.identifyMyself());\r\n    }\r\n}\r\n\r\nThe method Mustang.identifyMyself returns the string I am a horse. The class Mustang inherits the method identifyMyself from the class Horse, which overrides the abstract method of the same name in the interface Mammal.\r\nNote: Static methods in interfaces are never inherited.\r\nModifiers\r\nThe access specifier for an overriding method can allow more, but not less, access than the overridden method. For example, a protected instance method in the superclass can be made public, but not private, in the subclass.\r\nYou will get a compile-time error if you attempt to change an instance method in the superclass to a static method in the subclass, and vice versa.\r\nSummary\r\n\r\nThe following table summarizes what happens when you define a method with the same signature as a method in a superclass.\r\n\r\nDefining a Method with the Same Signature as a Superclass's Method\r\n\r\nÂ \r\nSuperclass Instance Method\r\nSuperclass Static Method\r\n\r\n\r\nSubclass Instance Method\r\nOverrides\r\nGenerates a compile-time error\r\n\r\n\r\nSubclass Static Method\r\nGenerates a compile-time error\r\nHides\r\n\r\n\r\nNote:Â In a subclass, you can overload the methods inherited from the superclass. Such overloaded methods neither hide nor override the superclass instance methodsâ\u20ac\u201dthey are new methods, unique to the subclass.\r\n\r\n",
        "title": "Oracle_Overriding and Hiding Methods.txt",
        "type": "Oracle_"
    }, {
        "rank": 9,
        "text": "\r\n\r\nThis page maps sections in the Java Tutorials to topics covered in the Java SE 8 Programmer I exam. This exam is associated with the Oracle Certified Associate, Java SE 8 Programmer certificate.  The topics covered in this exam are:\r\n\r\nJava Basics\r\nWorking with Java Data Types\r\nUsing Operators and Decision Constructs\r\nCreating and Using Arrays\r\nUsing Loop Constructs\r\nWorking with Methods and Encapsulation\r\nWorking with Inheritance\r\nHandling Exceptions\r\nWorking with Selected classes from the Java API\r\n\r\nSection 1: Java Basics\r\nItem 1: Define the scope of variables.\r\n\r\n\r\nVariables\r\n\r\n\r\nItem 2: Define the structure of a Java class.\r\n\r\n\r\nA Closer Look at the \"Hello World!\" Application\r\n\r\nClasses\r\n\r\n\r\nItem 3:  Create executable Java applications with a main method; run a Java program from the command line; produce console output.\r\n\r\n\r\n\"Hello World!\" for the NetBeans IDE\r\n\r\n\"Hello World!\" for Microsoft Windows\r\n\r\n\"Hello World!\" for Solaris OS and Linux\r\n\r\nA Closer Look at the \"Hello World!\" Application\r\n\r\n\r\nItem 4: Import other Java packages to make them accessible in your code.\r\n\r\n\r\nCreating and Using Packages\r\n\r\nUsing Package Members\r\n\r\n\r\nItem 5: Compare and contrast the features and components of Java such as: platform independence, object orientation, encapsulation, etc.\r\n\r\n\r\nAbout the Java Technology\r\n\r\nObject-Oriented Programming Concepts\r\n\r\n\r\n\r\nSection 2: Working with Java Data Types\r\nItem 1: Declare and initialize variables (including casting of primitive data types).\r\n\r\n\r\nVariables\r\n\r\nInitializing Fields\r\n\r\n\r\nItem 2: Differentiate between object reference variables and primitive variables.\r\n\r\n\r\nPrimitive Data Types\r\n\r\nThe Numbers Classes\r\n\r\n\r\nItem 3: Know how to read or write to object fields.\r\n\r\n\r\nInheritance\r\n\r\nDeclaring Member Variables\r\n\r\nCreating Objects\r\n\r\nUsing Objects\r\n\r\n\r\nItem 4:  Explain an object's lifecycle (creation, \"dereference by reassignment\" and garbage collection).\r\n\r\n\r\nObjects\r\n\r\nCreating Objects\r\n\r\nUsing Objects\r\n\r\n\r\n\r\nSection 3: Using Operators and Decision Constructs\r\nItem 1: Use Java operators; use parentheses to override operator precedence.\r\n\r\n\r\nOperators\r\n\r\nAssignment, Arithmetic, and Unary Operators\r\n\r\nEquality, Relational, and Conditional Operators \r\n\r\nBitwise and Bit Shift Operators\r\n\r\nExpressions, Statements, and Blocks\r\n\r\n\r\nItem 2: Test equality between strings and other objects using == and equals().\r\n\r\n\r\nObject as a Superclass\r\n\r\n\r\nItem 3: Create and use if, if-else, and ternary constructs.\r\n\r\n\r\nThe if-then and if-then-else Statements\r\n\r\nEquality, Relational, and Conditional Operators \r\n\r\n\r\nItem 4: Use a switch statement.\r\n\r\n\r\nThe switch Statement\r\n\r\n\r\n\r\nSection 4: Creating and Using Arrays\r\nItem 1: Declare, instantiate, initialize and use a one-dimensional array.\r\n\r\n\r\nArrays\r\n\r\n\r\nItem 2: Declare, instantiate, initialize and use a multi-dimensional array.\r\n\r\n\r\nArrays\r\n\r\n\r\n\r\nSection 5: Using Loop Constructs\r\nItem 1: Create and use while loops.\r\n\r\n\r\nThe while and do-while Statements\r\n\r\n\r\nItem 2: Create and use for loops including the enhanced for loop.\r\n\r\n\r\nThe for Statement\r\n\r\n\r\nItem 3: Create and use do-while loops.\r\n\r\n\r\nThe while and do-while Statements\r\n\r\n\r\nItem 4: Compare loop constructs.\r\n\r\n\r\nSummary of Control Flow Statements\r\n\r\n\r\nItem 5: Use break and continue.\r\n\r\n\r\nBranching Statements\r\n\r\n\r\n\r\nSection 6: Working with Methods and Encapsulation\r\nItem 1: Create methods with arguments and return values, including overloaded methods.\r\n\r\n\r\nReturning a Value from a Method\r\n\r\nDefining Methods\r\n\r\n\r\nItem 2: Apply the static keyword to methods and fields.\r\n\r\n\r\nVariables\r\n\r\nUnderstanding Class Members\r\n\r\nDefault Methods\r\n\r\n\r\nItem 3: Create an overloaded method; differentiate between default and user defined constructors.\r\n\r\n\r\nDefining Methods\r\n\r\nProviding Constructors for Your Classes\r\n\r\n\r\nItem 4: Apply access modifiers.\r\n\r\n\r\nControlling Access to Members of a Class\r\n\r\n\r\nItem 5: Apply encapsulation principles to a class.\r\n\r\n\r\nInheritance\r\n\r\nInner Class Example\r\n\r\nNested Classes\r\n\r\n\r\nItem 6: Determine the effect upon object references and primitive values when they are passed into methods that change the values.\r\n\r\n\r\nPassing Information to a Method or a Constructor\r\n\r\n\r\n\r\nSection 7: Working with Inheritance\r\nItem 1: Describe inheritance and its benefits.\r\n\r\n\r\nInheritance\r\n\r\nOverriding and Hiding Methods\r\n\r\n\r\nItem 2: Develop code that makes use of polymorphism; develop code that overrides methods; differentiate between the type of a reference and the type of an object.\r\n\r\n\r\nPolymorphism\r\n\r\nCreating Objects\r\n\r\nUsing Objects\r\n\r\n\r\nItem 3: Determine when casting is necessary.\r\n\r\n\r\nInheritance\r\n\r\n\r\nItem 4: Use super and this to access objects and constructors.\r\n\r\n\r\nUsing the Keyword super\r\n\r\nUsing the this Keyword\r\n\r\n\r\nItem 5: Use abstract classes and interfaces.\r\n\r\n\r\nAbstract Methods and Classes\r\n\r\nDefining an Interface\r\n\r\nImplementing an Interface\r\n\r\n\r\n\r\nSection 8: Handling Exceptions\r\nItem 1: Differentiate among checked exceptions, RuntimeException, and Error.\r\n\r\n\r\nThe Catch or Specify Requirement\r\n\r\n\r\nItem 2: Create a try-catch block and determine how exceptions alter normal program flow.\r\n\r\n\r\nCatching and Handling Exceptions\r\n\r\nThe try Block\r\n\r\nThe catch Blocks\r\n\r\n\r\nItem 3: Describe the advantages of exception handling .\r\n\r\n\r\nWhat Is an Exception?\r\n\r\nAdvantages of Exceptions\r\n\r\n\r\nItem 4: Create and invoke a method that throws an exception.\r\n\r\n\r\nCatching Exceptions\r\n\r\n\r\nItem 5: Recognize common exception classes and categories (such as NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException, ClassCastException).\r\n\r\n\r\nSection 9: Working with Selected classes from the Java API\r\nItem 1: Manipulate data using the StringBuilder class and its methods.\r\n\r\n\r\nThe StringBuilder Class\r\n\r\nSummary of Characters and Strings\r\n\r\n\r\nItem 2: Create and manipulate strings.\r\n\r\n\r\nStrings\r\n\r\nConverting Between Numbers and Strings\r\n\r\nComparing Strings and Portions of Strings\r\n\r\nManipulating Characters in a String\r\n\r\n\r\nItem 3: Create and manipulate calendar data using classes from java.time.LocalDateTime,  java.time.LocalDate, java.time.LocalTime, java.time.format.DateTimeFormatter, java.time.Period.\r\n\r\n\r\nDate and Time Classes\r\n\r\nDate Classes\r\n\r\nParsing and Formatting\r\n\r\nPeriod and Duration\r\n\r\n\r\nItem 4: Declare and use an ArrayList of a given type.\r\n\r\n\r\nThe List Interface\r\n\r\nList Implementations\r\n\r\n\r\nItem 5: Write a simple Lambda expression that consumes a Lambda Predicate expression.\r\n\r\n\r\n\r\nLambda Expressions\r\n\r\nAggregate Operations\r\n\r\n",
        "title": "Oracle_Java SE 8 Programmer I Exam.txt",
        "type": "Oracle_"
    }, {
        "rank": 10,
        "text": "\r\nThe Java Sound API takes a flexible approach to system configuration. Different sorts of audio devices (mixers) can be installed on a computer. The API makes few assumptions about what devices have been installed and what their capabilities are. Instead, it provides ways for the system to report about the available audio components, and ways for your program to access them.\r\n The following sections show how your program can learn what sampled-audio resources have been installed on the computer, and how it can gain access to the available resources. Among other things, the resources include mixers and the various types of lines owned by the mixers.\r\n\r\nThe AudioSystem Class\r\n The \r\nAudioSystem class acts as a clearinghouse for audio components, including built-in services and separately installed services from third-party providers. AudioSystem serves as an application program's entry point for accessing these installed sampled-audio resources. You can query the AudioSystem to learn what sorts of resources have been installed, and then you can obtain access to them. For example, an application program might start out by asking the AudioSystem class whether there is a mixer that has a certain configuration, such as one of the input or output configurations illustrated earlier in the discussion of lines. From the mixer, the program would then obtain data lines, and so on.\r\nHere are some of the resources an application program can obtain from the AudioSystem:\r\n\r\nMixers â\u20ac\u201d A system typically has multiple mixers installed. There is usually at least one for audio input and one for audio output. There might also be mixers that don't have I/O ports but instead accept audio from an application program and deliver the mixed audio back to the program. The AudioSystem class provides a list of all of the installed mixers.\r\nLines â\u20ac\u201d Even though every line is associated with a mixer, an application program can get a line directly from the AudioSystem, without dealing explicitly with mixers.\r\nFormat conversions â\u20ac\u201d An application program can use format conversions to translate audio data from one format to another.\r\nFiles and streams â\u20ac\u201d The AudioSystem class provides methods for translating between audio files and audio streams. It can also report the file format of a sound file and can write files in different formats.\r\n\r\nInformation Objects\r\n Several classes in the Java Sound API provide useful information about associated interfaces. For example, \r\nMixer.Info provides details about an installed mixer, such as the mixer's vendor, name, description, and version. \r\nLine.Info obtains the class of a specific line. Subclasses of Line.Info include \r\nPort.Info and \r\nDataLine.Info , which obtain details relevant to a specific port and data line, respectively. Each of these classes is described further in the appropriate section below. It's important not to confuse the Info object with the mixer or line object that it describes.\r\n\r\nGetting a Mixer\r\nUsually, one of the first things a program that uses the Java Sound API needs to do is to obtain a mixer, or at least one line of a mixer, so that you can get sound into or out of the computer. Your program might need a specific kind of mixer, or you might want to display a list of all the available mixers so that the user can select one. In either case, you need to learn what kinds of mixers are installed. AudioSystem provides the following method:\r\n\r\nstatic Mixer.Info[] getMixerInfo()\r\n\r\nEach \r\nMixer.Info object returned by this method identifies one type of mixer that is installed. (Usually a system has at most one mixer of a given type. If there happens to be more than one of a given type, the returned array still only has one Mixer.Info for that type.) An application program can iterate over the Mixer.Info objects to find an appropriate one, according to its needs. The Mixer.Info includes the following strings to identify the kind of mixer:\r\n\r\nName\r\nVersion\r\nVendor\r\nDescription\r\n\r\nThese are arbitrary strings, so an application program that needs a specific mixer must know what to expect and what to compare the strings to. The company that provides the mixer should include this information in its documentation. Alternatively, and perhaps more typically, the application program will display all the Mixer.Info objects' strings to the user and let the user choose the corresponding mixer.\r\n Once an appropriate mixer is found, the application program invokes the following AudioSystem method to obtain the desired mixer:\r\n\r\nstatic Mixer getMixer(Mixer.Info info)\r\n\r\nWhat if your program needs a mixer that has certain capabilities, but it doesn't need a specific mixer made by a specific vendor? And what if you can't depend on the user's knowing which mixer should be chosen? In that case, the information in the Mixer.Info objects won't be of much use. Instead, you can iterate over all the Mixer.Info objects returned by getMixerInfo, get a mixer for each by invoking getMixer, and query each mixer for its capabilities. For example, you might need a mixer that can write its mixed audio data to a certain number of target data lines simultaneously. In that case, you would query each mixer using this Mixer method:\r\n\r\nint getMaxLines(Line.Info info)\r\n\r\n Here, the \r\nLine.Info would specify a TargetDataLine. The Line.Info class is discussed in the next section.\r\n\r\nGetting a Line of a Desired Type\r\nThere are two ways to get a line:\r\n\r\nDirectly from the \r\nAudioSystem object\r\nFrom a mixer that you have already obtained from the AudioSystem object\r\n\r\nGetting a Line Directly from the AudioSystem\r\n Let's assume you haven't obtained a mixer, and your program is a simple one that really only needs a certain kind of line; the details of the mixer don't matter to you. You can use the AudioSystem method:\r\n\r\nstatic Line getLine(Line.Info info)\r\n\r\nwhich is analogous to the getMixer method discussed previously. Unlike \r\nMixer.Info , the \r\nLine.Info used as an argument doesn't store textual information to specify the desired line. Instead, it stores information about the class of line desired.\r\n Line.Info is an abstract class, so you use one of its subclasses ( \r\nPort.Info or \r\nDataLine.Info ) to obtain a line. The following code excerpt uses the DataLine.Info subclass to obtain and open a target data line:\r\n\r\nTargetDataLine line;\r\nDataLine.Info info = new DataLine.Info(TargetDataLine.class, \r\n    format); // format is an AudioFormat object\r\nif (!AudioSystem.isLineSupported(info)) {\r\n    // Handle the error.\r\n    }\r\n    // Obtain and open the line.\r\ntry {\r\n    line = (TargetDataLine) AudioSystem.getLine(info);\r\n    line.open(format);\r\n} catch (LineUnavailableException ex) {\r\n        // Handle the error.\r\n    //... \r\n}\r\n\r\nThis code obtains a \r\nTargetDataLine object without specifying any attributes other than its class and its audio format. You can use analogous code to obtain other kinds of lines. For a SourceDataLine or a Clip, just substitute that class for TargetDataLine as the class of the line variable, and also in the first argument to the DataLine.Info constructor.\r\n For a Port, you can use static instances of Port.Info, in code like the following:\r\n\r\nif (AudioSystem.isLineSupported(Port.Info.MICROPHONE)) {\r\n    try {\r\n        line = (Port) AudioSystem.getLine(\r\n            Port.Info.MICROPHONE);\r\n    }\r\n}\r\n\r\nNote the use of the method isLineSupported to see whether the mixer even has a line of the desired type.\r\n Recall that a source line is an input to a mixer, namely, a Port object if the mixer represents an audio-input device, and a SourceDataLine or Clip object if the mixer represents an audio-output device. Similarly, a target line is an output of the mixer: a Port object for an audio-output mixer, and a TargetDataLine object for an audio-input mixer. What if a mixer doesn't connect to any external hardware device at all? For example, consider an internal or software-only mixer that gets audio from an application program and delivers its mixed audio back to the program. This kind of mixer has SourceDataLine or Clip objects for its input lines and TargetDataLine objects for its output lines.\r\n You can also use the following AudioSystem methods to learn more about source and target lines of a specified type that are supported by any installed mixer:\r\n\r\nstatic Line.Info[] getSourceLineInfo(Line.Info info)\r\nstatic Line.Info[] getTargetLineInfo(Line.Info info)\r\n\r\nNote that the array returned by each of these methods indicates unique types of lines, not necessarily all the lines. For example, if two of a mixer's lines, or two lines of different mixers, have identical Line.Info objects, the two lines will represented by only one Line.Info in the returned array. \r\nGetting a Line from a Mixer\r\n The Mixer interface includes variations on the AudioSystem access methods for source and target lines, described above. These Mixer methods include ones that take Line.Info arguments, just as AudioSystem's methods do. However, Mixer also includes these variants, which take no arguments:\r\n\r\nLine.Info[] getSourceLineInfo()\r\nLine.Info[] getTargetLineInfo()\r\n\r\nThese methods return arrays of all the Line.Info objects for the particular mixer. Once you've obtained the arrays, you can iterate over them, calling Mixer's getLine method to obtain each line, followed by Line's open method to reserve use of each line for your program. \r\nSelecting Input and Output Ports\r\n The previous section, regarding how to obtain a line of a desired type, applies to ports as well as other types of lines. You can obtain all of the source (i.e., input) and target (i.e, output) ports by passing a Port.Info object to the AudioSystem (or Mixer) methods getSourceLineInfo and getTargetLineInfo that take a Line.Info argument. You then iterate over the returned array of objects and invoke Mixer's getLine method to get each port.\r\n You can then open each Port by invoking Line's open method. Opening a port means you turn it onÃ¢Â\u20acÂ\u201dthat is, you allow sound to come in or out the port. Similarly, you can close ports that you don't want sound to travel through, because some ports might already be open before you even obtain them. Some platforms leave all ports on by default; or a user or system administrator might have selected certain ports to be on or off, using another application program or operating-system software.\r\n Warning: If you want to select a certain port and make sure that the sound is actually going in or out the port, you can open the port as described. However, this can be considered user-hostile behavior! For example, a user might have the speaker port turned off so as not to disturb her co-workers. She would be rather upset if your program suddenly overrode her wishes and started blaring music. As another example, a user might want to be assured that his computer's microphone is never turned on without his knowledge, to avoid eavesdropping. In general, it is recommended not to open or close ports unless your program is responding to the user's intentions, as expressed through the user interface. Instead, respect the settings that the user or the operating system has already selected.\r\n It isn't necessary to open or close a port before the mixer it's attached to will function correctly. For example, you can start playing back sound into an audio-output mixer, even though all its output ports are closed. The data still flows into the mixer; the playback isn't blocked. The user just won't hear anything. As soon as the user opens an output port, the sound will be audible through that port, starting at whatever point in the media the playback has already reached.\r\n Also, you don't need to access the ports to learn whether the mixer has certain ports. To learn whether a mixer is actually an audio-output mixer, for example, you can invoke getTargetLineInfo to see whether it has output ports. There's no reason to access the ports themselves unless you want to change their settings (such as their open-or-closed state, or the settings of any controls they might have).\r\n\r\nPermission to Use Audio Resources\r\n The Java Sound API includes an \r\nAudioPermission class that indicates what kinds of access an applet (or an application running with a security manager) can have to the sampled-audio system. Permission to record sound is controlled separately. This permission should be granted with care, to help prevent security risks such as unauthorized eavesdropping. By default, applets and applications are granted permissions as follows:\r\n\r\nAn applet running with the applet security manager can play, but not record, audio.\r\nAn application running with no security manager can both play and record audio.\r\nAn application running with the default security manager can play, but not record, audio.\r\n\r\nIn general, applets are run under the scrutiny of a security manager and aren't permitted to record sound. Applications, on the other hand, don't automatically install a security manager, and are able to record sound. (However, if the default security manager is invoked explicitly for an application, the application isn't permitted to record sound.)\r\n Both applets and applications can record sound even when running with a security manager if they have been granted explicit permission to do so.\r\n If your program doesn't have permission to record (or play) sound, an exception will be thrown when it attempts to open a line. There is nothing you can do about this in your program, other than to catch the exception and report the problem to the user, because permissions can't be changed through the API. (If they could, they would be pointless, because nothing would be secure!) Generally, permissions are set in one or more policy configuration files, which a user or system administrator can edit using a text editor or the Policy Tool program.\r\n",
        "title": "Oracle_Accessing Audio System Resources.txt",
        "type": "Oracle_"
    }]
}

post5_rec = {
    "response": [{
        "rank": 1,
        "text": "\r\n\r\nInstance Methods\r\nAn instance method in a subclass with the same signature (name, plus the number and the type of its parameters) and return type as an instance method in the superclass overrides the superclass's method.\r\nThe ability of a subclass to override a method allows a class to inherit from a superclass whose behavior is \"close enough\" and then to modify behavior as needed. The overriding method has the same name, number and type of parameters, and return type as the method that it overrides. An overriding method can also return a subtype of the type returned by the overridden method. This subtype is called a covariant return type.\r\nWhen overriding a method, you might want to use the @Override annotation that instructs the compiler that you intend to override a method in the superclass. If, for some reason, the compiler detects that the method does not exist in one of the superclasses, then it will generate an error. For more information on @Override, see \r\nAnnotations.\r\nStatic Methods\r\nIf a subclass defines a static method with the same signature as a static method in the superclass, then the method in the subclass hides the one in the superclass.\r\nThe distinction between hiding a static method and overriding an instance method has important implications:\r\n\r\nThe version of the overridden instance method that gets invoked is the one in the subclass.\r\nThe version of the hidden static method that gets invoked depends on whether it is invoked from the superclass or the subclass.\r\n\r\nConsider an example that contains two classes. The first is Animal, which contains one instance method and one static method:\r\n\r\npublic class Animal {\r\n    public static void testClassMethod() {\r\n        System.out.println(\"The static method in Animal\");\r\n    }\r\n    public void testInstanceMethod() {\r\n        System.out.println(\"The instance method in Animal\");\r\n    }\r\n}\r\n\r\nThe second class, a subclass of Animal, is called Cat:\r\n\r\npublic class Cat extends Animal {\r\n    public static void testClassMethod() {\r\n        System.out.println(\"The static method in Cat\");\r\n    }\r\n    public void testInstanceMethod() {\r\n        System.out.println(\"The instance method in Cat\");\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Cat myCat = new Cat();\r\n        Animal myAnimal = myCat;\r\n        Animal.testClassMethod();\r\n        myAnimal.testInstanceMethod();\r\n    }\r\n}\r\n\r\nThe Cat class overrides the instance method in Animal and hides the static method in Animal. The main method in this class creates an instance of Cat and invokes testClassMethod() on the class and testInstanceMethod() on the instance.\r\nThe output from this program is as follows:\r\n\r\nThe static method in Animal\r\nThe instance method in Cat\r\n\r\nAs promised, the version of the hidden static method that gets invoked is the one in the superclass, and the version of the overridden instance method that gets invoked is the one in the subclass.\r\n\r\nInterface Methods\r\n\r\nDefault methods and \r\nabstract methods in interfaces are inherited like instance methods. However, when the supertypes of a class or interface provide multiple default methods with the same signature, the Java compiler follows inheritance rules to resolve the name conflict. These rules are driven by the following two principles:\r\n\r\n\r\nInstance methods are preferred over interface default methods.\r\nConsider the following classes and interfaces:\r\npublic class Horse {\r\n    public String identifyMyself() {\r\n        return \"I am a horse.\";\r\n    }\r\n}\r\npublic interface Flyer {\r\n    default public String identifyMyself() {\r\n        return \"I am able to fly.\";\r\n    }\r\n}\r\npublic interface Mythical {\r\n    default public String identifyMyself() {\r\n        return \"I am a mythical creature.\";\r\n    }\r\n}\r\npublic class Pegasus extends Horse implements Flyer, Mythical {\r\n    public static void main(String... args) {\r\n        Pegasus myApp = new Pegasus();\r\n        System.out.println(myApp.identifyMyself());\r\n    }\r\n}\r\nThe method Pegasus.identifyMyself returns the string I am a horse.\r\n\r\nMethods that are already overridden by other candidates are ignored. This circumstance can arise when supertypes share a common ancestor.\r\nConsider the following interfaces and classes:\r\npublic interface Animal {\r\n    default public String identifyMyself() {\r\n        return \"I am an animal.\";\r\n    }\r\n}\r\npublic interface EggLayer extends Animal {\r\n    default public String identifyMyself() {\r\n        return \"I am able to lay eggs.\";\r\n    }\r\n}\r\npublic interface FireBreather extends Animal { }\r\npublic class Dragon implements EggLayer, FireBreather {\r\n    public static void main (String... args) {\r\n        Dragon myApp = new Dragon();\r\n        System.out.println(myApp.identifyMyself());\r\n    }\r\n}\r\nThe method Dragon.identifyMyself returns the string I am able to lay eggs.\r\n\r\n\r\nIf two or more independently defined default methods conflict, or a default method conflicts with an abstract method, then the Java compiler produces a compiler error. You must explicitly override the supertype methods.\r\nConsider the example about computer-controlled cars that can now fly. You have two interfaces (OperateCar and FlyCar) that provide default implementations for the same method, (startEngine):\r\npublic interface OperateCar {\r\n    // ...\r\n    default public int startEngine(EncryptedKey key) {\r\n        // Implementation\r\n    }\r\n}\r\npublic interface FlyCar {\r\n    // ...\r\n    default public int startEngine(EncryptedKey key) {\r\n        // Implementation\r\n    }\r\n}\r\nA class that implements both OperateCar and FlyCar must override the method startEngine. You could invoke any of the of the default implementations with the super keyword.\r\npublic class FlyingCar implements OperateCar, FlyCar {\r\n    // ...\r\n    public int startEngine(EncryptedKey key) {\r\n        FlyCar.super.startEngine(key);\r\n        OperateCar.super.startEngine(key);\r\n    }\r\n}\r\nThe name preceding super (in this example, FlyCar or OperateCar) must refer to a direct superinterface that defines or inherits a default for the invoked method. This form of method invocation is not restricted to differentiating between multiple implemented interfaces that contain default methods with the same signature. You can use the super keyword to invoke a default method in both classes and interfaces.\r\nInherited instance methods from classes can override abstract interface methods. Consider the following interfaces and classes:\r\n\r\npublic interface Mammal {\r\n    String identifyMyself();\r\n}\r\n\r\n\r\npublic class Horse {\r\n    public String identifyMyself() {\r\n        return \"I am a horse.\";\r\n    }\r\n}\r\n\r\n\r\npublic class Mustang extends Horse implements Mammal {\r\n    public static void main(String... args) {\r\n        Mustang myApp = new Mustang();\r\n        System.out.println(myApp.identifyMyself());\r\n    }\r\n}\r\n\r\nThe method Mustang.identifyMyself returns the string I am a horse. The class Mustang inherits the method identifyMyself from the class Horse, which overrides the abstract method of the same name in the interface Mammal.\r\nNote: Static methods in interfaces are never inherited.\r\nModifiers\r\nThe access specifier for an overriding method can allow more, but not less, access than the overridden method. For example, a protected instance method in the superclass can be made public, but not private, in the subclass.\r\nYou will get a compile-time error if you attempt to change an instance method in the superclass to a static method in the subclass, and vice versa.\r\nSummary\r\n\r\nThe following table summarizes what happens when you define a method with the same signature as a method in a superclass.\r\n\r\nDefining a Method with the Same Signature as a Superclass's Method\r\n\r\nÂ \r\nSuperclass Instance Method\r\nSuperclass Static Method\r\n\r\n\r\nSubclass Instance Method\r\nOverrides\r\nGenerates a compile-time error\r\n\r\n\r\nSubclass Static Method\r\nGenerates a compile-time error\r\nHides\r\n\r\n\r\nNote:Â In a subclass, you can overload the methods inherited from the superclass. Such overloaded methods neither hide nor override the superclass instance methodsâ\u20ac\u201dthey are new methods, unique to the subclass.\r\n\r\n",
        "title": "Oracle_Overriding and Hiding Methods.txt",
        "type": "Oracle_"
    }, {
        "rank": 2,
        "text": "\r\nThere are two categories of methods provided in \r\nClass for accessing fields, methods, and constructors: methods which enumerate these members and methods which search for particular members. Also there are distinct methods for accessing members declared directly on the class versus methods which search the superinterfaces and superclasses for inherited members. The following tables provide a summary of all the member-locating methods and their characteristics.\r\n\r\n\r\nClass Methods for Locating Fields\r\n\r\n\r\nClass API\r\nList of members?\r\nInherited members?\r\nPrivate members? \r\n\r\n\r\n\r\ngetDeclaredField()\r\nno\r\nno\r\nyes\r\n\r\n\r\n\r\ngetField()\r\nno\r\nyes\r\nno\r\n\r\n\r\n\r\ngetDeclaredFields()\r\nyes\r\nno\r\nyes\r\n\r\n\r\n\r\ngetFields()\r\nyes\r\nyes\r\nno\r\n\r\n\r\n\r\n\r\n\r\nClass Methods for Locating Methods\r\n\r\n\r\nClass API\r\nList of members?\r\nInherited members?\r\nPrivate members?\r\n\r\n\r\n\r\ngetDeclaredMethod()\r\nno\r\nno\r\nyes\r\n\r\n\r\n\r\ngetMethod()\r\nno\r\nyes\r\nno\r\n\r\n\r\n\r\ngetDeclaredMethods()\r\nyes\r\nno\r\nyes\r\n\r\n\r\n\r\ngetMethods()\r\nyes\r\nyes\r\nno\r\n\r\n\r\n\r\n\r\n\r\nClass Methods for Locating Constructors\r\n\r\n\r\nClass API\r\nList of members?\r\nInherited members?\r\nPrivate members?\r\n\r\n\r\n\r\ngetDeclaredConstructor()\r\nno\r\nN/A1\r\nyes\r\n\r\n\r\n\r\ngetConstructor()\r\nno\r\nN/A1\r\nno\r\n\r\n\r\n\r\ngetDeclaredConstructors()\r\nyes\r\nN/A1\r\nyes\r\n\r\n\r\n\r\ngetConstructors()\r\nyes\r\nN/A1\r\nno\r\n\r\n\r\n1 Constructors are not inherited.\r\nGiven a class name and an indication of which members are of interest, the \r\nClassSpy example uses the get*s() methods to determine the list of all public elements, including any which are inherited.\r\n\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Member;\r\nimport static java.lang.System.out;\r\n\r\nenum ClassMember { CONSTRUCTOR, FIELD, METHOD, CLASS, ALL }\r\n\r\npublic class ClassSpy {\r\n    public static void main(String... args) {\r\n\ttry {\r\n\t    Class<?> c = Class.forName(args[0]);\r\n\t    out.format(\"Class:%n  %s%n%n\", c.getCanonicalName());\r\n\r\n\t    Package p = c.getPackage();\r\n\t    out.format(\"Package:%n  %s%n%n\",\r\n\t\t       (p != null ? p.getName() : \"-- No Package --\"));\r\n\r\n\t    for (int i = 1; i < args.length; i++) {\r\n\t\tswitch (ClassMember.valueOf(args[i])) {\r\n\t\tcase CONSTRUCTOR:\r\n\t\t    printMembers(c.getConstructors(), \"Constructor\");\r\n\t\t    break;\r\n\t\tcase FIELD:\r\n\t\t    printMembers(c.getFields(), \"Fields\");\r\n\t\t    break;\r\n\t\tcase METHOD:\r\n\t\t    printMembers(c.getMethods(), \"Methods\");\r\n\t\t    break;\r\n\t\tcase CLASS:\r\n\t\t    printClasses(c);\r\n\t\t    break;\r\n\t\tcase ALL:\r\n\t\t    printMembers(c.getConstructors(), \"Constuctors\");\r\n\t\t    printMembers(c.getFields(), \"Fields\");\r\n\t\t    printMembers(c.getMethods(), \"Methods\");\r\n\t\t    printClasses(c);\r\n\t\t    break;\r\n\t\tdefault:\r\n\t\t    assert false;\r\n\t\t}\r\n\t    }\r\n\r\n        // production code should handle these exceptions more gracefully\r\n\t} catch (ClassNotFoundException x) {\r\n\t    x.printStackTrace();\r\n\t}\r\n    }\r\n\r\n    private static void printMembers(Member[] mbrs, String s) {\r\n\tout.format(\"%s:%n\", s);\r\n\tfor (Member mbr : mbrs) {\r\n\t    if (mbr instanceof Field)\r\n\t\tout.format(\"  %s%n\", ((Field)mbr).toGenericString());\r\n\t    else if (mbr instanceof Constructor)\r\n\t\tout.format(\"  %s%n\", ((Constructor)mbr).toGenericString());\r\n\t    else if (mbr instanceof Method)\r\n\t\tout.format(\"  %s%n\", ((Method)mbr).toGenericString());\r\n\t}\r\n\tif (mbrs.length == 0)\r\n\t    out.format(\"  -- No %s --%n\", s);\r\n\tout.format(\"%n\");\r\n    }\r\n\r\n    private static void printClasses(Class<?> c) {\r\n\tout.format(\"Classes:%n\");\r\n\tClass<?>[] clss = c.getClasses();\r\n\tfor (Class<?> cls : clss)\r\n\t    out.format(\"  %s%n\", cls.getCanonicalName());\r\n\tif (clss.length == 0)\r\n\t    out.format(\"  -- No member interfaces, classes, or enums --%n\");\r\n\tout.format(\"%n\");\r\n    }\r\n}\r\n\r\nThis example is relatively compact; however the printMembers() method is slightly awkward due to the fact that the \r\njava.lang.reflect.Member interface has existed since the earliest implementations of reflection and it could not be modified to include the more useful getGenericString() method when generics were introduced. The only alternatives are to test and cast as shown, replace this method with printConstructors(), printFields(), and printMethods(), or to be satisfied with the relatively spare results of \r\nMember.getName().\r\nSamples of the output and their interpretation follows. User input is in italics.\r\n\r\n$ java ClassSpy java.lang.ClassCastException CONSTRUCTOR\r\nClass:\r\n  java.lang.ClassCastException\r\n\r\nPackage:\r\n  java.lang\r\n\r\nConstructor:\r\n  public java.lang.ClassCastException()\r\n  public java.lang.ClassCastException(java.lang.String)\r\n\r\nSince constructors are not inherited, the exception chaining mechanism constructors (those with a \r\nThrowable parameter) which are defined in the immediate super class \r\nRuntimeException and other super classes are not found.\r\n\r\n$ java ClassSpy java.nio.channels.ReadableByteChannel METHOD\r\nClass:\r\n  java.nio.channels.ReadableByteChannel\r\n\r\nPackage:\r\n  java.nio.channels\r\n\r\nMethods:\r\n  public abstract int java.nio.channels.ReadableByteChannel.read\r\n    (java.nio.ByteBuffer) throws java.io.IOException\r\n  public abstract void java.nio.channels.Channel.close() throws\r\n    java.io.IOException\r\n  public abstract boolean java.nio.channels.Channel.isOpen()\r\n\r\nThe interface \r\njava.nio.channels.ReadableByteChannel defines \r\nread(). The remaining methods are inherited from a super interface. This code could easily be modified to list only those methods that are actually declared in the class by replacing get*s() with getDeclared*s().\r\n\r\n$ java ClassSpy ClassMember FIELD METHOD\r\nClass:\r\n  ClassMember\r\n\r\nPackage:\r\n  -- No Package --\r\n\r\nFields:\r\n  public static final ClassMember ClassMember.CONSTRUCTOR\r\n  public static final ClassMember ClassMember.FIELD\r\n  public static final ClassMember ClassMember.METHOD\r\n  public static final ClassMember ClassMember.CLASS\r\n  public static final ClassMember ClassMember.ALL\r\n\r\nMethods:\r\n  public static ClassMember ClassMember.valueOf(java.lang.String)\r\n  public static ClassMember[] ClassMember.values()\r\n  public final int java.lang.Enum.hashCode()\r\n  public final int java.lang.Enum.compareTo(E)\r\n  public int java.lang.Enum.compareTo(java.lang.Object)\r\n  public final java.lang.String java.lang.Enum.name()\r\n  public final boolean java.lang.Enum.equals(java.lang.Object)\r\n  public java.lang.String java.lang.Enum.toString()\r\n  public static <T> T java.lang.Enum.valueOf\r\n    (java.lang.Class<T>,java.lang.String)\r\n  public final java.lang.Class<E> java.lang.Enum.getDeclaringClass()\r\n  public final int java.lang.Enum.ordinal()\r\n  public final native java.lang.Class<?> java.lang.Object.getClass()\r\n  public final native void java.lang.Object.wait(long) throws\r\n    java.lang.InterruptedException\r\n  public final void java.lang.Object.wait(long,int) throws\r\n    java.lang.InterruptedException\r\n  public final void java.lang.Object.wait() hrows java.lang.InterruptedException\r\n  public final native void java.lang.Object.notify()\r\n  public final native void java.lang.Object.notifyAll()\r\n\r\nIn the fields portion of these results, enum constants are listed. While these are technically fields, it might be useful to distinguish them from other fields. This example could be modified to use \r\njava.lang.reflect.Field.isEnumConstant() for this purpose. The \r\nEnumSpy example in a later section of this trail, Examining Enums, contains a possible implementation.\r\nIn the methods section of the output, observe that the method name includes the name of the declaring class. Thus, the toString() method is implemented by \r\nEnum, not inherited from \r\nObject. The code could be amended to make this more obvious by using \r\nField.getDeclaringClass(). The following fragment illustrates part of a potential solution.\r\n\r\nif (mbr instanceof Field) {\r\n    Field f = (Field)mbr;\r\n    out.format(\"  %s%n\", f.toGenericString());\r\n    out.format(\"  -- declared in: %s%n\", f.getDeclaringClass());\r\n}\r\n\r\n",
        "title": "Oracle_Discovering Class Members.txt",
        "type": "Oracle_"
    }, {
        "rank": 3,
        "text": "\r\nThe section\r\nInterfaces describes an example that involves manufacturers of computer-controlled cars who publish industry-standard interfaces that describe which methods can be invoked to operate their cars. What if those computer-controlled car manufacturers add new functionality, such as flight, to their cars? These manufacturers would need to specify new methods to enable other companies (such as electronic guidance instrument manufacturers) to adapt their software to flying cars. Where would these car manufacturers declare these new flight-related methods? If they add them to their original interfaces, then programmers who have implemented those interfaces would have to rewrite their implementations. If they add them as static methods, then programmers would regard them as utility methods, not as essential, core methods.\r\nDefault methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces.\r\nConsider the following interface,\r\nTimeClient, as described in\r\nAnswers to Questions and Exercises: Interfaces:\r\n\r\n\r\nimport java.time.*; \r\n \r\npublic interface TimeClient {\r\n    void setTime(int hour, int minute, int second);\r\n    void setDate(int day, int month, int year);\r\n    void setDateAndTime(int day, int month, int year,\r\n                               int hour, int minute, int second);\r\n    LocalDateTime getLocalDateTime();\r\n}\r\n\r\nThe following class,\r\nSimpleTimeClient, implements TimeClient:\r\n\r\n\r\npackage defaultmethods;\r\n\r\nimport java.time.*;\r\nimport java.lang.*;\r\nimport java.util.*;\r\n\r\npublic class SimpleTimeClient implements TimeClient {\r\n    \r\n    private LocalDateTime dateAndTime;\r\n    \r\n    public SimpleTimeClient() {\r\n        dateAndTime = LocalDateTime.now();\r\n    }\r\n    \r\n    public void setTime(int hour, int minute, int second) {\r\n        LocalDate currentDate = LocalDate.from(dateAndTime);\r\n        LocalTime timeToSet = LocalTime.of(hour, minute, second);\r\n        dateAndTime = LocalDateTime.of(currentDate, timeToSet);\r\n    }\r\n    \r\n    public void setDate(int day, int month, int year) {\r\n        LocalDate dateToSet = LocalDate.of(day, month, year);\r\n        LocalTime currentTime = LocalTime.from(dateAndTime);\r\n        dateAndTime = LocalDateTime.of(dateToSet, currentTime);\r\n    }\r\n    \r\n    public void setDateAndTime(int day, int month, int year,\r\n                               int hour, int minute, int second) {\r\n        LocalDate dateToSet = LocalDate.of(day, month, year);\r\n        LocalTime timeToSet = LocalTime.of(hour, minute, second); \r\n        dateAndTime = LocalDateTime.of(dateToSet, timeToSet);\r\n    }\r\n    \r\n    public LocalDateTime getLocalDateTime() {\r\n        return dateAndTime;\r\n    }\r\n    \r\n    public String toString() {\r\n        return dateAndTime.toString();\r\n    }\r\n    \r\n    public static void main(String... args) {\r\n        TimeClient myTimeClient = new SimpleTimeClient();\r\n        System.out.println(myTimeClient.toString());\r\n    }\r\n}\r\n\r\nSuppose that you want to add new functionality to the TimeClient interface, such as the ability to specify a time zone through a\r\nZonedDateTime object (which is like a\r\nLocalDateTime object except that it stores time zone information):\r\n\r\npublic interface TimeClient {\r\n    void setTime(int hour, int minute, int second);\r\n    void setDate(int day, int month, int year);\r\n    void setDateAndTime(int day, int month, int year,\r\n        int hour, int minute, int second);\r\n    LocalDateTime getLocalDateTime();                           \r\n    ZonedDateTime getZonedDateTime(String zoneString);\r\n}\r\n\r\nFollowing this modification to the TimeClient interface, you would also have to modify the class SimpleTimeClient and implement the method getZonedDateTime. However, rather than leaving getZonedDateTime as abstract (as in the previous example), you can instead define a default implementation. (Remember that an\r\nabstract method is a method declared without an implementation.)\r\n\r\n\r\npackage defaultmethods;\r\n \r\nimport java.time.*;\r\n\r\npublic interface TimeClient {\r\n    void setTime(int hour, int minute, int second);\r\n    void setDate(int day, int month, int year);\r\n    void setDateAndTime(int day, int month, int year,\r\n                               int hour, int minute, int second);\r\n    LocalDateTime getLocalDateTime();\r\n    \r\n    static ZoneId getZoneId (String zoneString) {\r\n        try {\r\n            return ZoneId.of(zoneString);\r\n        } catch (DateTimeException e) {\r\n            System.err.println(\"Invalid time zone: \" + zoneString +\r\n                \"; using default time zone instead.\");\r\n            return ZoneId.systemDefault();\r\n        }\r\n    }\r\n        \r\n    default ZonedDateTime getZonedDateTime(String zoneString) {\r\n        return ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString));\r\n    }\r\n}\r\n\r\nYou specify that a method definition in an interface is a default method with the default keyword at the beginning of the method signature. All method declarations in an interface, including default methods, are implicitly public, so you can omit the public modifier.\r\nWith this interface, you do not have to modify the class SimpleTimeClient, and this class (and any class that implements the interface TimeClient), will have the method getZonedDateTime already defined. The following example,\r\nTestSimpleTimeClient, invokes the method getZonedDateTime from an instance of SimpleTimeClient:\r\n\r\n\r\npackage defaultmethods;\r\n \r\nimport java.time.*;\r\nimport java.lang.*;\r\nimport java.util.*;\r\n\r\npublic class TestSimpleTimeClient {\r\n    public static void main(String... args) {\r\n        TimeClient myTimeClient = new SimpleTimeClient();\r\n        System.out.println(\"Current time: \" + myTimeClient.toString());\r\n        System.out.println(\"Time in California: \" +\r\n            myTimeClient.getZonedDateTime(\"Blah blah\").toString());\r\n    }\r\n}\r\n\r\n\r\nExtending Interfaces That Contain Default Methods\r\nWhen you extend an interface that contains a default method, you can do the following:\r\n\r\nNot mention the default method at all, which lets your extended interface inherit the default method.\r\nRedeclare the default method, which makes it abstract.\r\nRedefine the default method, which overrides it.\r\n\r\nSuppose that you extend the interface TimeClient as follows:\r\n\r\npublic interface AnotherTimeClient extends TimeClient { }\r\n\r\nAny class that implements the interface AnotherTimeClient will have the implementation specified by the default method TimeClient.getZonedDateTime.\r\nSuppose that you extend the interface TimeClient as follows:\r\n\r\npublic interface AbstractZoneTimeClient extends TimeClient {\r\n    public ZonedDateTime getZonedDateTime(String zoneString);\r\n}\r\n\r\nAny class that implements the interface AbstractZoneTimeClient will have to implement the method getZonedDateTime; this method is an abstract method like all other nondefault (and nonstatic) methods in an interface.\r\nSuppose that you extend the interface TimeClient as follows:\r\n\r\npublic interface HandleInvalidTimeZoneClient extends TimeClient {\r\n    default public ZonedDateTime getZonedDateTime(String zoneString) {\r\n        try {\r\n            return ZonedDateTime.of(getLocalDateTime(),ZoneId.of(zoneString)); \r\n        } catch (DateTimeException e) {\r\n            System.err.println(\"Invalid zone ID: \" + zoneString +\r\n                \"; using the default time zone instead.\");\r\n            return ZonedDateTime.of(getLocalDateTime(),ZoneId.systemDefault());\r\n        }\r\n    }\r\n}\r\n\r\nAny class that implements the interface HandleInvalidTimeZoneClient will use the implementation of getZonedDateTime specified by this interface instead of the one specified by the interface TimeClient.\r\n\r\nStatic Methods\r\nIn addition to default methods, you can define\r\nstatic methods  in interfaces. (A static method is a method that is associated with the class in which it is defined rather than with any object. Every instance of the class shares its static methods.) This makes it easier for you to organize helper methods in your libraries; you can keep static methods specific to an interface in the same interface rather than in a separate class. The following example defines a static method that retrieves a\r\nZoneId object corresponding to a time zone identifier; it uses the system default time zone if there is no ZoneId object corresponding to the given identifier. (As a result, you can simplify the method getZonedDateTime):\r\n\r\npublic interface TimeClient {\r\n    // ...\r\n    static public ZoneId getZoneId (String zoneString) {\r\n        try {\r\n            return ZoneId.of(zoneString);\r\n        } catch (DateTimeException e) {\r\n            System.err.println(\"Invalid time zone: \" + zoneString +\r\n                \"; using default time zone instead.\");\r\n            return ZoneId.systemDefault();\r\n        }\r\n    }\r\n\r\n    default public ZonedDateTime getZonedDateTime(String zoneString) {\r\n        return ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString));\r\n    }    \r\n}\r\n\r\nLike static methods in classes, you specify that a method definition in an interface is a static method with the static keyword at the beginning of the method signature. All method declarations in an interface, including static methods, are implicitly public, so you can omit the public modifier.\r\n\r\nIntegrating Default Methods into Existing Libraries\r\nDefault methods enable you to add new functionality to existing interfaces and ensure binary compatibility with code written for older versions of those interfaces. In particular, default methods enable you to add methods that accept lambda expressions as parameters to existing interfaces. This section demonstrates how the\r\nComparator interface has been enhanced with default and static methods.\r\nConsider the Card and Deck classes as described in\r\nQuestions and Exercises: Classes. This example rewrites the\r\nCard and \r\nDeck classes as interfaces. The Card interface contains two enum types (Suit and Rank) and two abstract methods (getSuit and getRank):\r\n\r\n\r\npackage defaultmethods;\r\n\r\npublic interface Card extends Comparable<Card> {\r\n    \r\n    public enum Suit { \r\n        DIAMONDS (1, \"Diamonds\"), \r\n        CLUBS    (2, \"Clubs\"   ), \r\n        HEARTS   (3, \"Hearts\"  ), \r\n        SPADES   (4, \"Spades\"  );\r\n        \r\n        private final int value;\r\n        private final String text;\r\n        Suit(int value, String text) {\r\n            this.value = value;\r\n            this.text = text;\r\n        }\r\n        public int value() {return value;}\r\n        public String text() {return text;}\r\n    }\r\n    \r\n    public enum Rank { \r\n        DEUCE  (2 , \"Two\"  ),\r\n        THREE  (3 , \"Three\"), \r\n        FOUR   (4 , \"Four\" ), \r\n        FIVE   (5 , \"Five\" ), \r\n        SIX    (6 , \"Six\"  ), \r\n        SEVEN  (7 , \"Seven\"),\r\n        EIGHT  (8 , \"Eight\"), \r\n        NINE   (9 , \"Nine\" ), \r\n        TEN    (10, \"Ten\"  ), \r\n        JACK   (11, \"Jack\" ),\r\n        QUEEN  (12, \"Queen\"), \r\n        KING   (13, \"King\" ),\r\n        ACE    (14, \"Ace\"  );\r\n        private final int value;\r\n        private final String text;\r\n        Rank(int value, String text) {\r\n            this.value = value;\r\n            this.text = text;\r\n        }\r\n        public int value() {return value;}\r\n        public String text() {return text;}\r\n    }\r\n    \r\n    public Card.Suit getSuit();\r\n    public Card.Rank getRank();\r\n}\r\n\r\nThe Deck interface contains various methods that manipulate cards in a deck:\r\n\r\n\r\npackage defaultmethods; \r\n \r\nimport java.util.*;\r\nimport java.util.stream.*;\r\nimport java.lang.*;\r\n \r\npublic interface Deck {\r\n    \r\n    List<Card> getCards();\r\n    Deck deckFactory();\r\n    int size();\r\n    void addCard(Card card);\r\n    void addCards(List<Card> cards);\r\n    void addDeck(Deck deck);\r\n    void shuffle();\r\n    void sort();\r\n    void sort(Comparator<Card> c);\r\n    String deckToString();\r\n\r\n    Map<Integer, Deck> deal(int players, int numberOfCards)\r\n        throws IllegalArgumentException;\r\n\r\n}\r\n\r\nThe class\r\nPlayingCard implements the interface Card, and the class\r\nStandardDeck implements the interface Deck.\r\nThe class StandardDeck implements the abstract method Deck.sort as follows:\r\n\r\npublic class StandardDeck implements Deck {\r\n    \r\n    private List<Card> entireDeck;\r\n    \r\n    // ...\r\n    \r\n    public void sort() {\r\n        Collections.sort(entireDeck);\r\n    }\r\n    \r\n    // ...\r\n}\r\n\r\nThe method Collections.sort sorts an instance of List whose element type implements the interface\r\nComparable. The member entireDeck is an instance of List whose elements are of the type Card, which extends Comparable. The class PlayingCard implements the\r\nComparable.compareTo method as follows:\r\n\r\npublic int hashCode() {\r\n    return ((suit.value()-1)*13)+rank.value();\r\n}\r\n\r\npublic int compareTo(Card o) {\r\n    return this.hashCode() - o.hashCode();\r\n}\r\n\r\nThe method compareTo causes the method StandardDeck.sort() to sort the deck of cards first by suit, and then by rank.\r\nWhat if you want to sort the deck first by rank, then by suit? You would need to implement the\r\nComparator interface to specify new sorting criteria, and use the method\r\nsort(List<T> list, Comparator<? super T> c) (the version of the sort method that includes a Comparator parameter). You can define the following method in the class StandardDeck:\r\n\r\npublic void sort(Comparator<Card> c) {\r\n    Collections.sort(entireDeck, c);\r\n}  \r\n\r\nWith this method, you can specify how the method Collections.sort sorts instances of the Card class. One way to do this is to implement the Comparator interface to specify how you want the cards sorted. The example\r\nSortByRankThenSuit does this:\r\n\r\n\r\n\r\npackage defaultmethods;\r\n\r\nimport java.util.*;\r\nimport java.util.stream.*;\r\nimport java.lang.*;\r\n\r\npublic class SortByRankThenSuit implements Comparator<Card> {\r\n    public int compare(Card firstCard, Card secondCard) {\r\n        int compVal =\r\n            firstCard.getRank().value() - secondCard.getRank().value();\r\n        if (compVal != 0)\r\n            return compVal;\r\n        else\r\n            return firstCard.getSuit().value() - secondCard.getSuit().value(); \r\n    }\r\n}\r\n\r\nThe following invocation sorts the deck of playing cards first by rank, then by suit:\r\n\r\nStandardDeck myDeck = new StandardDeck();\r\nmyDeck.shuffle();\r\nmyDeck.sort(new SortByRankThenSuit());\r\n\r\nHowever, this approach is too verbose; it would be better if you could specify what you want to sort, not how you want to sort. Suppose that you are the developer who wrote the Comparator interface. What default or static methods could you add to the Comparator interface to enable other developers to more easily specify sort criteria?\r\nTo start, suppose that you want to sort the deck of playing cards by rank, regardless of suit. You can invoke the StandardDeck.sort method as follows:\r\n\r\nStandardDeck myDeck = new StandardDeck();\r\nmyDeck.shuffle();\r\nmyDeck.sort(\r\n    (firstCard, secondCard) ->\r\n        firstCard.getRank().value() - secondCard.getRank().value()\r\n); \r\n\r\nBecause the interface Comparator is a\r\nfunctional interface, you can use a lambda expression as an argument for the sort method. In this example, the lambda expression compares two integer values.\r\nIt would be simpler for your developers if they could create a Comparator instance by invoking the method Card.getRank only. In particular, it would be helpful if your developers could create a Comparator instance that compares any object that can return a numerical value from a method such as getValue or hashCode. The Comparator interface has been enhanced with this ability with the static method\r\ncomparing:\r\n\r\nmyDeck.sort(Comparator.comparing((card) -> card.getRank()));  \r\n\r\nIn this example, you can use a\r\nmethod reference instead:\r\n\r\nmyDeck.sort(Comparator.comparing(Card::getRank));  \r\n\r\nThis invocation better demonstrates what to sort rather than how to do it.\r\nThe Comparator interface has been enhanced with other versions of the static method comparing such as  \r\ncomparingDouble and\r\ncomparingLong that enable you to create Comparator instances that compare other data types.\r\nSuppose that your developers would like to create a Comparator instance that could compare objects with more than one criteria. For example, how would you sort the deck of playing cards first by rank, and then by suit? As before, you could use a lambda expression to specify these sort criteria:\r\n\r\nStandardDeck myDeck = new StandardDeck();\r\nmyDeck.shuffle();\r\nmyDeck.sort(\r\n    (firstCard, secondCard) -> {\r\n        int compare =\r\n            firstCard.getRank().value() - secondCard.getRank().value();\r\n        if (compare != 0)\r\n            return compare;\r\n        else\r\n            return firstCard.getSuit().value() - secondCard.getSuit().value();\r\n    }      \r\n); \r\n\r\nIt would be simpler for your developers if they could build a Comparator instance from a series of Comparator instances. The Comparator interface has been enhanced with this ability with the default method\r\nthenComparing:\r\n\r\nmyDeck.sort(\r\n    Comparator\r\n        .comparing(Card::getRank)\r\n        .thenComparing(Comparator.comparing(Card::getSuit)));\r\n\r\nThe Comparator interface has been enhanced with other versions of the default method thenComparing (such as  \r\nthenComparingDouble and\r\nthenComparingLong) that enable you to build Comparator instances that compare other data types.\r\nSuppose that your developers would like to create a Comparator instance that enables them to sort a collection of objects in reverse order. For example, how would you sort the deck of playing cards first by descending order of rank, from Ace to Two (instead of from Two to Ace)? As before, you could specify another lambda expression. However, it would be simpler for your developers if they could reverse an existing Comparator by invoking a method. The Comparator interface has been enhanced with this ability with the default method\r\nreversed:\r\n\r\nmyDeck.sort(\r\n    Comparator.comparing(Card::getRank)\r\n        .reversed()\r\n        .thenComparing(Comparator.comparing(Card::getSuit)));\r\n\r\nThis example demonstrates how the Comparator interface has been enhanced with default methods, static methods, lambda expressions, and method references to create more expressive library methods whose functionality programmers can quickly deduce by looking at how they are invoked. Use these constructs to enhance the interfaces in your libraries.\r\n",
        "title": "Oracle_Default Methods.txt",
        "type": "Oracle_"
    }, {
        "rank": 4,
        "text": "\r\nOne issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an interface that contains only one method, then the syntax of anonymous classes may seem unwieldy and unclear. In these cases, you're usually trying to pass functionality as an argument to another method, such as what action should be taken when someone clicks a button. Lambda expressions enable you to do this, to treat functionality as method argument, or code as data.\r\nThe previous section,\r\nAnonymous Classes, shows you how to implement a base class without giving it a name.\r\nAlthough this is often more concise than a named class, for classes\r\nwith only one method, even an anonymous class seems a bit\r\nexcessive and cumbersome. Lambda expressions let you express instances of\r\nsingle-method classes more compactly.\r\nThis section covers the following topics:\r\n\r\nIdeal Use Case for Lambda Expressions\r\n\r\nApproach 1: Create Methods That Search for Members That Match One Characteristic\r\nApproach 2: Create More Generalized Search Methods\r\nApproach 3: Specify Search Criteria Code in a Local Class\r\nApproach 4: Specify Search Criteria Code in an Anonymous Class\r\nApproach 5: Specify Search Criteria Code with a Lambda Expression\r\nApproach 6: Use Standard Functional Interfaces with Lambda Expressions\r\nApproach 7: Use Lambda Expressions Throughout Your Application\r\nApproach 8: Use Generics More Extensively\r\nApproach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters\r\n\r\n\r\nLambda Expressions in GUI Applications\r\nSyntax of Lambda Expressions\r\nAccessing Local Variables of the Enclosing Scope\r\nTarget Typing\r\n\r\nTarget Types and Method Arguments\r\n\r\n\r\nSerialization\r\n\r\nIdeal Use Case for Lambda Expressions\r\nSuppose that you are creating a social networking application. You\r\nwant to create a feature that enables an administrator to perform\r\nany kind of action, such as sending a message, on members of the\r\nsocial networking application that satisfy certain criteria. The following table describes this use case in detail:\r\n\r\n\r\nField\r\nDescription\r\n\r\n\r\nName\r\nPerform action on selected members\r\n\r\n\r\nPrimary Actor\r\nAdministrator\r\n\r\n\r\nPreconditions\r\nAdministrator is logged in to the system.\r\n\r\n\r\nPostconditions\r\nAction is performed only on members that fit the specified criteria.\r\n\r\n\r\nMain Success Scenario\r\n\r\n\r\nAdministrator specifies criteria of members on which to perform a certain action.\r\nAdministrator specifies an action to perform on those selected members.\r\nAdministrator selects the Submit button.\r\nThe system finds all members that match the specified criteria.\r\nThe system performs the specified action on all matching members.\r\n\r\n\r\n\r\n\r\nExtensions\r\n\r\n1a. Administrator has an option to preview those members who match the specified criteria before he or she specifies the action to be performed or before selecting the Submit button.\r\n\r\n\r\n\r\nFrequency of Occurrence\r\nMany times during the day.\r\n\r\n\r\nSuppose that members of this social networking application are\r\nrepresented by the following\r\nPerson class:\r\npublic class Person {\r\n\r\n    public enum Sex {\r\n        MALE, FEMALE\r\n    }\r\n\r\n    String name;\r\n    LocalDate birthday;\r\n    Sex gender;\r\n    String emailAddress;\r\n\r\n    public int getAge() {\r\n        // ...\r\n    }\r\n\r\n    public void printPerson() {\r\n        // ...\r\n    }\r\n}\r\nSuppose that the members of your social networking application\r\nare stored in a List<Person> instance.\r\nThis section begins with a naive approach to this use case. It improves upon this approach with local and anonymous classes, and then finishes with an efficient and concise approach using lambda expressions. Find the code excerpts described in this section in the example\r\nRosterTest.\r\n\r\nApproach 1: Create Methods That Search for Members That Match One Characteristic\r\nOne simplistic approach is to create several methods; each method searches for members that match one characteristic, such as gender or age. The following method prints members that are older than a specified\r\nage:\r\npublic static void printPersonsOlderThan(List<Person> roster, int age) {\r\n    for (Person p : roster) {\r\n        if (p.getAge() >= age) {\r\n            p.printPerson();\r\n        }\r\n    }\r\n}\r\nNote: A\r\nList is an ordered\r\nCollection. A collection is an object\r\nthat groups multiple elements into a single unit. Collections are\r\nused to store, retrieve, manipulate, and communicate aggregate\r\ndata. For more information about collections, see the\r\nCollections trail.\r\nThis approach can potentially make your application brittle, which is the likelihood of an application not working because of the introduction of updates (such as newer data types). Suppose that you upgrade your application and change the structure of the Person class such that it contains different member variables; perhaps the class records and measures ages with a different data type or algorithm. You would have to rewrite a lot of your API to accommodate this change. In addition, this approach is unnecessarily restrictive; what if you\r\nwanted to print members younger than a certain age, for example?\r\n\r\nApproach 2: Create More Generalized Search Methods\r\nThe following method is more generic than printPersonsOlderThan; it prints members within a specified range of ages:\r\npublic static void printPersonsWithinAgeRange(\r\n    List<Person> roster, int low, int high) {\r\n    for (Person p : roster) {\r\n        if (low <= p.getAge() && p.getAge() < high) {\r\n            p.printPerson();\r\n        }\r\n    }\r\n}\r\nWhat if you want to print members of a specified sex, or a combination of a specified gender and age range? What if you decide to change the Person class and add other attributes such as relationship status or geographical location? Although this method is more generic than printPersonsOlderThan, trying to create a separate method for each possible search query can still lead to brittle code. You can instead separate the code that specifies the criteria for which you want to search in a different class.\r\n\r\nApproach 3: Specify Search Criteria Code in a Local Class\r\nThe following method prints members that match search criteria that you specify:\r\npublic static void printPersons(\r\n    List<Person> roster, CheckPerson tester) {\r\n    for (Person p : roster) {\r\n        if (tester.test(p)) {\r\n            p.printPerson();\r\n        }\r\n    }\r\n}\r\nThis method checks each Person instance contained in the List parameter roster whether it satisfies the search criteria specified in the CheckPerson parameter tester by invoking the method tester.test. If the method tester.test returns a true value, then the method printPersons is invoked on the Person instance.\r\nTo specify the search criteria, you implement the\r\nCheckPerson interface:\r\ninterface CheckPerson {\r\n    boolean test(Person p);\r\n}\r\nThe following class implements the CheckPerson interface by specifying an implementation for the method test. This method filters members that are eligible for Selective Service in the United States: it returns a true value if its Person parameter is male and between the ages of 18 and 25:\r\nclass CheckPersonEligibleForSelectiveService implements CheckPerson {\r\n    public boolean test(Person p) {\r\n        return p.gender == Person.Sex.MALE &&\r\n            p.getAge() >= 18 &&\r\n            p.getAge() <= 25;\r\n    }\r\n}\r\nTo use this class, you create a new\r\ninstance of it and invoke the printPersons method:\r\nprintPersons(\r\n    roster, new CheckPersonEligibleForSelectiveService());\r\nAlthough this approach is less brittleâ\u20ac\u201dyou don't have to rewrite methods if you change the structure of the Personâ\u20ac\u201dyou still have additional code: a new interface and a local class for each search you plan to perform in your application. Because CheckPersonEligibleForSelectiveService\r\nimplements an interface, you can use an anonymous class\r\ninstead of a local class and bypass the need to declare a new class for each search.\r\n\r\nApproach 4: Specify Search Criteria Code in an Anonymous Class\r\nOne of the arguments of the following invocation of the method printPersons is an anonymous class that filters members that are eligible for Selective Service in the United States: those who are male and between the ages of 18 and 25:\r\nprintPersons(\r\n    roster,\r\n    new CheckPerson() {\r\n        public boolean test(Person p) {\r\n            return p.getGender() == Person.Sex.MALE\r\n                && p.getAge() >= 18\r\n                && p.getAge() <= 25;\r\n        }\r\n    }\r\n);\r\nThis approach reduces the amount of code required because you don't have to create a new class for each search that you want to perform. However, the syntax of anonymous classes is bulky considering that the CheckPerson interface contains only one method. In this\r\ncase, you can use a lambda expression instead of an anonymous class, as\r\ndescribed in the next section.\r\n\r\nApproach 5: Specify Search Criteria Code with a Lambda Expression\r\nThe CheckPerson\r\ninterface is a functional interface. A functional\r\ninterface is any interface that contains only one\r\nabstract method. (A functional interface may contain one or more \r\ndefault methods or\r\nstatic methods.) Because\r\na functional interface contains only one abstract method, you can\r\nomit the name of that method\r\nwhen you implement it. To do this, instead of using an anonymous\r\nclass expression, you use a lambda\r\nexpression, which is\r\nhighlighted in the following method invocation:\r\nprintPersons(\r\n    roster,\r\n    (Person p) -> p.getGender() == Person.Sex.MALE\r\n        && p.getAge() >= 18\r\n        && p.getAge() <= 25\r\n);\r\nSee Syntax of Lambda Expressions for information about how to define lambda expressions.\r\nYou can use a standard functional interface in place of the interface CheckPerson, which reduces even further the amount of code required.\r\n\r\nApproach 6: Use Standard Functional Interfaces with Lambda Expressions\r\nReconsider the CheckPerson interface:\r\ninterface CheckPerson {\r\n    boolean test(Person p);\r\n}\r\nThis is a very\r\nsimple interface. It's a functional interface because it contains\r\nonly one abstract method. This method takes one parameter and returns a\r\nboolean value. The method is so simple that it might not be worth\r\nit to define one in your application. Consequently, the JDK\r\ndefines several standard functional interfaces, which you can\r\nfind in the package java.util.function.\r\nFor example, you can use the\r\nPredicate<T>\r\n\r\n interface in place of CheckPerson. This\r\ninterface contains the method boolean\r\ntest(T t):\r\ninterface Predicate<T> {\r\n    boolean test(T t);\r\n}\r\nThe interface Predicate<T> is an example of a generic interface. (For more information about generics, see the\r\nGenerics (Updated) lesson.) Generic types (such as generic interfaces) specify one or more type parameters within angle brackets (<>). This interface contains only one type parameter, T. When you declare or instantiate a generic type with actual type arguments, you have a parameterized type. For example, the parameterized type Predicate<Person> is the following:\r\ninterface Predicate<Person> {\r\n    boolean test(Person t);\r\n}\r\nThis parameterized type contains a method that has the same return type and parameters as CheckPerson.boolean test(Person p). Consequently, you can use Predicate<T> in place of CheckPerson as the following method demonstrates:\r\npublic static void printPersonsWithPredicate(\r\n    List<Person> roster, Predicate<Person> tester) {\r\n    for (Person p : roster) {\r\n        if (tester.test(p)) {\r\n            p.printPerson();\r\n        }\r\n    }\r\n}\r\nAs a result,\r\nthe following method invocation is the same as when you invoked\r\nprintPersons in Approach 3: Specify Search Criteria Code in a Local Class to obtain members who are eligible for Selective Service:\r\nprintPersonsWithPredicate(\r\n    roster,\r\n    p -> p.getGender() == Person.Sex.MALE\r\n        && p.getAge() >= 18\r\n        && p.getAge() <= 25\r\n);\r\nThis is not the only possible place in this method to use a lambda expression. The following approach suggests other ways to use lambda expressions.\r\n\r\nApproach 7: Use Lambda Expressions Throughout Your Application\r\nReconsider the method printPersonsWithPredicate\r\nto see where else you could use lambda expressions:\r\npublic static void printPersonsWithPredicate(\r\n    List<Person> roster, Predicate<Person> tester) {\r\n    for (Person p : roster) {\r\n        if (tester.test(p)) {\r\n            p.printPerson();\r\n        }\r\n    }\r\n}\r\nThis method checks each Person instance contained in the List parameter roster whether it satisfies the criteria specified in the Predicate parameter tester. If the Person instance does satisfy the criteria specified by tester, the method printPersron is invoked on the Person instance.\r\nInstead of invoking the method printPerson, you can specify a different action to perform on those Person instances that satisfy the criteria specified by tester. You can specify this action with a lambda expression. Suppose you want a lambda expression similar to printPerson, one that takes one argument (an object of type Person) and returns void. Remember, to use a lambda expression, you need to implement a functional interface. In this case, you need a functional interface that contains an abstract method that can take one argument of type Person and returns void. The\r\nConsumer<T>\r\n interface contains the method\r\nvoid accept(T t), which has these characteristics. The\r\nfollowing method replaces the invocation\r\np.printPerson() with an\r\ninstance of Consumer<Person> that invokes the method accept:\r\npublic static void processPersons(\r\n    List<Person> roster,\r\n    Predicate<Person> tester,\r\n    Consumer<Person> block) {\r\n        for (Person p : roster) {\r\n            if (tester.test(p)) {\r\n                block.accept(p);\r\n            }\r\n        }\r\n}\r\nAs a\r\nresult, the following method invocation is the same as when you invoked printPersons in Approach 3: Specify Search Criteria Code in a Local Class to obtain members who are eligible for Selective Service. The lambda expression used to\r\nprint members is highlighted:\r\nprocessPersons(\r\n     roster,\r\n     p -> p.getGender() == Person.Sex.MALE\r\n         && p.getAge() >= 18\r\n         && p.getAge() <= 25,\r\n     p -> p.printPerson()\r\n);\r\nWhat if you want to do more with your members' profiles than printing them out. Suppose that you want to validate the members' profiles or retrieve\r\ntheir contact information? In this case, you need a functional\r\ninterface that contains an abstract method that returns a value.\r\nThe\r\nFunction<T,R>\r\n interface contains the\r\nmethod R apply(T\r\nt). The following method retrieves the data\r\nspecified by the parameter mapper, and\r\nthen performs an action on it specified by the\r\nparameter block:\r\npublic static void processPersonsWithFunction(\r\n    List<Person> roster,\r\n    Predicate<Person> tester,\r\n    Function<Person, String> mapper,\r\n    Consumer<String> block) {\r\n    for (Person p : roster) {\r\n        if (tester.test(p)) {\r\n            String data = mapper.apply(p);\r\n            block.accept(data);\r\n        }\r\n    }\r\n}\r\nThe following method retrieves the email address from each member\r\ncontained in roster who is eligible for Selective Service and\r\nthen prints it:\r\nprocessPersonsWithFunction(\r\n    roster,\r\n    p -> p.getGender() == Person.Sex.MALE\r\n        && p.getAge() >= 18\r\n        && p.getAge() <= 25,\r\n    p -> p.getEmailAddress(),\r\n    email -> System.out.println(email)\r\n);\r\n\r\nApproach 8: Use Generics More Extensively\r\nReconsider the method processPersonsWithFunction. The following is a generic version of it that accepts, as a parameter, a collection that contains elements of any data type:\r\npublic static <X, Y> void processElements(\r\n    Iterable<X> source,\r\n    Predicate<X> tester,\r\n    Function <X, Y> mapper,\r\n    Consumer<Y> block) {\r\n    for (X p : source) {\r\n        if (tester.test(p)) {\r\n            Y data = mapper.apply(p);\r\n            block.accept(data);\r\n        }\r\n    }\r\n}\r\nTo print the e-mail address of members who are eligible for Selective Service, invoke the processElements method as follows:\r\nprocessElements(\r\n    roster,\r\n    p -> p.getGender() == Person.Sex.MALE\r\n        && p.getAge() >= 18\r\n        && p.getAge() <= 25,\r\n    p -> p.getEmailAddress(),\r\n    email -> System.out.println(email)\r\n);\r\nThis method invocation performs the following actions:\r\n\r\nObtains a source of objects from the collection source. In this example, it obtains a source of Person objects from the collection roster. Notice that the collection roster, which is a collection of type List, is also an object of type Iterable.\r\nFilters objects that match the Predicate object tester. In this example, the Predicate object is a lambda expression that specifies which members would be eligible for Selective Service.\r\nMaps each filtered object to a value as specified by the Function object mapper. In this example, the Function object is a lambda expression that returns the e-mail address of a member.\r\nPerforms an action on each mapped object as specified by the Consumer object block. In this example, the Consumer object is a lambda expression that prints a string, which is the e-mail address returned by the Function object.\r\n\r\nYou can replace each of these actions with an aggregate operation.\r\n\r\nApproach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters\r\nThe following example uses aggregate operations to print the e-mail addresses of those members contained in the collection roster who are eligible for Selective Service:\r\nroster\r\n    .stream()\r\n    .filter(\r\n        p -> p.getGender() == Person.Sex.MALE\r\n            && p.getAge() >= 18\r\n            && p.getAge() <= 25)\r\n    .map(p -> p.getEmailAddress())\r\n    .forEach(email -> System.out.println(email));\r\nThe following table maps each of the operations the method processElements performs with the corresponding aggregate operation:\r\n\r\n\r\nprocessElements Action\r\nAggregate Operation\r\n\r\n\r\nObtain a source of objects\r\nStream<E> stream()\r\n\r\n\r\nFilter objects that match a Predicate object\r\nStream<T> filter(Predicate<? super T> predicate)\r\n\r\n\r\nMap objects to another value as specified by a Function object\r\n<R> Stream<R> map(Function<? super T,? extends R> mapper)\r\n\r\n\r\nPerform an action as specified by a Consumer object\r\nvoid forEach(Consumer<? super T> action)\r\n\r\n\r\nThe operations filter, map, and forEach are aggregate operations. Aggregate operations process elements from a stream, not directly from a collection (which is the reason why the first method invoked in this example is stream). A stream is a sequence of elements. Unlike a collection, it is not a data structure that stores elements. Instead, a stream carries values from a source, such as collection, through a pipeline. A pipeline is a sequence of stream operations, which in this example is filter- map-forEach. In addition, aggregate operations typically accept lambda expressions as parameters, enabling you to customize how they behave.\r\nFor a more thorough discussion of aggregate operations, see the\r\nAggregate Operations lesson.\r\nLambda Expressions in GUI Applications\r\nTo process events in a graphical user interface (GUI) application, such as keyboard\r\nactions, mouse actions, and scroll actions, you typically create\r\nevent handlers, which usually involves implementing a particular\r\ninterface. Often, event handler interfaces are functional\r\ninterfaces; they tend to have only one method.\r\nIn the JavaFX example \r\nHelloWorld.java (discussed in the previous section\r\nAnonymous Classes), you can\r\nreplace the highlighted anonymous class with a lambda expression in this\r\nstatement:\r\n        btn.setOnAction(new EventHandler<ActionEvent>() {\r\n\r\n            @Override\r\n            public void handle(ActionEvent event) {\r\n                System.out.println(\"Hello World!\");\r\n            }\r\n        });\r\nThe method invocation btn.setOnAction specifies what\r\nhappens when you select the button represented by the btn object. This method requires\r\nan object of type EventHandler<ActionEvent>. The EventHandler<ActionEvent>\r\ninterface contains only one method, void handle(T event).\r\nThis interface is a functional interface, so you could use the following highlighted lambda expression to replace it:\r\n        btn.setOnAction(\r\n          event -> System.out.println(\"Hello World!\")\r\n        );\r\nSyntax of Lambda Expressions\r\nA lambda expression consists of the following:\r\n\r\nA\r\ncomma-separated list of formal parameters enclosed in\r\nparentheses. The CheckPerson.test method contains one parameter,\r\np, which represents an instance of the\r\nPerson class.\r\nNote: You can\r\nomit the data type of the parameters in a lambda expression. In\r\naddition, you can omit the parentheses if there is only one\r\nparameter. For example, the following lambda expression is also\r\nvalid:\r\np -> p.getGender() == Person.Sex.MALE \r\n    && p.getAge() >= 18\r\n    && p.getAge() <= 25\r\nThe arrow token, ->\r\nA\r\nbody, which consists of a single expression or a statement block. This example uses the following expression:\r\np.getGender() == Person.Sex.MALE \r\n    && p.getAge() >= 18\r\n    && p.getAge() <= 25\r\nIf you\r\nspecify a single expression, then the Java runtime evaluates the\r\nexpression and then returns its value. Alternatively, you can use\r\na return statement:\r\np -> {\r\n    return p.getGender() == Person.Sex.MALE\r\n        && p.getAge() >= 18\r\n        && p.getAge() <= 25;\r\n}\r\nA return statement is not an expression; in a lambda expression,\r\nyou must enclose statements in braces ({}). However, you do not have to enclose a void method invocation in braces. For example, the following is a valid lambda expression:\r\nemail -> System.out.println(email)\r\n\r\n\r\nNote that a lambda expression looks a lot like a method\r\ndeclaration; you can consider lambda expressions as anonymous\r\nmethodsâ\u20ac\u201dmethods without a name.\r\nThe following example,\r\nCalculator, is an example of lambda expressions that take\r\nmore than one formal parameter:\r\n\r\n\r\npublic class Calculator {\r\n  \r\n    interface IntegerMath {\r\n        int operation(int a, int b);   \r\n    }\r\n  \r\n    public int operateBinary(int a, int b, IntegerMath op) {\r\n        return op.operation(a, b);\r\n    }\r\n \r\n    public static void main(String... args) {\r\n    \r\n        Calculator myApp = new Calculator();\r\n        IntegerMath addition = (a, b) -> a + b;\r\n        IntegerMath subtraction = (a, b) -> a - b;\r\n        System.out.println(\"40 + 2 = \" +\r\n            myApp.operateBinary(40, 2, addition));\r\n        System.out.println(\"20 - 10 = \" +\r\n            myApp.operateBinary(20, 10, subtraction));    \r\n    }\r\n}\r\n\r\n\r\nThe method operateBinary performs a\r\nmathematical operation on two integer operands. The operation\r\nitself is specified by an instance of IntegerMath. The example defines two operations with lambda expressions, addition and subtraction. The example prints\r\nthe following:\r\n40 + 2 = 42\r\n20 - 10 = 10\r\nAccessing Local Variables of the Enclosing Scope\r\nLike local and anonymous classes, lambda expressions can\r\ncapture variables; they have the same access to local variables of the enclosing scope. However, unlike local and anonymous classes, lambda expressions do not have any shadowing issues (see\r\nShadowing for more information). Lambda expressions are lexically scoped. This means that they do not inherit any names from a supertype or introduce a new level of scoping. Declarations in a lambda expression are interpreted just as they are in the enclosing environment. The following example,\r\nLambdaScopeTest, demonstrates this:\r\n\r\n\r\nimport java.util.function.Consumer;\r\n\r\npublic class LambdaScopeTest {\r\n\r\n    public int x = 0;\r\n\r\n    class FirstLevel {\r\n\r\n        public int x = 1;\r\n\r\n        void methodInFirstLevel(int x) {\r\n            \r\n            // The following statement causes the compiler to generate\r\n            // the error \"local variables referenced from a lambda expression\r\n            // must be final or effectively final\" in statement A:\r\n            //\r\n            // x = 99;\r\n            \r\n            Consumer<Integer> myConsumer = (y) -> \r\n            {\r\n                System.out.println(\"x = \" + x); // Statement A\r\n                System.out.println(\"y = \" + y);\r\n                System.out.println(\"this.x = \" + this.x);\r\n                System.out.println(\"LambdaScopeTest.this.x = \" +\r\n                    LambdaScopeTest.this.x);\r\n            };\r\n\r\n            myConsumer.accept(x);\r\n\r\n        }\r\n    }\r\n\r\n    public static void main(String... args) {\r\n        LambdaScopeTest st = new LambdaScopeTest();\r\n        LambdaScopeTest.FirstLevel fl = st.new FirstLevel();\r\n        fl.methodInFirstLevel(23);\r\n    }\r\n}\r\n\r\nThis example generates the following output:\r\n\r\nx = 23\r\ny = 23\r\nthis.x = 1\r\nLambdaScopeTest.this.x = 0\r\nIf you substitute the parameter x in place of y in the declaration of the lambda expression myConsumer, then the compiler generates an error:\r\nConsumer<Integer> myConsumer = (x) -> {\r\n    // ...\r\n}\r\nThe compiler generates the error \"variable x is already defined in method methodInFirstLevel(int)\" because the lambda expression does not introduce a new level of scoping. Consequently, you can directly access fields, methods, and local variables of the enclosing scope. For example, the lambda expression directly accesses the parameter x of the method methodInFirstLevel. To access variables in the enclosing class, use the keyword this. In this example, this.x refers to the member variable FirstLevel.x.\r\nHowever, like local and anonymous classes, a lambda expression can only access local variables and parameters of the enclosing block that are final or\r\neffectively final. For example, suppose that you add\r\nthe following assignment statement immediately after the methodInFirstLevel definition statement:\r\nvoid methodInFirstLevel(int x) {\r\n    x = 99;\r\n    // ...\r\n}\r\nBecause of this assignment\r\nstatement, the variable FirstLevel.x is not effectively final anymore. As a result, the Java compiler generates an error message similar to\r\n\"local variables referenced from a lambda expression must be final or effectively final\" where the lambda expression myConsumer tries to access the FirstLevel.x variable:\r\nSystem.out.println(\"x = \" + x);\r\nTarget Typing\r\nHow do you determine the type of a lambda expression? Recall\r\nthe lambda expression that selected members who are male and\r\nbetween the ages 18 and 25 years:\r\np -> p.getGender() == Person.Sex.MALE\r\n    && p.getAge() >= 18\r\n    && p.getAge() <= 25\r\nThis lambda expression was used in the following two methods:\r\n\r\npublic static void printPersons(List<Person> roster, CheckPerson tester) in Approach 3: Specify Search Criteria Code in a Local Class\r\npublic void printPersonsWithPredicate(List<Person> roster, Predicate<Person> tester) in Approach 6: Use Standard Functional Interfaces with Lambda Expressions\r\n\r\nWhen the Java runtime invokes the method printPersons, it's expecting a data type of CheckPerson, so the\r\nlambda expression is of this type. However,\r\nwhen the Java runtime invokes the method printPersonsWithPredicate,\r\nit's expecting a data type of Predicate<Person>,\r\nso the lambda expression is of this type. The data type that\r\nthese methods expect is called the target type. To determine the type of a lambda\r\nexpression, the Java compiler uses the target type of the context\r\nor situation in which the lambda expression was found. It follows\r\nthat you can only use lambda expressions in situations in which\r\nthe Java compiler can determine a target type:\r\n\r\nVariable declarations\r\nAssignments\r\nReturn statements\r\nArray initializers\r\nMethod or constructor arguments\r\nLambda expression bodies\r\nConditional expressions, ?:\r\nCast expressions\r\n\r\nTarget Types and Method Arguments\r\nFor method arguments, the Java compiler determines the target\r\ntype with two other language features: overload resolution and\r\ntype argument inference.\r\nConsider the following two functional interfaces (\r\njava.lang.Runnable and\r\njava.util.concurrent.Callable<V>):\r\npublic interface Runnable {\r\n    void run();\r\n}\r\n\r\npublic interface Callable<V> {\r\n    V call();\r\n}\r\nThe method Runnable.run does not return a value, whereas Callable<V>.call does.\r\nSuppose that you have overloaded the method invoke as follows\r\n(see\r\nDefining Methods for more information about overloading methods):\r\nvoid invoke(Runnable r) {\r\n    r.run();\r\n}\r\n\r\n<T> T invoke(Callable<T> c) {\r\n    return c.call();\r\n}\r\nWhich method will be invoked in the following statement?\r\nString s = invoke(() -> \"done\");\r\nThe method invoke(Callable<T>) will be\r\ninvoked because that method returns a value; the method\r\ninvoke(Runnable) does not. In this case, the type of the lambda expression () -> \"done\" is Callable<T>.\r\nSerialization\r\nYou can \r\nserialize a lambda expression if its target type and its captured arguments are serializable. However, like\r\ninner classes, the serialization of lambda expressions is strongly discouraged.\r\n",
        "title": "Oracle_Lambda Expressions.txt",
        "type": "Oracle_"
    }, {
        "rank": 5,
        "text": "\r\nThere a several modifiers that may be part of a method declaration:\r\n\r\nAccess modifiers: public, protected, and private\r\nModifier restricting to one instance: static\r\nModifier prohibiting value modification: final\r\nModifier requiring override: abstract\r\nModifier preventing reentrancy: synchronized\r\nModifier indicating implementation in another programming language: native\r\nModifier forcing strict floating point behavior: strictfp\r\nAnnotations\r\n\r\nThe \r\nMethodModifierSpy example lists the modifiers of a method with a given name. It also displays whether the method is synthetic (compiler-generated), of variable arity, or a bridge method (compiler-generated to support generic interfaces).\r\n\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Modifier;\r\nimport static java.lang.System.out;\r\n\r\npublic class MethodModifierSpy {\r\n\r\n    private static int count;\r\n    private static synchronized void inc() { count++; }\r\n    private static synchronized int cnt() { return count; }\r\n\r\n    public static void main(String... args) {\r\n\ttry {\r\n\t    Class<?> c = Class.forName(args[0]);\r\n\t    Method[] allMethods = c.getDeclaredMethods();\r\n\t    for (Method m : allMethods) {\r\n\t\tif (!m.getName().equals(args[1])) {\r\n\t\t    continue;\r\n\t\t}\r\n\t\tout.format(\"%s%n\", m.toGenericString());\r\n\t\tout.format(\"  Modifiers:  %s%n\",\r\n\t\t\t   Modifier.toString(m.getModifiers()));\r\n\t\tout.format(\"  [ synthetic=%-5b var_args=%-5b bridge=%-5b ]%n\",\r\n\t\t\t   m.isSynthetic(), m.isVarArgs(), m.isBridge());\r\n\t\tinc();\r\n\t    }\r\n\t    out.format(\"%d matching overload%s found%n\", cnt(),\r\n\t\t       (cnt() == 1 ? \"\" : \"s\"));\r\n\r\n        // production code should handle this exception more gracefully\r\n\t} catch (ClassNotFoundException x) {\r\n\t    x.printStackTrace();\r\n\t}\r\n    }\r\n}\r\n\r\nA few examples of the output \r\nMethodModifierSpy produces follow.\r\n\r\n$ java MethodModifierSpy java.lang.Object wait\r\npublic final void java.lang.Object.wait() throws java.lang.InterruptedException\r\n  Modifiers:  public final\r\n  [ synthetic=false var_args=false bridge=false ]\r\npublic final void java.lang.Object.wait(long,int)\r\n  throws java.lang.InterruptedException\r\n  Modifiers:  public final\r\n  [ synthetic=false var_args=false bridge=false ]\r\npublic final native void java.lang.Object.wait(long)\r\n  throws java.lang.InterruptedException\r\n  Modifiers:  public final native\r\n  [ synthetic=false var_args=false bridge=false ]\r\n3 matching overloads found\r\n\r\n\r\n$ java MethodModifierSpy java.lang.StrictMath toRadians\r\npublic static double java.lang.StrictMath.toRadians(double)\r\n  Modifiers:  public static strictfp\r\n  [ synthetic=false var_args=false bridge=false ]\r\n1 matching overload found\r\n\r\n\r\n$ java MethodModifierSpy MethodModifierSpy inc\r\nprivate synchronized void MethodModifierSpy.inc()\r\n  Modifiers: private synchronized\r\n  [ synthetic=false var_args=false bridge=false ]\r\n1 matching overload found\r\n\r\n\r\n$ java MethodModifierSpy java.lang.Class getConstructor\r\npublic java.lang.reflect.Constructor<T> java.lang.Class.getConstructor\r\n  (java.lang.Class<T>[]) throws java.lang.NoSuchMethodException,\r\n  java.lang.SecurityException\r\n  Modifiers: public transient\r\n  [ synthetic=false var_args=true bridge=false ]\r\n1 matching overload found\r\n\r\n\r\n$ java MethodModifierSpy java.lang.String compareTo\r\npublic int java.lang.String.compareTo(java.lang.String)\r\n  Modifiers: public\r\n  [ synthetic=false var_args=false bridge=false ]\r\npublic int java.lang.String.compareTo(java.lang.Object)\r\n  Modifiers: public volatile\r\n  [ synthetic=true  var_args=false bridge=true  ]\r\n2 matching overloads found\r\n\r\nNote that \r\nMethod.isVarArgs() returns true for \r\nClass.getConstructor(). This indicates that the method declaration looks like this:\r\n\r\npublic Constructor<T> getConstructor(Class<?>... parameterTypes)\r\n\r\nnot like this:\r\n\r\npublic Constructor<T> getConstructor(Class<?> [] parameterTypes)\r\n\r\nNotice that the output for \r\nString.compareTo() contains two methods. The method declared in String.java:\r\n\r\npublic int compareTo(String anotherString);\r\n\r\nand a second synthetic or compiler-generated bridge method. This occurs because \r\nString implements the parameterized interface \r\nComparable. During type erasure, the argument type of the inherited method \r\nComparable.compareTo() is changed from java.lang.Object to java.lang.String. Since the parameter types for the compareTo methods in Comparable and String no longer match after erasure, overriding can not occur. In all other circumstances, this would produce a compile-time error because the interface is not implemented. The addition of the bridge method avoids this problem.\r\n\r\nMethod implements \r\njava.lang.reflect.AnnotatedElement. Thus any runtime annotations with \r\njava.lang.annotation.RetentionPolicy.RUNTIME may be retrieved. For an example of obtaining annotations see the section Examining Class Modifiers and Types.\r\n",
        "title": "Oracle_Retrieving and Parsing Method Modifiers.txt",
        "type": "Oracle_"
    }, {
        "rank": 6,
        "text": "\r\n\r\nWrite a generic method to count the number of elements in a collection that have a specific property (for example, odd integers, prime numbers, palindromes).\r\nWill the following class compile? If not, why?\r\n\r\npublic final class Algorithm {\r\n    public static <T> T max(T x, T y) {\r\n        return x > y ? x : y;\r\n    }\r\n}\r\n\r\n\r\nWrite a generic method to exchange the positions of two different elements in an array.\r\nIf the compiler erases all type parameters at compile time, why should you use generics?\r\nWhat is the following class converted to after type erasure?\r\n\r\npublic class Pair<K, V> {\r\n\r\n    public Pair(K key, V value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n\r\n    public K getKey(); { return key; }\r\n    public V getValue(); { return value; }\r\n\r\n    public void setKey(K key)     { this.key = key; }\r\n    public void setValue(V value) { this.value = value; }\r\n\r\n    private K key;\r\n    private V value;\r\n}\r\n\r\n\r\nWhat is the following method converted to after type erasure?\r\n\r\npublic static <T extends Comparable<T>>\r\n    int findFirstGreaterThan(T[] at, T elem) {\r\n    // ...\r\n}\r\n\r\n\r\nWill the following method compile? If not, why?\r\n\r\npublic static void print(List<? extends Number> list) {\r\n    for (Number n : list)\r\n        System.out.print(n + \" \");\r\n    System.out.println();\r\n}\r\n\r\n\r\nWrite a generic method to find the maximal element in the range [begin, end) of a list.\r\nWill the following class compile?  If not, why?\r\n\r\npublic class Singleton<T> {\r\n\r\n    public static T getInstance() {\r\n        if (instance == null)\r\n            instance = new Singleton<T>();\r\n\r\n        return instance;\r\n    }\r\n\r\n    private static T instance = null;\r\n}\r\n\r\n\r\n Given the following classes:\r\n\r\nclass Shape { /* ... */ }\r\nclass Circle extends Shape { /* ... */ }\r\nclass Rectangle extends Shape { /* ... */ }\r\n\r\nclass Node<T> { /* ... */ }\r\n\r\nWill the following code compile? If not, why?\r\n\r\nNode<Circle> nc = new Node<>();\r\nNode<Shape>  ns = nc;\r\n\r\n\r\nConsider this class:\r\n\r\nclass Node<T> implements Comparable<T> {\r\n    public int compareTo(T obj) { /* ... */ }\r\n    // ...\r\n}\r\n\r\nWill the following code compile? If not, why?\r\n\r\nNode<String> node = new Node<>();\r\nComparable<String> comp = node;\r\n\r\n\r\nHow do you invoke the following method to find the first integer in a list that is relatively prime to a list of specified integers?\r\n\r\npublic static <T>\r\n    int findFirst(List<T> list, int begin, int end, UnaryPredicate<T> p)\r\n\r\nNote that two integers a and b are relatively prime if gcd(a, b) = 1, where gcd is short for greatest common divisor.\r\n\r\nCheck your answers.\r\n",
        "title": "Oracle_Questions and Exercises Generics.txt",
        "type": "Oracle_"
    }, {
        "rank": 7,
        "text": "\r\n\r\nConsider the problem of writing a routine that prints out all the elements in a collection. Here's how you might write it in an older version of the language (i.e., a pre-5.0 release):\r\n\r\nvoid printCollection(Collection c) {\r\n    Iterator i = c.iterator();\r\n    for (k = 0; k < c.size(); k++) {\r\n        System.out.println(i.next());\r\n    }\r\n}\r\n\r\nAnd here is a naive attempt at writing it using generics (and the new for loop syntax):\r\n\r\nvoid printCollection(Collection<Object> c) {\r\n    for (Object e : c) {\r\n        System.out.println(e);\r\n    }\r\n}\r\n\r\nThe problem is that this new version is much less useful than the old one. Whereas the old code could be called with any kind of collection as a parameter, the new code only takes Collection<Object>, which, as we've just demonstrated, is not a supertype of all kinds of collections!\r\nSo what is the supertype of all kinds of collections? It's written Collection<?> (pronounced \"collection of unknown\"), that is, a collection whose element type matches anything. It's called a wildcard type for obvious reasons. We can write:\r\n\r\nvoid printCollection(Collection<?> c) {\r\n    for (Object e : c) {\r\n        System.out.println(e);\r\n    }\r\n}\r\n\r\nand now, we can call it with any type of collection. Notice that inside printCollection(), we can still read elements from c and give them type Object. This is always safe, since whatever the actual type of the collection, it does contain objects. It isn't safe to add arbitrary objects to it however:\r\n\r\nCollection<?> c = new ArrayList<String>();\r\nc.add(new Object()); // Compile time error\r\n\r\nSince we don't know what the element type of c stands for, we cannot add objects to it. The add() method takes arguments of type E, the element type of the collection. When the actual type parameter is ?, it stands for some unknown type. Any parameter we pass to add would have to be a subtype of this unknown type. Since we don't know what type that is, we cannot pass anything in. The sole exception is null, which is a member of every type.\r\nOn the other hand, given a List<?>, we can call get() and make use of the result. The result type is an unknown type, but we always know that it is an object. It is therefore safe to assign the result of get() to a variable of type Object or pass it as a parameter where the type Object is expected.\r\nBounded Wildcards\r\nConsider a simple drawing application that can draw shapes such as rectangles and circles. To represent these shapes within the program, you could define a class hierarchy such as this:\r\n\r\npublic abstract class Shape {\r\n    public abstract void draw(Canvas c);\r\n}\r\n\r\npublic class Circle extends Shape {\r\n    private int x, y, radius;\r\n    public void draw(Canvas c) {\r\n        ...\r\n    }\r\n}\r\n\r\npublic class Rectangle extends Shape {\r\n    private int x, y, width, height;\r\n    public void draw(Canvas c) {\r\n        ...\r\n    }\r\n}\r\n\r\nThese classes can be drawn on a canvas:\r\n\r\npublic class Canvas {\r\n    public void draw(Shape s) {\r\n        s.draw(this);\r\n   }\r\n}\r\n\r\nAny drawing will typically contain a number of shapes. Assuming that they are represented as a list, it would be convenient to have a method in Canvas that draws them all:\r\n\r\npublic void drawAll(List<Shape> shapes) {\r\n    for (Shape s: shapes) {\r\n        s.draw(this);\r\n   }\r\n}\r\n\r\nNow, the type rules say that drawAll() can only be called on lists of exactly Shape: it cannot, for instance, be called on a List<Circle>. That is unfortunate, since all the method does is read shapes from the list, so it could just as well be called on a List<Circle>. What we really want is for the method to accept a list of any kind of shape:\r\n\r\npublic void drawAll(List<? extends Shape> shapes) {\r\n    ...\r\n}\r\n\r\nThere is a small but very important difference here: we have replaced the type List<Shape> with List<? extends Shape>. Now drawAll() will accept lists of any subclass of Shape, so we can now call it on a List<Circle> if we want.\r\nList<? extends Shape> is an example of a bounded wildcard. The ? stands for an unknown type, just like the wildcards we saw earlier. However, in this case, we know that this unknown type is in fact a subtype of Shape. (Note: It could be Shape itself, or some subclass; it need not literally extend Shape.) We say that Shape is the upper bound of the wildcard.\r\nThere is, as usual, a price to be paid for the flexibility of using wildcards. That price is that it is now illegal to write into shapes in the body of the method. For instance, this is not allowed:\r\n\r\npublic void addRectangle(List<? extends Shape> shapes) {\r\n    // Compile-time error!\r\n    shapes.add(0, new Rectangle());\r\n}\r\n\r\nYou should be able to figure out why the code above is disallowed. The type of the second parameter to shapes.add() is ? extends Shape-- an unknown subtype of Shape. Since we don't know what type it is, we don't know if it is a supertype of Rectangle; it might or might not be such a supertype, so it isn't safe to pass a Rectangle there.\r\nBounded wildcards are just what one needs to handle the example of the DMV passing its data to the census bureau. Our example assumes that the data is represented by mapping from names (represented as strings) to people (represented by reference types such as Person or its subtypes, such as Driver). Map<K,V> is an example of a generic type that takes two type arguments, representing the keys and values of the map.\r\nAgain, note the naming convention for formal type parameters--K for keys and V for values.\r\n\r\npublic class Census {\r\n    public static void addRegistry(Map<String, ? extends Person> registry) {\r\n}\r\n...\r\n\r\nMap<String, Driver> allDrivers = ... ;\r\nCensus.addRegistry(allDrivers);\r\n\r\n",
        "title": "Oracle_Wildcards.txt",
        "type": "Oracle_"
    }, {
        "rank": 8,
        "text": "\r\nThe break Statement\r\nThe break statement has two forms: labeled and unlabeled. You saw the unlabeled form in the previous discussion of the switch statement. You can also use an unlabeled break to terminate a for, while, or do-while loop, as shown in the following \r\nBreakDemo program:\r\n\r\nclass BreakDemo {\r\n    public static void main(String[] args) {\r\n\r\n        int[] arrayOfInts = \r\n            { 32, 87, 3, 589,\r\n              12, 1076, 2000,\r\n              8, 622, 127 };\r\n        int searchfor = 12;\r\n\r\n        int i;\r\n        boolean foundIt = false;\r\n\r\n        for (i = 0; i < arrayOfInts.length; i++) {\r\n            if (arrayOfInts[i] == searchfor) {\r\n                foundIt = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (foundIt) {\r\n            System.out.println(\"Found \" + searchfor + \" at index \" + i);\r\n        } else {\r\n            System.out.println(searchfor + \" not in the array\");\r\n        }\r\n    }\r\n}\r\n\r\nThis program searches for the number 12 in an array. The break statement, shown in boldface, terminates the for loop when that value is found. Control flow then transfers to the statement after the for loop. This program's output is:\r\n\r\nFound 12 at index 4\r\n\r\nAn unlabeled break statement terminates the innermost switch, for, while, or do-while statement, but a labeled break terminates an outer statement. The following program, \r\nBreakWithLabelDemo, is similar to the previous program, but uses nested for loops to search for a value in a two-dimensional array. When the value is found, a labeled break terminates the outer for loop (labeled \"search\"):\r\n\r\n\r\nclass BreakWithLabelDemo {\r\n    public static void main(String[] args) {\r\n\r\n        int[][] arrayOfInts = { \r\n            { 32, 87, 3, 589 },\r\n            { 12, 1076, 2000, 8 },\r\n            { 622, 127, 77, 955 }\r\n        };\r\n        int searchfor = 12;\r\n\r\n        int i;\r\n        int j = 0;\r\n        boolean foundIt = false;\r\n\r\n    search:\r\n        for (i = 0; i < arrayOfInts.length; i++) {\r\n            for (j = 0; j < arrayOfInts[i].length;\r\n                 j++) {\r\n                if (arrayOfInts[i][j] == searchfor) {\r\n                    foundIt = true;\r\n                    break search;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (foundIt) {\r\n            System.out.println(\"Found \" + searchfor + \" at \" + i + \", \" + j);\r\n        } else {\r\n            System.out.println(searchfor + \" not in the array\");\r\n        }\r\n    }\r\n}\r\n\r\nThis is the output of the program.\r\n\r\nFound 12 at 1, 0\r\n\r\nThe break statement terminates the labeled statement; it does not transfer the flow of control to the label. Control flow is transferred to the statement immediately following the labeled (terminated) statement.\r\nThe continue Statement\r\nThe continue statement skips the current iteration of a for, while , or do-while loop. The unlabeled form skips to the end of the innermost loop's body and evaluates the boolean expression that controls the loop. The following program, \r\nContinueDemo , steps through a String, counting the occurences of the letter \"p\". If the current character is not a p, the continue statement skips the rest of the loop and proceeds to the next character. If it is a \"p\", the program increments the letter count.\r\n\r\n\r\nclass ContinueDemo {\r\n    public static void main(String[] args) {\r\n\r\n        String searchMe = \"peter piper picked a \" + \"peck of pickled peppers\";\r\n        int max = searchMe.length();\r\n        int numPs = 0;\r\n\r\n        for (int i = 0; i < max; i++) {\r\n            // interested only in p's\r\n            if (searchMe.charAt(i) != 'p')\r\n                continue;\r\n\r\n            // process p's\r\n            numPs++;\r\n        }\r\n        System.out.println(\"Found \" + numPs + \" p's in the string.\");\r\n    }\r\n}\r\n\r\nHere is the output of this program:\r\n\r\nFound 9 p's in the string.\r\n\r\nTo see this effect more clearly, try removing the continue statement and recompiling. When you run the program again, the count will be wrong, saying that it found 35 p's instead of 9.\r\nA labeled continue statement skips the current iteration of an outer loop marked with the given label. The following example program, ContinueWithLabelDemo, uses nested loops to search for a substring within another string. Two nested loops are required: one to iterate over the substring and one to iterate over the string being searched. The following program, \r\nContinueWithLabelDemo, uses the labeled form of continue to skip an iteration in the outer loop.\r\n\r\n\r\nclass ContinueWithLabelDemo {\r\n    public static void main(String[] args) {\r\n\r\n        String searchMe = \"Look for a substring in me\";\r\n        String substring = \"sub\";\r\n        boolean foundIt = false;\r\n\r\n        int max = searchMe.length() - \r\n                  substring.length();\r\n\r\n    test:\r\n        for (int i = 0; i <= max; i++) {\r\n            int n = substring.length();\r\n            int j = i;\r\n            int k = 0;\r\n            while (n-- != 0) {\r\n                if (searchMe.charAt(j++) != substring.charAt(k++)) {\r\n                    continue test;\r\n                }\r\n            }\r\n            foundIt = true;\r\n                break test;\r\n        }\r\n        System.out.println(foundIt ? \"Found it\" : \"Didn't find it\");\r\n    }\r\n}\r\n\r\nHere is the output from this program.\r\n\r\nFound it\r\n\r\nThe return Statement\r\nThe last of the branching statements is the return statement. The return statement exits from the current method, and control flow returns to where the method was invoked. The return statement has two forms: one that returns a value, and one that doesn't. To return a value, simply put the value (or an expression that calculates the value) after the return keyword.\r\n\r\nreturn ++count;\r\n\r\nThe data type of the returned value must match the type of the method's declared return value. When a method is declared void, use the form of return that doesn't return a value.\r\n\r\nreturn;\r\n\r\nThe \r\nClasses and Objects lesson will cover everything you need to know about writing methods.\r\n",
        "title": "Oracle_Branching Statements.txt",
        "type": "Oracle_"
    }, {
        "rank": 9,
        "text": "\r\nMany programmers will never need to implement their own Collections classes. You can go pretty far using the implementations described in the preceding sections of this chapter. However, someday you might want to write your own implementation. It is fairly easy to do this with the aid of the abstract implementations provided by the Java platform. Before we discuss how to write an implementation, let's discuss why you might want to write one.\r\nReasons to Write an Implementation\r\nThe following list illustrates the sort of custom Collections you might want to implement. It is not intended to be exhaustive:\r\n\r\nPersistent: All of the built-in Collection implementations reside in main memory and vanish when the program exits. If you want a collection that will still be present the next time the program starts, you can implement it by building a veneer over an external database. Such a collection might be concurrently accessible by multiple programs.\r\nApplication-specific: This is a very broad category. One example is an unmodifiable Map containing real-time telemetry data. The keys could represent locations, and the values could be read from sensors at these locations in response to the get operation.\r\nHigh-performance, special-purpose: Many data structures take advantage of restricted usage to offer better performance than is possible with general-purpose implementations. For instance, consider a List containing long runs of identical element values. Such lists, which occur frequently in text processing, can be run-length encoded â\u20ac\u201d runs can be represented as a single object containing the repeated element and the number of consecutive repetitions. This example is interesting because it trades off two aspects of performance: It requires less space but more time than an ArrayList.\r\nHigh-performance, general-purpose: The Java Collections Framework's designers tried to provide the best general-purpose implementations for each interface, but many, many data structures could have been used, and new ones are invented every day. Maybe you can come up with something faster!\r\nEnhanced functionality: Suppose you need an efficient bag implementation (also known as a multiset): a Collection that offers constant-time containment checks while allowing duplicate elements. It's reasonably straightforward to implement such a collection atop a HashMap.\r\nConvenience: You may want additional implementations that offer conveniences beyond those offered by the Java platform. For instance, you may frequently need List instances representing a contiguous range of Integers.\r\nAdapter: Suppose you are using a legacy API that has its own ad hoc collections' API. You can write an adapter implementation that permits these collections to operate in the Java Collections Framework. An adapter implementation is a thin veneer that wraps objects of one type and makes them behave like objects of another type by translating operations on the latter type into operations on the former.\r\n\r\nHow to Write a Custom Implementation\r\nWriting a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We'll start with the following example of an implementation of \r\nArrays.asList.\r\n\r\npublic static <T> List<T> asList(T[] a) {\r\n    return new MyArrayList<T>(a);\r\n}\r\n\r\nprivate static class MyArrayList<T> extends AbstractList<T> {\r\n\r\n    private final T[] a;\r\n\r\n    MyArrayList(T[] array) {\r\n        a = array;\r\n    }\r\n\r\n    public T get(int index) {\r\n        return a[index];\r\n    }\r\n\r\n    public T set(int index, T element) {\r\n        T oldValue = a[index];\r\n        a[index] = element;\r\n        return oldValue;\r\n    }\r\n\r\n    public int size() {\r\n        return a.length;\r\n    }\r\n}\r\n\r\nBelieve it or not, this is very close to the implementation that is contained in java.util.Arrays. It's that simple! You provide a constructor and the get, set, and size methods, and AbstractList does all the rest. You get the ListIterator, bulk operations, search operations, hash code computation, comparison, and string representation for free.\r\nSuppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you'll know which methods to override to get the performance you want. The preceding implementation's performance is fine, but it can be improved a bit. In particular, the toArray method iterates over the List, copying one element at a time. Given the internal representation, it's a lot faster and more sensible just to clone the array.\r\n\r\npublic Object[] toArray() {\r\n    return (Object[]) a.clone();\r\n}\r\n\r\nWith the addition of this override and a few more like it, this implementation is exactly the one found in java.util.Arrays. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.\r\nThe following list summarizes the abstract implementations:\r\n\r\n\r\nAbstractCollection â\u20ac\u201d a Collection that is neither a Set nor a List. At a minimum, you must provide the iterator and the size methods.\r\n\r\nAbstractSet â\u20ac\u201d a Set; use is identical to AbstractCollection.\r\n\r\nAbstractList â\u20ac\u201d a List backed up by a random-access data store, such as an array. At a minimum, you must provide the positional access methods (get and, optionally, set, remove, and add) and the size method. The abstract class takes care of listIterator (and iterator).\r\n\r\nAbstractSequentialList â\u20ac\u201d a List backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the listIterator and size methods. The abstract class takes care of the positional access methods. (This is the opposite of AbstractList.)\r\n\r\nAbstractQueue â\u20ac\u201d at a minimum, you must provide the offer, peek, poll, and size methods and an iterator supporting remove.\r\n\r\nAbstractMap â\u20ac\u201d a Map. At a minimum you must provide the entrySet view. This is typically implemented with the AbstractSet class. If the Map is modifiable, you must also provide the put method.\r\n\r\nThe process of writing a custom implementation follows:\r\n\r\nChoose the appropriate abstract implementation class from the preceding list.\r\nProvide implementations for all the abstract methods of the class. If your custom collection is to be modifiable, you will have to override one or more of the concrete methods as well. The API documentation for the abstract implementation class will tell you which methods to override.\r\nTest and, if necessary, debug the implementation. You now have a working custom collection implementation.\r\nIf you are concerned about performance, read the API documentation of the abstract implementation class for all the methods whose implementations you're inheriting. If any seem too slow, override them. If you override any methods, be sure to measure the performance of the method before and after the override. How much effort you put into tweaking performance should be a function of how much use the implementation will get and how critical to performance its use is. (Often this step is best omitted.)\r\n\r\n",
        "title": "Oracle_Custom Collection Implementations.txt",
        "type": "Oracle_"
    }, {
        "rank": 10,
        "text": "\r\n\r\nThere may be times when you want to restrict the types that can be used as type arguments in a parameterized type. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what bounded type parameters are for.\r\n\r\nTo declare a bounded type parameter, list the type parameter's name, followed by the extends keyword, followed by its upper bound, which in this example is Number. Note that, in this context, extends is used in a general sense to mean either \"extends\" (as in classes) or \"implements\" (as in interfaces).\r\n\r\npublic class Box<T> {\r\n\r\n    private T t;          \r\n\r\n    public void set(T t) {\r\n        this.t = t;\r\n    }\r\n\r\n    public T get() {\r\n        return t;\r\n    }\r\n\r\n    public <U extends Number> void inspect(U u){\r\n        System.out.println(\"T: \" + t.getClass().getName());\r\n        System.out.println(\"U: \" + u.getClass().getName());\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Box<Integer> integerBox = new Box<Integer>();\r\n        integerBox.set(new Integer(10));\r\n        integerBox.inspect(\"some text\"); // error: this is still String!\r\n    }\r\n}\r\n\r\nBy modifying our generic method to include this bounded type parameter, compilation will now fail, since our invocation of inspect still includes a String:\r\n\r\nBox.java:21: <U>inspect(U) in Box<java.lang.Integer> cannot\r\n  be applied to (java.lang.String)\r\n                        integerBox.inspect(\"10\");\r\n                                  ^\r\n1 error\r\n\r\n\r\nIn addition to limiting the types you can use to instantiate a generic type, bounded type parameters allow you to invoke methods defined in the bounds:\r\n\r\npublic class NaturalNumber<T extends Integer> {\r\n\r\n    private T n;\r\n\r\n    public NaturalNumber(T n)  { this.n = n; }\r\n\r\n    public boolean isEven() {\r\n        return n.intValue() % 2 == 0;\r\n    }\r\n\r\n    // ...\r\n}\r\n\r\n\r\nThe isEven method invokes the intValue method defined in the Integer class through n.\r\nMultiple Bounds\r\n\r\nThe preceding example illustrates the use of a type parameter with a single bound, but a type parameter can have multiple bounds:\r\n\r\n<T extends B1 & B2 & B3>\r\n\r\n\r\nA type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first.  For example:\r\n\r\nClass A { /* ... */ }\r\ninterface B { /* ... */ }\r\ninterface C { /* ... */ }\r\n\r\nclass D <T extends A & B & C> { /* ... */ }\r\n\r\n\r\nIf bound A is not specified first, you get a compile-time error:\r\n\r\nclass D <T extends B & A & C> { /* ... */ }  // compile-time error\r\n\r\n",
        "title": "Oracle_Bounded Type Parameters.txt",
        "type": "Oracle_"
    }]
}

post6_rec = {
    "response": [{
        "rank": 1,
        "text": "\r\nCloning is not automatically available to classes. There is some help though, as all Java objects inherit theprotected Object clone()method. This base method would allocate the memory and do the bit by bit copying of the object's states.\r\nYou may ask why we need this clone method. Can't we create a constructor, pass in the same object and do the copying variable by variable? An example would be (note that accessing the privatememberVarvariable ofobjis legal as this is in the same class):\r\n\r\n\r\nThis method works but object creation with thenewkeyword is time-consuming. Theclone()method copies the whole object's memory in one operation and this is much faster than using the new keyword and copying each variable so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.\r\n\r\n\r\nNow, let's see how to make the Customer object cloneable.\r\n\r\nFirst theCustomerclass needs to implement theCloneableInterface.Override and make theclone()methodpublic, as that isprotectedin the Object class.Call thesuper.clone()method at the beginning of yourclonemethod.Override theclone()method in all the subclasses ofCustomer.\r\n\r\n\r\nIn thecode listing 4.15we used cloning for speed up object creation. Another use of cloning could be to take a snapshot of an object that can change in time. Let's say we want to store Customer objects in a collection, but we want to disassociate them from the 'live' objects.  So before adding the object, we clone them, so if the original object changes from that point forward, the added object won't.  Also let's say that the Customer object has a reference to an Activity object that contains the customer activities.  Now we are facing a problem, it is not enough to clone the Customer object, we also need to clone the referenced objects.  The solution:\r\n\r\nMake the Activity class also cloneableMake sure that if the Activity class has other 'changeable' object references, those have to be cloned as well, as seen belowChange the Customer classclone()method as follows:\r\n\r\n\r\nNote that only mutable objects need to be cloned. References to unchangeable objects such as a String can be used in the cloned object without worry.\r\n\r\n",
        "title": "Object Lifecycle_Creating object by cloning an object_text.txt",
        "type": "text"
    }, {
        "rank": 2,
        "text": "\r\nThis section discusses the task of implementing a class for the compute engine. In general, a class that implements a remote interface should at least do the following:\r\n\r\nDeclare the remote interfaces being implemented\r\nDefine the constructor for each remote object\r\nProvide an implementation for each remote method in the remote interfaces\r\n\r\nAn RMI server program needs to create the initial remote objects and export them to the RMI runtime, which makes them available to receive incoming remote invocations. This setup procedure can be either encapsulated in a method of the remote object implementation class itself or included in another class entirely. The setup procedure should do the following:\r\n\r\nCreate and install a security manager\r\nCreate and export one or more remote objects\r\nRegister at least one remote object with the RMI registry (or with another naming service, such as a service accessible through the Java Naming and Directory Interface) for bootstrapping purposes\r\n\r\nThe complete implementation of the compute engine follows. The \r\nengine.ComputeEngine class implements the remote interface Compute and also includes the main method for setting up the compute engine. Here is the source code for the ComputeEngine class:\r\n\r\npackage engine;\r\n\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport compute.Compute;\r\nimport compute.Task;\r\n\r\npublic class ComputeEngine implements Compute {\r\n\r\n    public ComputeEngine() {\r\n        super();\r\n    }\r\n\r\n    public <T> T executeTask(Task<T> t) {\r\n        return t.execute();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        if (System.getSecurityManager() == null) {\r\n            System.setSecurityManager(new SecurityManager());\r\n        }\r\n        try {\r\n            String name = \"Compute\";\r\n            Compute engine = new ComputeEngine();\r\n            Compute stub =\r\n                (Compute) UnicastRemoteObject.exportObject(engine, 0);\r\n            Registry registry = LocateRegistry.getRegistry();\r\n            registry.rebind(name, stub);\r\n            System.out.println(\"ComputeEngine bound\");\r\n        } catch (Exception e) {\r\n            System.err.println(\"ComputeEngine exception:\");\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n\r\nThe following sections discuss each component of the compute engine implementation.\r\nDeclaring the Remote Interfaces Being Implemented\r\nThe implementation class for the compute engine is declared as follows:\r\n\r\npublic class ComputeEngine implements Compute\r\n\r\nThis declaration states that the class implements the Compute remote interface and therefore can be used for a remote object.\r\nThe ComputeEngine class defines a remote object implementation class that implements a single remote interface and no other interfaces. The ComputeEngine class also contains two executable program elements that can only be invoked locally. The first of these elements is a constructor for ComputeEngine instances. The second of these elements is a main method that is used to create a ComputeEngine instance and make it available to clients.\r\nDefining the Constructor for the Remote Object\r\nThe ComputeEngine class has a single constructor that takes no arguments. The code for the constructor is as follows:\r\n\r\npublic ComputeEngine() {\r\n    super();\r\n}\r\n\r\nThis constructor just invokes the superclass constructor, which is the no-argument constructor of the Object class. Although the superclass constructor gets invoked even if omitted from the ComputeEngine constructor, it is included for clarity.\r\nProviding Implementations for Each Remote Method\r\nThe class for a remote object provides implementations for each remote method specified in the remote interfaces. The Compute interface contains a single remote method, executeTask, which is implemented as follows:\r\n\r\npublic <T> T executeTask(Task<T> t) {\r\n    return t.execute();\r\n}\r\n\r\nThis method implements the protocol between the ComputeEngine remote object and its clients. Each client provides the ComputeEngine with a Task object that has a particular implementation of the Task interface's execute method. The ComputeEngine executes each client's task and returns the result of the task's execute method directly to the client.\r\nPassing Objects in RMI\r\nArguments to or return values from remote methods can be of almost any type, including local objects, remote objects, and primitive data types. More precisely, any entity of any type can be passed to or from a remote method as long as the entity is an instance of a type that is a primitive data type, a remote object, or a serializable object, which means that it implements the interface java.io.Serializable.\r\nSome object types do not meet any of these criteria and thus cannot be passed to or returned from a remote method. Most of these objects, such as threads or file descriptors, encapsulate information that makes sense only within a single address space. Many of the core classes, including the classes in the packages java.lang and java.util, implement the Serializable interface.\r\nThe rules governing how arguments and return values are passed are as follows:\r\n\r\nRemote objects are essentially passed by reference. A remote object reference is a stub, which is a client-side proxy that implements the complete set of remote interfaces that the remote object implements.\r\nLocal objects are passed by copy, using object serialization. By default, all fields are copied except fields that are marked static or transient. Default serialization behavior can be overridden on a class-by-class basis.\r\n\r\nPassing a remote object by reference means that any changes made to the state of the object by remote method invocations are reflected in the original remote object. When a remote object is passed, only those interfaces that are remote interfaces are available to the receiver. Any methods defined in the implementation class or defined in non-remote interfaces implemented by the class are not available to that receiver.\r\nFor example, if you were to pass a reference to an instance of the ComputeEngine class, the receiver would have access only to the compute engine's executeTask method. That receiver would not see the ComputeEngine constructor, its main method, or its implementation of any methods of java.lang.Object.\r\nIn the parameters and return values of remote method invocations, objects that are not remote objects are passed by value. Thus, a copy of the object is created in the receiving Java virtual machine. Any changes to the object's state by the receiver are reflected only in the receiver's copy, not in the sender's original instance. Any changes to the object's state by the sender are reflected only in the sender's original instance, not in the receiver's copy.\r\nImplementing the Server's main Method\r\nThe most complex method of the ComputeEngine implementation is the main method. The main method is used to start the ComputeEngine and therefore needs to do the necessary initialization and housekeeping to prepare the server to accept calls from clients. This method is not a remote method, which means that it cannot be invoked from a different Java virtual machine. Because the main method is declared static, the method is not associated with an object at all but rather with the class ComputeEngine.\r\nCreating and Installing a Security Manager\r\nThe main method's first task is to create and install a security manager, which protects access to system resources from untrusted downloaded code running within the Java virtual machine. A security manager determines whether downloaded code has access to the local file system or can perform any other privileged operations.\r\nIf an RMI program does not install a security manager, RMI will not download classes (other than from the local class path) for objects received as arguments or return values of remote method invocations. This restriction ensures that the operations performed by downloaded code are subject to a security policy.\r\nHere's the code that creates and installs a security manager:\r\n\r\nif (System.getSecurityManager() == null) {\r\n    System.setSecurityManager(new SecurityManager());\r\n}\r\n\r\nMaking the Remote Object Available to Clients\r\nNext, the main method creates an instance of ComputeEngine and exports it to the RMI runtime with the following statements:\r\n\r\nCompute engine = new ComputeEngine();\r\nCompute stub =\r\n    (Compute) UnicastRemoteObject.exportObject(engine, 0);\r\n\r\nThe static UnicastRemoteObject.exportObject method exports the supplied remote object so that it can receive invocations of its remote methods from remote clients. The second argument, an int, specifies which TCP port to use to listen for incoming remote invocation requests for the object. It is common to use the value zero, which specifies the use of an anonymous port. The actual port will then be chosen at runtime by RMI or the underlying operating system. However, a non-zero value can also be used to specify a specific port to use for listening. Once the exportObject invocation has returned successfully, the ComputeEngine remote object is ready to process incoming remote invocations.\r\nThe exportObject method returns a stub for the exported remote object. Note that the type of the variable stub must be Compute, not ComputeEngine, because the stub for a remote object only implements the remote interfaces that the exported remote object implements.\r\nThe exportObject method declares that it can throw a RemoteException, which is a checked exception type. The main method handles this exception with its try/catch block. If the exception were not handled in this way, RemoteException would have to be declared in the throws clause of the main method. An attempt to export a remote object can throw a RemoteException if the necessary communication resources are not available, such as if the requested port is bound for some other purpose.\r\nBefore a client can invoke a method on a remote object, it must first obtain a reference to the remote object. Obtaining a reference can be done in the same way that any other object reference is obtained in a program, such as by getting the reference as part of the return value of a method or as part of a data structure that contains such a reference.\r\nThe system provides a particular type of remote object, the RMI registry, for finding references to other remote objects. The RMI registry is a simple remote object naming service that enables clients to obtain a reference to a remote object by name. The registry is typically only used to locate the first remote object that an RMI client needs to use. That first remote object might then provide support for finding other objects.\r\nThe java.rmi.registry.Registry remote interface is the API for binding (or registering) and looking up remote objects in the registry. The java.rmi.registry.LocateRegistry class provides static methods for synthesizing a remote reference to a registry at a particular network address (host and port). These methods create the remote reference object containing the specified network address without performing any remote communication. LocateRegistry also provides static methods for creating a new registry in the current Java virtual machine, although this example does not use those methods. Once a remote object is registered with an RMI registry on the local host, clients on any host can look up the remote object by name, obtain its reference, and then invoke remote methods on the object. The registry can be shared by all servers running on a host, or an individual server process can create and use its own registry.\r\nThe ComputeEngine class creates a name for the object with the following statement:\r\n\r\nString name = \"Compute\";\r\n\r\nThe code then adds the name to the RMI registry running on the server. This step is done later with the following statements:\r\n\r\nRegistry registry = LocateRegistry.getRegistry();\r\nregistry.rebind(name, stub);\r\n\r\nThis rebind invocation makes a remote call to the RMI registry on the local host. Like any remote call, this call can result in a RemoteException being thrown, which is handled by the catch block at the end of the main method.\r\nNote the following about the Registry.rebind invocation:\r\n\r\nThe no-argument overload of LocateRegistry.getRegistry synthesizes a reference to a registry on the local host and on the default registry port, 1099. You must use an overload that has an int parameter if the registry is created on a port other than 1099.\r\nWhen a remote invocation on the registry is made, a stub for the remote object is passed instead of a copy of the remote object itself. Remote implementation objects, such as instances of ComputeEngine, never leave the Java virtual machine in which they were created. Thus, when a client performs a lookup in a server's remote object registry, a copy of the stub is returned. Remote objects in such cases are thus effectively passed by (remote) reference rather than by value.\r\nFor security reasons, an application can only bind, unbind, or rebind remote object references with a registry running on the same host. This restriction prevents a remote client from removing or overwriting any of the entries in a server's registry. A lookup, however, can be requested from any host, local or remote.\r\n\r\nOnce the server has registered with the local RMI registry, it prints a message indicating that it is ready to start handling calls. Then, the main method completes. It is not necessary to have a thread wait to keep the server alive. As long as there is a reference to the ComputeEngine object in another Java virtual machine, local or remote, the ComputeEngine object will not be shut down or garbage collected. Because the program binds a reference to the ComputeEngine in the registry, it is reachable from a remote client, the registry itself. The RMI system keeps the ComputeEngine's process running. The ComputeEngine is available to accept calls and won't be reclaimed until its binding is removed from the registry and no remote clients hold a remote reference to the ComputeEngine object.\r\nThe final piece of code in the ComputeEngine.main method handles any exception that might arise. The only checked exception type that could be thrown in the code is RemoteException, either by the UnicastRemoteObject.exportObject invocation or by the registry rebind invocation. In either case, the program cannot do much more than exit after printing an error message. In some distributed applications, recovering from the failure to make a remote invocation is possible. For example, the application could attempt to retry the operation or choose another server to continue the operation.\r\n",
        "title": "Oracle_Implementing a Remote Interface.txt",
        "type": "Oracle_"
    }, {
        "rank": 3,
        "text": "\r\nMany programmers will never need to implement their own Collections classes. You can go pretty far using the implementations described in the preceding sections of this chapter. However, someday you might want to write your own implementation. It is fairly easy to do this with the aid of the abstract implementations provided by the Java platform. Before we discuss how to write an implementation, let's discuss why you might want to write one.\r\nReasons to Write an Implementation\r\nThe following list illustrates the sort of custom Collections you might want to implement. It is not intended to be exhaustive:\r\n\r\nPersistent: All of the built-in Collection implementations reside in main memory and vanish when the program exits. If you want a collection that will still be present the next time the program starts, you can implement it by building a veneer over an external database. Such a collection might be concurrently accessible by multiple programs.\r\nApplication-specific: This is a very broad category. One example is an unmodifiable Map containing real-time telemetry data. The keys could represent locations, and the values could be read from sensors at these locations in response to the get operation.\r\nHigh-performance, special-purpose: Many data structures take advantage of restricted usage to offer better performance than is possible with general-purpose implementations. For instance, consider a List containing long runs of identical element values. Such lists, which occur frequently in text processing, can be run-length encoded â\u20ac\u201d runs can be represented as a single object containing the repeated element and the number of consecutive repetitions. This example is interesting because it trades off two aspects of performance: It requires less space but more time than an ArrayList.\r\nHigh-performance, general-purpose: The Java Collections Framework's designers tried to provide the best general-purpose implementations for each interface, but many, many data structures could have been used, and new ones are invented every day. Maybe you can come up with something faster!\r\nEnhanced functionality: Suppose you need an efficient bag implementation (also known as a multiset): a Collection that offers constant-time containment checks while allowing duplicate elements. It's reasonably straightforward to implement such a collection atop a HashMap.\r\nConvenience: You may want additional implementations that offer conveniences beyond those offered by the Java platform. For instance, you may frequently need List instances representing a contiguous range of Integers.\r\nAdapter: Suppose you are using a legacy API that has its own ad hoc collections' API. You can write an adapter implementation that permits these collections to operate in the Java Collections Framework. An adapter implementation is a thin veneer that wraps objects of one type and makes them behave like objects of another type by translating operations on the latter type into operations on the former.\r\n\r\nHow to Write a Custom Implementation\r\nWriting a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We'll start with the following example of an implementation of \r\nArrays.asList.\r\n\r\npublic static <T> List<T> asList(T[] a) {\r\n    return new MyArrayList<T>(a);\r\n}\r\n\r\nprivate static class MyArrayList<T> extends AbstractList<T> {\r\n\r\n    private final T[] a;\r\n\r\n    MyArrayList(T[] array) {\r\n        a = array;\r\n    }\r\n\r\n    public T get(int index) {\r\n        return a[index];\r\n    }\r\n\r\n    public T set(int index, T element) {\r\n        T oldValue = a[index];\r\n        a[index] = element;\r\n        return oldValue;\r\n    }\r\n\r\n    public int size() {\r\n        return a.length;\r\n    }\r\n}\r\n\r\nBelieve it or not, this is very close to the implementation that is contained in java.util.Arrays. It's that simple! You provide a constructor and the get, set, and size methods, and AbstractList does all the rest. You get the ListIterator, bulk operations, search operations, hash code computation, comparison, and string representation for free.\r\nSuppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you'll know which methods to override to get the performance you want. The preceding implementation's performance is fine, but it can be improved a bit. In particular, the toArray method iterates over the List, copying one element at a time. Given the internal representation, it's a lot faster and more sensible just to clone the array.\r\n\r\npublic Object[] toArray() {\r\n    return (Object[]) a.clone();\r\n}\r\n\r\nWith the addition of this override and a few more like it, this implementation is exactly the one found in java.util.Arrays. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.\r\nThe following list summarizes the abstract implementations:\r\n\r\n\r\nAbstractCollection â\u20ac\u201d a Collection that is neither a Set nor a List. At a minimum, you must provide the iterator and the size methods.\r\n\r\nAbstractSet â\u20ac\u201d a Set; use is identical to AbstractCollection.\r\n\r\nAbstractList â\u20ac\u201d a List backed up by a random-access data store, such as an array. At a minimum, you must provide the positional access methods (get and, optionally, set, remove, and add) and the size method. The abstract class takes care of listIterator (and iterator).\r\n\r\nAbstractSequentialList â\u20ac\u201d a List backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the listIterator and size methods. The abstract class takes care of the positional access methods. (This is the opposite of AbstractList.)\r\n\r\nAbstractQueue â\u20ac\u201d at a minimum, you must provide the offer, peek, poll, and size methods and an iterator supporting remove.\r\n\r\nAbstractMap â\u20ac\u201d a Map. At a minimum you must provide the entrySet view. This is typically implemented with the AbstractSet class. If the Map is modifiable, you must also provide the put method.\r\n\r\nThe process of writing a custom implementation follows:\r\n\r\nChoose the appropriate abstract implementation class from the preceding list.\r\nProvide implementations for all the abstract methods of the class. If your custom collection is to be modifiable, you will have to override one or more of the concrete methods as well. The API documentation for the abstract implementation class will tell you which methods to override.\r\nTest and, if necessary, debug the implementation. You now have a working custom collection implementation.\r\nIf you are concerned about performance, read the API documentation of the abstract implementation class for all the methods whose implementations you're inheriting. If any seem too slow, override them. If you override any methods, be sure to measure the performance of the method before and after the override. How much effort you put into tweaking performance should be a function of how much use the implementation will get and how critical to performance its use is. (Often this step is best omitted.)\r\n\r\n",
        "title": "Oracle_Custom Collection Implementations.txt",
        "type": "Oracle_"
    }, {
        "rank": 4,
        "text": "\r\nIn light of the above discussion, a thread is the smallest unit of processing that can be scheduled by an operating system. Therefore, using threads, a programmer can effectively create two or more tasks[1]that run at the same time. The first call-to-action is to implement a set of tasks that a particular thread would execute. To do so, we require the creation of aRunnableprocess.\r\n\r\nCreating a Runnable process block[edit]\r\n\r\nARunnableprocess block is a simple class that implements arun()method. Within therun()method is the actual task that needs to be executed by a running thread. By implementing a class with theRunnableinterface, we ensure that the class holds arun()method. Consider the following program:\r\n\r\n\r\nIn the above code, we create a class calledRunnableProcessand implement theRunnableinterface to ensure that we have arun()method in the class declaration.\r\n\r\n\r\nWe then declare the rest of the logic for the class. For the constructor, we take aStringparameter that would serve as the name of the class. Then, we initialize the class member variabletimewith a random number between0and999. To ensure the initialization of a random number, we use theRandomclass in thejava.utilpackage.\r\n\r\n\r\nThe actual task that would be executed per this runnable block is presented within therun()method. To keep safe from exceptions occurring because of the concurrent programming, we wrap the code within this method with atry..catchblock. The executing task actually consists of just three statements. The first outputs the provided name for the Runnable process, and the last reports that the thread has executed. Perhaps the most intriguing part of the code is the second statement:Thread.sleep(...).\r\n\r\n\r\nThis statement allows the thread executing the current runnable block to halt its execution for the given amount of time. This time is presented in milliseconds. But for our convenience, this time would be the random number generated in the constructor and can be anywhere between0and999milliseconds. We will explore this in a later section. Creating aRunnableprocess block is just the beginning. No code is actually executed. To do so, we would require the creation of threads that would then individually execute this task.\r\n\r\nCreating threads[edit]\r\n\r\nOnce we have aRunnableprocess block, we can create various threads that can then execute the logic encased within such blocks. Multithreading capabilities in Java are utilized and manipulated using theThreadclass. AThreadobject therefore holds all the necessary logic and devices to create truly multithreaded programs. Consider the following program:\r\n\r\n\r\nCreating threads is as simple as the above program suggests. You just have to create an object of theThreadclass and pass a reference to aRunnableprocess object. In the case above, we present theThreadconstructor with the class object for theRunnableProcessclass that we created incode listing 1. But for each object, we give a different name (i.e.,\"Thread-1\"and\"Thread-2\", etc.) to differentiate between the threeThreadobjects. The above example only declaresThreadobjects and hasn't yet started them for execution.\r\n\r\nStarting threads[edit]\r\n\r\nNow, that we know how to effectively create aRunnableprocess block and aThreadobject that executes it, we need to understand how to start the createdThreadobjects. This couldn't be simpler. For this process, we will be calling thestart()method on theThreadobjects and voilÃ , our threads will begin executing their individual process tasks.\r\n\r\n\r\nThe above code will start all three declared threads. This way, all three threads will begin their execution one-by-one. However, this being concurrent programming and us having declared random times for the halting of the execution, the outputs for every one of us would differ. Following is the output we received when we executed the above program.\r\n\r\nOutput forcode listing 3Thread-1 is sleeping for 419\r\nThread-3 is sleeping for 876\r\nThread-2 is sleeping for 189\r\nThread-2 is done\r\nThread-1 is done\r\nThread-3 is done\r\n\r\nIt should be noted that the execution of theThreaddidn't occur in the desired order. Instead of the ordert1â\u20ac\u201ct2â\u20ac\u201ct3, the threads executed in the order oft1â\u20ac\u201ct3â\u20ac\u201ct2. The order in which the threads are executed is completely dependent on the operating system and may change for every execution of the program, thus making output of multithreaded application difficult to predict and control. Some people suggest that this is the major reason that adds to the complexity of multithreaded programming and its debugging. However, it should be observed that once the threads were put to sleep using theThread.sleep(...)function, the execution intervals and order can be predicted quite capably. The thread with the least amount of sleeping time wast2(\"Thread-2\") with189milliseconds of sleep hence it got called first. Thent1was called and finallyt3was called.\r\n\r\n",
        "title": "Threads and Runnables_Threads_text.txt",
        "type": "text"
    }, {
        "rank": 5,
        "text": "\r\nDebugging and Symbolic Information[edit]\r\n\r\n\r\n\r\nTo do:Complete this section.\r\n\r\n\r\n\r\nTo debug into Java system classes such as String and ArrayList, you need a special version of the JRE which is compiled with \"debug information\". The JRE included inside the JDK provides this info, but the regular JRE does not. Regular JRE does not include this info to ensure better performance.\r\n\r\n\r\nModern compilers do a pretty good job converting your high-level code, with its nicely indented and nested control structures and arbitrarily typed variables into a big pile of bits called machine code (or bytecode in case of Java), the sole purpose of which is to run as fast as possible on the target CPU (virtual CPU of your JVM). Java code gets converted into several machine code instructions. Variables are shoved all over the place â\u20ac\u201c into the stack, into registers, or completely optimized away. Structures and objects donâ\u20ac™t even exist in the resulting code â\u20ac\u201c theyâ\u20ac™re merely an abstraction that gets translated to hard-coded offsets into memory buffers.\r\n\r\nSo how does a debugger know where to stop when you ask it to break at the entry to some function? How does it manage to find what to show you when you ask it for the value of a variable? The answer is â\u20ac\u201c debugging information.\r\n\r\nDebugging information is generated by the compiler together with the machine code. It is a representation of the relationship between the executable program and the original source code. This information is encoded into a pre-defined format and stored alongside the machine code. Many such formats were invented over the years for different platforms and executable files.\r\n\r\nSymbolic InformationÂ : Symbolic resolution is done at class loading time at linking resolution step.\r\nIt is the process of replacing symbolic references from the type with direct references. It is done by searching into method area to locate the referenced entity\r\n\r\n",
        "title": "Compilation_Compiler Options_text.txt",
        "type": "text"
    }, {
        "rank": 6,
        "text": "\r\nIn Java and J2EE programming, you can call a method on an object only if it is casted to a class or an interface that declares it. The structured definition of bean properties is very useful for comparing a single common property across several objects that are not and should not be related by inheritance.\r\nFor example, a program may contain both a bean representing a company's employees, and another containing a list of buildings that a company occupies. A programmer writing a function calledlistAssetNames()wants to write a simple way of getting the field \"name\" from several beans that can get the field from both Employee and Building beans, and that can be easily adapted to get the same field from other types of beans that may not be written yet.\r\nWhile this could be done by rewriting both Employee and Building so that they each inherit from one class named NamedObject, or by creating a NamedObject interface, both methods have their own problems. Using inheritance is limiting, as each child class can only inherit from one parent class, which limits the number of different classes that can share properties, as well as the number of common properties that can be shared. Furthermore, using inheritance to express relationships other than a simple \"is-a\" relationship can be confusing, as can looking through dozens of class definitions to find where a single \"dumb\" getter function is implemented. Creating an interface fixes the problems caused by the multiple inheritance rule, as a class can use any number of interfaces, but it still requires every shared property to be explicitly spelled out.\r\nThe simplest, most elegant way to deal with this type of relationship is to read the bean properties using introspection. The jakartaBeanUtilspackage is a common way of handling objects that need to be related in this way, as it takes advantage of the regularity of JavaBean naming conventions.\r\n\r\n\r\nor\r\n\r\n\r\n",
        "title": "JavaBeans_Introspection_text.txt",
        "type": "text"
    }, {
        "rank": 7,
        "text": "\r\nThe following rules define a simple strategy for creating immutable objects. Not all classes documented as \"immutable\" follow these rules. This does not necessarily mean the creators of these classes were sloppy â\u20ac\u201d they may have good reason for believing that instances of their classes never change after construction. However, such strategies require sophisticated analysis and are not for beginners.\r\n\r\nDon't provide \"setter\" methods â\u20ac\u201d methods that modify fields or objects referred to by fields.\r\nMake all fields final and private.\r\nDon't allow subclasses to override methods. The simplest way to do this is to declare the class as final. A more sophisticated approach is to make the constructor private and construct instances in factory methods.\r\nIf the instance fields include references to mutable objects, don't allow those objects to be changed:\r\n\r\nDon't provide methods that modify the mutable objects.\r\nDon't share references to the mutable objects. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.\r\n\r\n\r\n\r\nApplying this strategy to SynchronizedRGB results in the following steps:\r\n\r\nThere are two setter methods in this class. The first one, set, arbitrarily transforms the object, and has no place in an immutable version of the class. The second one, invert, can be adapted by having it create a new object instead of modifying the existing one.\r\nAll fields are already private; they are further qualified as final.\r\nThe class itself is declared final.\r\nOnly one field refers to an object, and that object is itself immutable. Therefore, no safeguards against changing the state of \"contained\" mutable objects are necessary.\r\n\r\nAfter these changes, we have \r\nImmutableRGB:\r\n\r\n\r\nfinal public class ImmutableRGB {\r\n\r\n    // Values must be between 0 and 255.\r\n    final private int red;\r\n    final private int green;\r\n    final private int blue;\r\n    final private String name;\r\n\r\n    private void check(int red,\r\n                       int green,\r\n                       int blue) {\r\n        if (red < 0 || red > 255\r\n            || green < 0 || green > 255\r\n            || blue < 0 || blue > 255) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n    }\r\n\r\n    public ImmutableRGB(int red,\r\n                        int green,\r\n                        int blue,\r\n                        String name) {\r\n        check(red, green, blue);\r\n        this.red = red;\r\n        this.green = green;\r\n        this.blue = blue;\r\n        this.name = name;\r\n    }\r\n\r\n\r\n    public int getRGB() {\r\n        return ((red << 16) | (green << 8) | blue);\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public ImmutableRGB invert() {\r\n        return new ImmutableRGB(255 - red,\r\n                       255 - green,\r\n                       255 - blue,\r\n                       \"Inverse of \" + name);\r\n    }\r\n}\r\n\r\n",
        "title": "Oracle_A Strategy for Defining Immutable Objects.txt",
        "type": "Oracle_"
    }, {
        "rank": 8,
        "text": "\r\n\r\nThe \r\nObject class, in the java.lang package, sits at the top of the class hierarchy tree. Every class is a descendant, direct or indirect, of the Object class. Every class you use or write inherits the instance methods of Object. You need not use any of these methods, but, if you choose to do so, you may need to override them with code that is specific to your class. The methods inherited from Object that are discussed in this section are:\r\n\r\nprotected Object clone() throws CloneNotSupportedException\r\nÂ Â Â Â Â  Creates and returns a copy of this object.\r\npublic boolean equals(Object obj)\r\nÂ Â Â Â Â  Indicates whether some other object is \"equal to\" this one.\r\nprotected void finalize() throws Throwable\r\nÂ Â Â Â Â  Called by the garbage collector on an object when garbage\r\nÂ Â Â Â Â Â collection determines that there are no more references to the object\r\npublic final Class getClass()\r\nÂ Â Â Â Â  Returns the runtime class of an object.\r\npublic int hashCode()\r\nÂ Â Â Â Â  Returns a hash code value for the object.\r\npublic String toString()\r\nÂ Â Â Â Â  Returns a string representation of the object.\r\n\r\nThe notify, notifyAll, and wait methods of Object all play a part in synchronizing the activities of independently running threads in a program, which is discussed in a later \r\nlesson\r\nand won't be covered here. There are five of these methods:\r\n\r\npublic final void notify()\r\npublic final void notifyAll()\r\npublic final void wait()\r\npublic final void wait(long timeout)\r\npublic final void wait(long timeout, int nanos)\r\n\r\nNote:Â There are some subtle aspects to a number of these methods, especially the clone method.\r\n\r\nThe clone() Method\r\nIf a class, or one of its superclasses, implements the Cloneable interface, you can use the clone() method to create a copy from an existing object. To create a clone, you write:\r\n\r\naCloneableObject.clone();\r\n\r\nObject's implementation of this method checks to see whether the object on which clone() was invoked implements the Cloneable interface. If the object does not, the method throws a CloneNotSupportedException exception. Exception handling will be covered in a later \r\nlesson. \r\nFor the moment, you need to know that clone() must be declared as\r\n\r\nprotected Object clone() throws CloneNotSupportedException\r\n\r\nor:\r\n\r\npublic Object clone() throws CloneNotSupportedException\r\n\r\nif you are going to write a clone() method to override the one in Object.\r\nIf the object on which clone() was invoked does implement the Cloneable interface, Object's implementation of the clone() method creates an object of the same class as the original object and initializes the new object's member variables to have the same values as the original object's corresponding member variables.\r\nThe simplest way to make your class cloneable is to add implements Cloneable to your class's declaration. then your objects can invoke the clone() method.\r\nFor some classes, the default behavior of Object's clone() method works just fine. If, however, an object contains a reference to an external object, say ObjExternal, you may need to override clone() to get correct behavior. Otherwise, a change in ObjExternal made by one object will be visible in its clone also. This means that the original object and its clone are not independentâ\u20ac\u201dto decouple them, you must override clone() so that it clones the object and ObjExternal. Then the original object references ObjExternal and the clone references a clone of ObjExternal, so that the object and its clone are truly independent.\r\nThe equals() Method\r\nThe equals() method compares two objects for equality and returns true if they are equal. The equals() method provided in the Object class uses the identity operator (==) to determine whether two objects are equal. For primitive data types, this gives the correct result. For objects, however, it does not. The equals() method provided by Object tests whether the object references are equalâ\u20ac\u201dthat is, if the objects compared are the exact same object.\r\nTo test whether two objects are equal in the sense of equivalency (containing the same information), you must override the equals() method. Here is an example of a Book class that overrides equals():\r\n\r\npublic class Book {\r\n    ...\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof Book)\r\n            return ISBN.equals((Book)obj.getISBN()); \r\n        else\r\n            return false;\r\n    }\r\n}\r\n\r\nConsider this code that tests two instances of the Book class for equality:\r\n\r\n// Swing Tutorial, 2nd edition\r\nBook firstBook  = new Book(\"0201914670\");\r\nBook secondBook = new Book(\"0201914670\");\r\nif (firstBook.equals(secondBook)) {\r\n    System.out.println(\"objects are equal\");\r\n} else {\r\n    System.out.println(\"objects are not equal\");\r\n}\r\n\r\nThis program displays objects are equal even though firstBook and secondBook reference two distinct objects. They are considered equal because the objects compared contain the same ISBN number.\r\nYou should always override the equals() method if the identity operator is not appropriate for your class.\r\nNote:Â If you override equals(), you must override hashCode() as well.\r\n\r\nThe finalize() Method\r\nThe Object class provides a callback method, finalize(), that may be invoked on an object when it becomes garbage. Object's implementation of finalize() does nothingâ\u20ac\u201dyou can override finalize() to do cleanup, such as freeing resources.\r\nThe finalize() method may be called automatically by the system, but when it is called, or even if it is called, is uncertain. Therefore, you should not rely on this method to do your cleanup for you. For example, if you don't close file descriptors in your code after performing I/O and you expect finalize() to close them for you, you may run out of file descriptors.\r\nThe getClass() Method\r\nYou cannot override getClass.\r\nThe getClass() method returns a Class object, which has methods you can use to get information about the class, such as its name (getSimpleName()), its superclass (getSuperclass()), and the interfaces it implements (getInterfaces()). For example, the following method gets and displays the class name of an object:\r\n\r\nvoid printClassName(Object obj) {\r\n    System.out.println(\"The object's\" + \" class is \" +\r\n        obj.getClass().getSimpleName());\r\n}\r\n\r\nThe \r\nClass class, in the java.lang package, has a large number of methods (more than 50). For example, you can test to see if the class is an annotation (isAnnotation()), an interface (isInterface()), or an enumeration (isEnum()). You can see what the object's fields are (getFields()) or what its methods are (getMethods()), and so on.\r\nThe hashCode() Method\r\nThe value returned by hashCode() is the object's hash code, which is the object's memory address in hexadecimal.\r\nBy definition, if two objects are equal, their hash code must also be equal. If you override the equals() method, you change the way two objects are equated and Object's implementation of hashCode() is no longer valid. Therefore, if you override the equals() method, you must also override the hashCode() method as well.\r\nThe toString() Method\r\nYou should always consider overriding the toString() method in your classes.\r\nThe Object's toString() method returns a String representation of the object, which is very useful for debugging. The String representation for an object depends entirely on the object, which is why you need to override toString() in your classes.\r\nYou can use toString() along with System.out.println() to display a text representation of an object, such as an instance of Book:\r\n\r\nSystem.out.println(firstBook.toString());\r\n\r\nwhich would, for a properly overridden toString() method, print something useful, like this:\r\n\r\nISBN: 0201914670; The Swing Tutorial; A Guide to Constructing GUIs, 2nd Edition\r\n\r\n",
        "title": "Oracle_Object as a Superclass.txt",
        "type": "Oracle_"
    }, {
        "rank": 9,
        "text": "\r\nNow that you know what exceptions are and how to use them, it's time to learn the advantages of using exceptions in your programs.\r\nAdvantage 1: Separating Error-Handling Code from \"Regular\" Code\r\nExceptions provide the means to separate the details of what to do when something out of the ordinary happens from the main logic of a program. In traditional programming, error detection, reporting, and handling often lead to confusing spaghetti code. For example, consider the pseudocode method here that reads an entire file into memory.\r\n\r\nreadFile {\r\n    open the file;\r\n    determine its size;\r\n    allocate that much memory;\r\n    read the file into memory;\r\n    close the file;\r\n}\r\n\r\nAt first glance, this function seems simple enough, but it ignores all the following potential errors.\r\n\r\nWhat happens if the file can't be opened?\r\nWhat happens if the length of the file can't be determined?\r\nWhat happens if enough memory can't be allocated?\r\nWhat happens if the read fails?\r\nWhat happens if the file can't be closed?\r\n\r\nTo handle such cases, the readFile function must have more code to do error detection, reporting, and handling. Here is an example of what the function might look like.\r\n\r\nerrorCodeType readFile {\r\n    initialize errorCode = 0;\r\n    \r\n    open the file;\r\n    if (theFileIsOpen) {\r\n        determine the length of the file;\r\n        if (gotTheFileLength) {\r\n            allocate that much memory;\r\n            if (gotEnoughMemory) {\r\n                read the file into memory;\r\n                if (readFailed) {\r\n                    errorCode = -1;\r\n                }\r\n            } else {\r\n                errorCode = -2;\r\n            }\r\n        } else {\r\n            errorCode = -3;\r\n        }\r\n        close the file;\r\n        if (theFileDidntClose && errorCode == 0) {\r\n            errorCode = -4;\r\n        } else {\r\n            errorCode = errorCode and -4;\r\n        }\r\n    } else {\r\n        errorCode = -5;\r\n    }\r\n    return errorCode;\r\n}\r\n\r\nThere's so much error detection, reporting, and returning here that the original seven lines of code are lost in the clutter. Worse yet, the logical flow of the code has also been lost, thus making it difficult to tell whether the code is doing the right thing: Is the file really being closed if the function fails to allocate enough memory? It's even more difficult to ensure that the code continues to do the right thing when you modify the method three months after writing it. Many programmers solve this problem by simply ignoring it â\u20ac\u201d errors are reported when their programs crash.\r\nExceptions enable you to write the main flow of your code and to deal with the exceptional cases elsewhere. If the readFile function used exceptions instead of traditional error-management techniques, it would look more like the following.\r\n\r\nreadFile {\r\n    try {\r\n        open the file;\r\n        determine its size;\r\n        allocate that much memory;\r\n        read the file into memory;\r\n        close the file;\r\n    } catch (fileOpenFailed) {\r\n       doSomething;\r\n    } catch (sizeDeterminationFailed) {\r\n        doSomething;\r\n    } catch (memoryAllocationFailed) {\r\n        doSomething;\r\n    } catch (readFailed) {\r\n        doSomething;\r\n    } catch (fileCloseFailed) {\r\n        doSomething;\r\n    }\r\n}\r\n\r\nNote that exceptions don't spare you the effort of doing the work of detecting, reporting, and handling errors, but they do help you organize the work more effectively.\r\nAdvantage 2: Propagating Errors Up the Call Stack\r\nA second advantage of exceptions is the ability to propagate error reporting up the call stack of methods. Suppose that the readFile method is the fourth method in a series of nested method calls made by the main program: method1 calls method2, which calls method3, which finally calls readFile.\r\n\r\nmethod1 {\r\n    call method2;\r\n}\r\n\r\nmethod2 {\r\n    call method3;\r\n}\r\n\r\nmethod3 {\r\n    call readFile;\r\n}\r\n\r\nSuppose also that method1 is the only method interested in the errors that might occur within readFile. Traditional error-notification techniques force method2 and method3 to propagate the error codes returned by readFile up the call stack until the error codes finally reach method1â\u20ac\u201dthe only method that is interested in them.\r\n\r\nmethod1 {\r\n    errorCodeType error;\r\n    error = call method2;\r\n    if (error)\r\n        doErrorProcessing;\r\n    else\r\n        proceed;\r\n}\r\n\r\nerrorCodeType method2 {\r\n    errorCodeType error;\r\n    error = call method3;\r\n    if (error)\r\n        return error;\r\n    else\r\n        proceed;\r\n}\r\n\r\nerrorCodeType method3 {\r\n    errorCodeType error;\r\n    error = call readFile;\r\n    if (error)\r\n        return error;\r\n    else\r\n        proceed;\r\n}\r\n\r\nRecall that the Java runtime environment searches backward through the call stack to find any methods that are interested in handling a particular exception. A method can duck any exceptions thrown within it, thereby allowing a method farther up the call stack to catch it. Hence, only the methods that care about errors have to worry about detecting errors.\r\n\r\nmethod1 {\r\n    try {\r\n        call method2;\r\n    } catch (exception e) {\r\n        doErrorProcessing;\r\n    }\r\n}\r\n\r\nmethod2 throws exception {\r\n    call method3;\r\n}\r\n\r\nmethod3 throws exception {\r\n    call readFile;\r\n}\r\n\r\nHowever, as the pseudocode shows, ducking an exception requires some effort on the part of the middleman methods. Any checked exceptions that can be thrown within a method must be specified in its throws clause.\r\nAdvantage 3: Grouping and Differentiating Error Types\r\nBecause all exceptions thrown within a program are objects, the grouping or categorizing of exceptions is a natural outcome of the class hierarchy. An example of a group of related exception classes in the Java platform are those defined in java.io â\u20ac\u201d IOException and its descendants. IOException is the most general and represents any type of error that can occur when performing I/O. Its descendants represent more specific errors. For example, FileNotFoundException means that a file could not be located on disk.\r\nA method can write specific handlers that can handle a very specific exception. The FileNotFoundException class has no descendants, so the following handler can handle only one type of exception.\r\n\r\ncatch (FileNotFoundException e) {\r\n    ...\r\n}\r\n\r\nA method can catch an exception based on its group or general type by specifying any of the exception's superclasses in the catch statement. For example, to catch all I/O exceptions, regardless of their specific type, an exception handler specifies an IOException argument.\r\n\r\ncatch (IOException e) {\r\n    ...\r\n}\r\n\r\nThis handler will be able to catch all I/O exceptions, including FileNotFoundException, EOFException, and so on. You can find details about what occurred by querying the argument passed to the exception handler. For example, use the following to print the stack trace.\r\n\r\ncatch (IOException e) {\r\n    // Output goes to System.err.\r\n    e.printStackTrace();\r\n    // Send trace to stdout.\r\n    e.printStackTrace(System.out);\r\n}\r\n\r\nYou could even set up an exception handler that handles any Exception with the handler here.\r\n\r\n// A (too) general exception handler\r\ncatch (Exception e) {\r\n    ...\r\n}\r\n\r\nThe Exception class is close to the top of the Throwable class hierarchy. Therefore, this handler will catch many other exceptions in addition to those that the handler is intended to catch. You may want to handle exceptions this way if all you want your program to do, for example, is print out an error message for the user and then exit.\r\nIn most situations, however, you want exception handlers to be as specific as possible. The reason is that the first thing a handler must do is determine what type of exception occurred before it can decide on the best recovery strategy. In effect, by not catching specific errors, the handler must accommodate any possibility. Exception handlers that are too general can make code more error-prone by catching and handling exceptions that weren't anticipated by the programmer and for which the handler was not intended.\r\nAs noted, you can create groups of exceptions and handle exceptions in a general fashion, or you can use the specific exception type to differentiate exceptions and handle exceptions in an exact fashion.\r\n",
        "title": "Oracle_Advantages of Exceptions.txt",
        "type": "Oracle_"
    }, {
        "rank": 10,
        "text": "\r\nUse the information in this lesson and the component \r\nhow-to sections to help you complete these questions and exercises.\r\nQuestions\r\n1. Find the component that best fits each of the following needs. Write down both the componentÃ¢Â\u20acÂ™s common name (such as Ã¢Â\u20acÂœframeÃ¢Â\u20acÂ?) and find the component's how-to page online.\r\na. A component that lets the user pick a color.\r\n\r\nb. A component that displays an icon, but that doesnÃ¢Â\u20acÂ™t react to user clicks.\r\n\r\nc. A component that looks like a button and that, when pressed, brings up a menu of items for the user to choose from.\r\n\r\nd. A container that looks like a frame, but that appears (usually with other, similar containers) within a real frame.\r\n\r\ne. A container that lets the user determine how two components share a limited amount of space.\r\n2. Which method do you use to add a menu bar to a top-level container such as a JFrame?\r\n3. Which method do you use to specify the default button for a top-level container such as a JFrame or JDialog?\r\n4. Which method do you use to enable and disable components such as JButtons? What class is it defined in?\r\n5. a. Which Swing components use ListSelectionModel? [Hint: The Ã¢Â\u20acÂœUseÃ¢Â\u20acÂ? link at the top of the specification for each interface and class takes you to a page showing where in the API that interface or class is referenced.]\r\nb. Do those components use any other models to handle other aspects of the componentsÃ¢Â\u20acÂ™ state? If so, list the other modelsÃ¢Â\u20acÂ™ types.\r\n6. Which type of model holds a text componentÃ¢Â\u20acÂ™s content?\r\nExercises\r\n1. Implement a program with a GUI that looks like the one shown below. Put the main method in a class named MyDemo1.\r\n\r\n\r\n2. Make a copy of MyDemo1.java named MyDemo2.java. Add a menu bar to MyDemo2.\r\n\r\n3. Copy MyDemo1.java to MyDemo3.java. Add a button (JButton) to MyDemo3.java. Make it the default button.\r\nÂ \r\n\r\nCheck your answers.\r\n",
        "title": "Oracle_Questions and Exercises Using Swing Components.txt",
        "type": "Oracle_"
    }]
}

post7_rec = {
    "response": [{
        "rank": 1,
        "text": "\r\nJust as data streams support I/O of primitive data types, object streams support I/O of objects. Most, but not all, standard classes support serialization of their objects. Those that do implement the marker interface \r\nSerializable.\r\nThe object stream classes are \r\nObjectInputStream and \r\nObjectOutputStream. These classes implement \r\nObjectInput and \r\nObjectOutput, which are subinterfaces of DataInput and DataOutput. That means that all the primitive data I/O methods covered in Data Streams are also implemented in object streams. So an object stream can contain a mixture of primitive and object values. The \r\nObjectStreams example illustrates this. ObjectStreams creates the same application as DataStreams, with a couple of changes. First, prices are now \r\nBigDecimalobjects, to better represent fractional values. Second, a \r\nCalendar object is written to the data file, indicating an invoice date.\r\nIf readObject() doesn't return the object type expected, attempting to cast it to the correct type may throw a \r\nClassNotFoundException. In this simple example, that can't happen, so we don't try to catch the exception. Instead, we notify the compiler that we're aware of the issue by adding ClassNotFoundException to the main method's throws clause.\r\nOutput and Input of Complex Objects\r\nThe writeObject and readObject methods are simple to use, but they contain some very sophisticated object management logic. This isn't important for a class like Calendar, which just encapsulates primitive values. But many objects contain references to other objects. If readObject is to reconstitute an object from a stream, it has to be able to reconstitute all of the objects the original object referred to. These additional objects might have their own references, and so on. In this situation, writeObject traverses the entire web of object references and writes all objects in that web onto the stream. Thus a single invocation of writeObject can cause a large number of objects to be written to the stream.\r\nThis is demonstrated in the following figure, where writeObject is invoked to write a single object named a. This object contains references to objects b and c, while b contains references to d and e. Invoking writeobject(a) writes not just a, but all the objects necessary to reconstitute a, so the other four objects in this web are written also. When a is read back by readObject, the other four objects are read back as well, and all the original object references are preserved.\r\n",
        "title": "Oracle_Object Streams.txt",
        "type": "Oracle_"
    }, {
        "rank": 2,
        "text": " /**\r\n  * -- A class extended from a Thread; Responsible to service one client --\r\n  */\r\n class '''ComServerThread''' extends Thread\r\n {\r\n    private Socket clientSocket = null;\r\n    COM_DATA tDataFromClient;\r\n    COM_DATA tDataToClient; \r\n    ObjectInputStream oIn;\r\n    ObjectOutputStream oOut;\r\n    /**\r\n     * -- Constructor --\r\n     */\r\n    public ComServerThread( Socket socket )\r\n    {\r\n       super( \"ComServerThread\" );\r\n       this.clientSocket = socket;\r\n    } // -- End of ComServerThread() constructor --\r\n    /**\r\n     * -- Overrun from the Thread (super) class --\r\n     */\r\n    public void run()\r\n    {\r\n       try {\r\n          // --- Create the Writer; will be used to send data to client ---\r\n          oOut = new ObjectOutputStream( clientSocket.getOutputStream() );\r\n          // --- Create the Reader; will be used to get data from client ---\r\n          oIn  = new ObjectInputStream( clientSocket.getInputStream() );\r\n          // --- Create a new protocol object ---\r\n          ComProtocol comp = new ComProtocol();\r\n          // --- Send something to client to indicate that server is ready ---\r\n          tDataToClient  = '''comp.processInput( null );'''\r\n          '''sendDataToClient'''( tDataToClient, oOut );\r\n          // --- Get the data from the client ---\r\n          while ( true )\r\n          {\r\n             try {\r\n                tDataFromClient = '''getDataFromClient( oIn )''';\r\n                // --- Parse the request and get the reply ---\r\n                tDataToClient = '''comp.processInput( tDataFromClient );'''\r\n                // --- Send data to the Client ---\r\n                '''sendDataToClient'''( tDataToClient, oOut );\r\n             }\r\n             catch ( EOFException e ) {\r\n                System.out.println( \"Client Disconnected, Bye, Bye\" );\r\n                break;\r\n             }\r\n             // --- See if the Client wanted to terminate the connection ---\r\n             if ( tDataToClient.bExit )\r\n             {\r\n                System.out.println( \"Client said Bye. Bye\" );\r\n                break;\r\n             }\r\n          }\r\n          // --- Close resources;  This client is gone ---\r\n          comp.Final();\r\n          oOut.close();\r\n          oIn.close();\r\n          clientSocket.close();\r\n       } catch ( IOException e ) {\r\n        e.printStackTrace();\r\n       }\r\n    } // -- End of run() Method --\r\n    /**\r\n     * Get data from Client \r\n     */\r\n    private static COM_DATA '''getDataFromClient'''( ObjectInputStream oIn ) throws IOException                                                                         \r\n    {\r\n        COM_DATA  tDataFromClient = null;         \r\n        // --- Initialize variables ---\r\n        //   tDataFromClient = new COM_DATA();\r\n        while ( tDataFromClient == null )\r\n        {\r\n           try {\r\n              // --- Read Line Number first --\r\n              tDataFromClient = (COM_DATA) oIn.readObject();\r\n           } catch ( ClassNotFoundException e ) {\r\n               System.out.println( \"ClassNotFound\" );\r\n           }\r\n        }\r\n        System.out.println( \"Get: \" + tDataFromClient.comData );\r\n     return tDataFromClient;\r\n    } // --- getDataFromClient() Method --- \r\n    /**\r\n     * Send data to Client \r\n     */\r\n    private static void '''sendDataToClient'''( COM_DATA tDataToClient,\r\n                                           ObjectOutputStream  oOut ) throws IOException\r\n    {         \r\n        System.out.println( \"Sent: \" + tDataToClient.comData );\r\n        oOut.writeObject( tDataToClient );\r\n      return;\r\n    } // -- End of sendDataToClient() Method --\r\n } // --- End of ComServerThread class ---\r\n",
        "title": "Client Server_1.2 ComServerThread_code.txt",
        "type": "code"
    }, {
        "rank": 3,
        "text": "\r\nWhen an object is sent through a network, the object needs to bere-createdat the receiving host.\r\n\r\nObject SerializationThe termObject Serializationrefers to the act of converting the object to a byte stream. The byte stream can be stored on the file system or can be sent through a network.At a later time the object can be re-created from that stream of bytes. The only requirement is that the same class has to be available both times, when the object is serialized and also when the object is re-created. If that happens on different servers, then the same class must be available on both servers.  Same class means that exactly the same version of the class must be available, otherwise the object won't be able to be re-created. This is a maintenance problem for those applications where java serialization is used to make objects persistent or to sent the object through the network.When a class is modified, there could be a problem re-creating those objects that were serialized using an earlier version of the class.\r\n\r\nJava has built-in support for serialization, using theSerializableinterface; however, a class must first implement theSerializableinterface.\r\nBy default, a class will have all of its fields serialized when converted into a data stream (withtransientfields being skipped).  If additional handling is required beyond the default of writing all fields, you need to provide an implementation for the following three methods:\r\n\r\nprivate void writeObject(java.io.ObjectOutputStream out) throws IOException;\r\n\r\nprivate void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;\r\n\r\nprivate void readObjectNoData() throws ObjectStreamException;\r\n\r\nIf the object needs to write or provide a replacement object during serialization, it needs to implement the following two methods, with any access specifier:\r\n\r\nObject writeReplace() throws ObjectStreamException;\r\n\r\nObject readResolve() throws ObjectStreamException;\r\n\r\nNormally, a minor change to the class can cause the serialization to fail.  You can still allow the class to be loaded by defining the serialization version id:\r\n\r\n\r\n",
        "title": "Object Lifecycle_Re-creating an object received from a remote source_text.txt",
        "type": "text"
    }, {
        "rank": 4,
        "text": "\r\nTo serialize an object means to convert its state to a byte stream so that the byte stream can be reverted back into a copy of the object. A Java object is serializable if its class or any of its superclasses implements either the java.io.Serializable interface or its subinterface, java.io.Externalizable. Deserialization is the process of converting the serialized form of an object back into a copy of the object.\r\nFor example, the java.awt.Button class implements the Serializable interface, so you can serialize a java.awt.Button object and store that serialized state in a file. Later, you can read back the serialized state and deserialize into a java.awt.Button object.\r\nThe Java platform specifies a default way by which serializable objects are serialized. A (Java) class can override this default serialization and define its own way of serializing objects of that class. The \r\nObject Serialization Specification describes object serialization in detail.\r\nWhen an object is serialized, information that identifies its class is recorded in the serialized stream. However, the class's definition (\"class file\") itself is not recorded. It is the responsibility of the system that is deserializing the object to determine how to locate and load the necessary class files. For example, a Java application might include in its classpath a JAR file that contains the class files of the serialized object(s) or load the class definitions by using information stored in the directory, as explained later in this lesson. \r\nBinding a Serializable Object\r\nYou can store a serializable object in the directory if the underlying service provider supports that action, as does Oracle's LDAP service provider.\r\nThe following example invokes \r\nContext.bind to bind an AWT button to the name \"cn=Button\". To associate attributes with the new binding, you use \r\nDirContext.bind. To overwrite an existing binding, use \r\nContext.rebind and \r\nDirContext.rebind.\r\n\r\n// Create the object to be bound\r\nButton b = new Button(\"Push me\");\r\n\r\n// Perform the bind\r\nctx.bind(\"cn=Button\", b);\r\n\r\nYou can then read the object back using \r\nContext.lookup, as follows.\r\n\r\n// Check that it is bound\r\nButton b2 = (Button)ctx.lookup(\"cn=Button\");\r\nSystem.out.println(b2);\r\n\r\nRunning \r\nthis example produces the following output.\r\n\r\n# java SerObj\r\njava.awt.Button[button0,0,0,0x0,invalid,label=Push me]\r\n\r\n\r\nSpecifying a Codebase\r\n\r\nNote: The procedures described here are for binding a serializable object in a directory service that follows the schema defined in \r\nRFC 2713. These procedures might not be generally applicable to other naming and directory services that support binding a serializable object with a specified codebase.\r\n\r\nWhen a serialized object is bound in the directory as shown in the previous example, applications that read the serialized object from the directory must have access to the class definitions necessary to deserialize the object.\r\nAlternatively, you can record a codebase with the serialized object in the directory, either when you bind the object or subsequently by adding an attribute by using \r\nDirContext.modifyAttributes. You can use any attribute to record this codebase and have your application read that attribute from the directory and use it appropriately. Or you can use the \"javaCodebase\" attribute specified in . In the latter case, Oracle's LDAP service provider will automatically use the attribute to load the class definitions as needed. \"javaCodebase\" should contain the URL of a codebase directory or a JAR file. If the codebase contains more than one URL, then each URL must be separated by a space character.\r\nThe following example resembles the one for binding a java.awt.Button. It differs in that it uses a user-defined Serializable class, \r\nFlower, and supplies a \"javaCodebase\" attribute that contains the location of Flower's class definition. Here's the code that does the binding.\r\n\r\nString codebase = ...;\r\n\r\n// Create the object to be bound\r\nFlower f = new Flower(\"rose\", \"pink\");\r\n\r\n// Perform the bind and specify the codebase\r\nctx.bind(\"cn=Flower\", f, new BasicAttributes(\"javaCodebase\", codebase));\r\n\r\nWhen you run \r\nthis example, you must supply the URL of the location at which the class file Flower.class was installed. For example, if Flower.class was installed at the Web server web1, in the directory example/classes, then you would run this example as follows.\r\n\r\n# java SerObjWithCodebase http://web1/example/classes/\r\npink rose\r\n\r\nAfterward, you may remove Flower.class from your classpath and run any program that looks up or lists this object without directly referencing the Flower class. If your program references Flower directly, then you must make its class file available for compilation and execution.\r\n",
        "title": "Oracle_Serializable Objects.txt",
        "type": "Oracle_"
    }, {
        "rank": 5,
        "text": " public class ComClient\r\n {\r\n  private Socket         comSocket;\r\n  private ObjectOutputStream oOut;\r\n  private ObjectInputStream  oIn;\r\n  private boolean         IsItOpen = false;       \r\n    /**\r\n     * --- Open Socket ---\r\n     */\r\n    public void openCom( String sServerName,\r\n                         int    iPortNumber ) throws UnknownHostException,\r\n                                                              IOException  \r\n    {\r\n       try {\r\n          // --- Open Socket for communication ---\r\n          comSocket = new Socket( sServerName, iPortNumber );     \r\n          // --- Get Stream to write request to the Server ---\r\n          oOut = new ObjectOutputStream( comSocket.getOutputStream() );     \r\n          // --- Get Stream// to read from the Server\r\n          oIn = new ObjectInputStream( comSocket.getInputStream());\r\n          // --- Set internal Member variable that the Communication opened ---\r\n          IsItOpen = true;\r\n       } catch ( java.net.UnknownHostException e ) {\r\n          System.err.println( \"(openCom:)Don't know about host: \"+sServerName );\r\n          IsItOpen = false;\r\n          throw( e );                                         \r\n       } catch ( java.io.IOException e ) {\r\n          System.err.println(\"(openCom:)Couldn't get I/O for the connection to: \"+ sServerName );\r\n          IsItOpen = false;\r\n          throw( e );         \r\n       }               \r\n    }\r\n    /**\r\n     * --- Check if Socket is open ---\r\n     */\r\n    public boolean isItOpen()\r\n    {\r\n      return IsItOpen;\r\n    }     \r\n    /**\r\n     * --- Get data string from the Server ---\r\n     */\r\n    public void getServerData( COM_DATA tServData ) throws IOException\r\n    {\r\n        // --- Initialize Variables ---\r\n        tServData.comData = \"\";\r\n        // --- Get the Response from the Server ---              \r\n        try {\r\n           tServData.copy( (COM_DATA) oIn.readObject() );\r\n        }   \r\n        catch ( ClassNotFoundException e ) {\r\n            System.out.println( \"Class Not Found\" );\r\n        } \r\n        System.out.println( \"Server: \" + tServData.comData );\r\n        if ( tServData.comData.equals(\"BYE.\") )\r\n        {\r\n            tServData.bExit = true;\r\n        }        \r\n     return;\r\n    }\r\n    /**\r\n     * --- Send data to the Server ---\r\n     */\r\n    public void sendDataToServer( COM_DATA tServData ) throws IOException\r\n    {\r\n        // --- Send the data string ---\r\n        System.out.println( \"Send: \" + tServData.comData );\r\n        oOut.writeObject( tServData );\r\n     return;\r\n    } \r\n    /**\r\n     * --- Close Socket --- \r\n     */\r\n    public void closeCom() throws IOException\r\n    {\r\n        oOut.close();\r\n        oIn.close();\r\n        comSocket.close();\r\n        IsItOpen = false;\r\n    }    \r\n }\r\n",
        "title": "Client Server_1.5 ComClient_code.txt",
        "type": "code"
    }, {
        "rank": 6,
        "text": "\r\nA bean has the property of persistence when its properties, fields, and state information are saved to and retrieved from storage. Component models provide a mechanism for persistence that enables the state of components to be stored in a non-volatile place for later retrieval.\r\nThe mechanism that makes persistence possible is called serialization. Object serialization means converting an object into a data stream and writing it to storage. Any applet, application, or tool that uses that bean can then \"reconstitute\" it by deserialization. The object is then restored to its original state.\r\nFor example, a Java application can serialize a Frame window on a Microsoft Windows machine, the serialized file can be sent with e-mail to a Solaris machine, and then a Java application can restore the Frame window to the exact state which existed on the Microsoft Windows machine.\r\nAny applet, application, or tool that uses that bean can then \"reconstitute\" it by deserialization.\r\nAll beans must persist. To persist, your beans must support serialization by implementing either the \r\njava.io.Serializable (in the API reference documentation) interface, or the \r\njava.io.Externalizable (in the API reference documentation) interface. These interfaces offer you the choices of automatic serialization and customized serialization. If any class in a class's inheritance hierarchy implements Serializable or Externalizable, then that class is serializable.\r\nClasses That Are Serializable\r\nAny class is serializable as long as that class or a parent class implements the java.io.Serializable interface. Examples of serializable classes include Component, String, Date, Vector, and Hashtable. Thus, any subclass of the Component class, including Applet, can be serialized. Notable classes not supporting serialization include Image, Thread, Socket, and InputStream. Attempting to serialize objects of these types will result in an NotSerializableException.\r\nThe Java Object Serialization API automatically serializes most fields of a Serializable object to the storage stream. This includes primitive types, arrays,and strings. The API does not serialize or deserialize fields that are marked transient or static.\r\nControlling Serialization\r\nYou can control the level of serialization that your beans undergo. Three ways to control serilization are:\r\n\r\nAutomatic serialization, implemented by the Serializable interface. The Java serialization software serializes the entire object, except transient and static fields.\r\nCustomized serialization. Selectively exclude fields you do not want serialized by marking with the transient (or static) modifier.\r\nCustomized file format, implemented by the Externalizable interface and its two methods. Beans are written in a specific file format.\r\n\r\nDefault Serialization: The Serializable Interface\r\nThe Serializable interface provides automatic serialization by using the Java Object Serialization tools. Serializable declares no methods; it acts as a marker, telling the Object Serialization tools that your bean class is serializable. Marking your class Serializable means you are telling the Java Virtual Machine (JVM) that you have made sure your class will work with default serialization. Here are some important points about working with the Serializable interface:\r\n\r\nClasses that implement Serializable must have an access to a no-argument constructor of supertype. This constructor will be called when an object is \"reconstituted\" from a .ser file.\r\nYou don't need to implement Serializable in your class if it is already implemented in a superclass.\r\nAll fields except static and transient fields are serialized. Use the transient modifier to specify fields you do not want serialized, and to specify classes that are not serializable.\r\n\r\nSelective Serialization Using the transient Keyword\r\nTo exclude fields from serialization in a Serializable object mark the fields with the transient modifier.\r\n\r\ntransient int status;\r\n\r\nDefault serialization will not serialize transient and static fields.\r\nSelective Serialization: writeObject and readObject\r\nIf your serializable class contains either of the following two methods (the signatures must be exact), then the default serialization will not take place.\r\n\r\nprivate void writeObject(java.io.ObjectOutputStream out)\r\n    throws IOException;\r\nprivate void readObject(java.io.ObjectInputStream in)\r\n    throws IOException, ClassNotFoundException;\r\n\r\nYou can control how more complex objects are serialized, by writing your own implementations of the writeObject and readObject methods. Implement writeObject when you need to exercise greater control over what gets serialized when you need to serialize objects that default serialization cannot handle, or when you need to add data to the serialization stream that is not an object data member. Implement readObject to reconstruct the data stream you wrote with writeObject.\r\nThe Externalizable Interface\r\nUse the Externalizable interface when you need complete control over your bean's serialization (for example, when writing and reading a specific file format). To use the Externalizable interface you need to implement two methods: readExternal and writeExternal. Classes that implement Externalizable must have a no-argument constructor.\r\n",
        "title": "Oracle_Bean Persistence.txt",
        "type": "Oracle_"
    }, {
        "rank": 7,
        "text": "\r\nThis lesson covers the Java platform classes used for basic I/O. It first focuses on I/O Streams, a powerful concept that greatly simplifies I/O operations. The lesson also looks at serialization, which lets a program write whole objects out to streams and read them back again. Then the lesson looks at file I/O and file system operations, including random access files.\r\nMost of the classes covered in the I/O Streams section are in the java.io package. Most of the classes covered in the File I/O section are in the java.nio.file package.\r\nI/O Streams\r\n\r\nByte Streams handle I/O of raw binary data.\r\nCharacter Streams handle I/O of character data, automatically handling translation to and from the local character set.\r\nBuffered Streams optimize input and output by reducing the number of calls to the native API.\r\nScanning and Formatting allows a program to read and write formatted text.\r\nI/O from the Command Line describes the Standard Streams and the Console object.\r\nData Streams handle binary I/O of primitive data type and String values.\r\nObject Streams handle binary I/O of objects.\r\n\r\nFile I/O (Featuring NIO.2)\r\n\r\nWhat is a Path? examines the concept of a path on a file system.\r\nThe Path Class introduces the cornerstone class of the java.nio.file package.\r\nPath Operations looks at methods in the Path class that deal with syntactic operations.\r\nFile Operations introduces concepts common to many of the file I/O methods.\r\nChecking a File or Directory shows how to check a file's existence and its level of accessibility.\r\nDeleting a File or Directory.\r\nCopying a File or Directory.\r\nMoving a File or Directory.\r\nManaging Metadata explains how to read and set file attributes.\r\nReading, Writing and Creating Files shows the stream and channel methods for reading and writing files.\r\nRandom Access Files shows how to read or write files in a non-sequentially manner.\r\nCreating and Reading Directories covers API specific to directories, such as how to list a directory's contents.\r\nLinks, Symbolic or Otherwise covers issues specific to symbolic and hard links.\r\nWalking the File Tree demonstrates how to recursively visit each file and directory in a file tree.\r\nFinding Files shows how to search for files using pattern matching.\r\nWatching a Directory for Changes shows how to use the watch service to detect files that are added, removed or updated in one or more directories.\r\nOther Useful Methods covers important API that didn't fit elsewhere in the lesson.\r\nLegacy File I/O Code shows how to leverage Path functionality if you have older code using the java.io.File class. A table mapping java.io.File API to java.nio.file API is provided.\r\n\r\nSummary\r\nA summary of the key points covered in this trail.\r\nQuestions and Exercises\r\nTest what you've learned in this trail by trying these questions and exercises.\r\nThe I/O Classes in Action\r\nMany of the examples in the next trail, \r\nCustom Networking use the I/O streams described in this lesson to read from and write to network connections.\r\nSecurity consideration:Â Some I/O operations are subject to approval by the current security manager. The example programs contained in these lessons are standalone applications, which by default have no security manager. To work in an applet, most of these examples would have to be modified. See \r\nWhat Applets Can and Cannot Do for information about the security restrictions placed on applets.\r\n\r\n",
        "title": "Oracle_Basic I-O.txt",
        "type": "Oracle_"
    }, {
        "rank": 8,
        "text": "\r\nThis section discusses the task of implementing a class for the compute engine. In general, a class that implements a remote interface should at least do the following:\r\n\r\nDeclare the remote interfaces being implemented\r\nDefine the constructor for each remote object\r\nProvide an implementation for each remote method in the remote interfaces\r\n\r\nAn RMI server program needs to create the initial remote objects and export them to the RMI runtime, which makes them available to receive incoming remote invocations. This setup procedure can be either encapsulated in a method of the remote object implementation class itself or included in another class entirely. The setup procedure should do the following:\r\n\r\nCreate and install a security manager\r\nCreate and export one or more remote objects\r\nRegister at least one remote object with the RMI registry (or with another naming service, such as a service accessible through the Java Naming and Directory Interface) for bootstrapping purposes\r\n\r\nThe complete implementation of the compute engine follows. The \r\nengine.ComputeEngine class implements the remote interface Compute and also includes the main method for setting up the compute engine. Here is the source code for the ComputeEngine class:\r\n\r\npackage engine;\r\n\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport compute.Compute;\r\nimport compute.Task;\r\n\r\npublic class ComputeEngine implements Compute {\r\n\r\n    public ComputeEngine() {\r\n        super();\r\n    }\r\n\r\n    public <T> T executeTask(Task<T> t) {\r\n        return t.execute();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        if (System.getSecurityManager() == null) {\r\n            System.setSecurityManager(new SecurityManager());\r\n        }\r\n        try {\r\n            String name = \"Compute\";\r\n            Compute engine = new ComputeEngine();\r\n            Compute stub =\r\n                (Compute) UnicastRemoteObject.exportObject(engine, 0);\r\n            Registry registry = LocateRegistry.getRegistry();\r\n            registry.rebind(name, stub);\r\n            System.out.println(\"ComputeEngine bound\");\r\n        } catch (Exception e) {\r\n            System.err.println(\"ComputeEngine exception:\");\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n\r\nThe following sections discuss each component of the compute engine implementation.\r\nDeclaring the Remote Interfaces Being Implemented\r\nThe implementation class for the compute engine is declared as follows:\r\n\r\npublic class ComputeEngine implements Compute\r\n\r\nThis declaration states that the class implements the Compute remote interface and therefore can be used for a remote object.\r\nThe ComputeEngine class defines a remote object implementation class that implements a single remote interface and no other interfaces. The ComputeEngine class also contains two executable program elements that can only be invoked locally. The first of these elements is a constructor for ComputeEngine instances. The second of these elements is a main method that is used to create a ComputeEngine instance and make it available to clients.\r\nDefining the Constructor for the Remote Object\r\nThe ComputeEngine class has a single constructor that takes no arguments. The code for the constructor is as follows:\r\n\r\npublic ComputeEngine() {\r\n    super();\r\n}\r\n\r\nThis constructor just invokes the superclass constructor, which is the no-argument constructor of the Object class. Although the superclass constructor gets invoked even if omitted from the ComputeEngine constructor, it is included for clarity.\r\nProviding Implementations for Each Remote Method\r\nThe class for a remote object provides implementations for each remote method specified in the remote interfaces. The Compute interface contains a single remote method, executeTask, which is implemented as follows:\r\n\r\npublic <T> T executeTask(Task<T> t) {\r\n    return t.execute();\r\n}\r\n\r\nThis method implements the protocol between the ComputeEngine remote object and its clients. Each client provides the ComputeEngine with a Task object that has a particular implementation of the Task interface's execute method. The ComputeEngine executes each client's task and returns the result of the task's execute method directly to the client.\r\nPassing Objects in RMI\r\nArguments to or return values from remote methods can be of almost any type, including local objects, remote objects, and primitive data types. More precisely, any entity of any type can be passed to or from a remote method as long as the entity is an instance of a type that is a primitive data type, a remote object, or a serializable object, which means that it implements the interface java.io.Serializable.\r\nSome object types do not meet any of these criteria and thus cannot be passed to or returned from a remote method. Most of these objects, such as threads or file descriptors, encapsulate information that makes sense only within a single address space. Many of the core classes, including the classes in the packages java.lang and java.util, implement the Serializable interface.\r\nThe rules governing how arguments and return values are passed are as follows:\r\n\r\nRemote objects are essentially passed by reference. A remote object reference is a stub, which is a client-side proxy that implements the complete set of remote interfaces that the remote object implements.\r\nLocal objects are passed by copy, using object serialization. By default, all fields are copied except fields that are marked static or transient. Default serialization behavior can be overridden on a class-by-class basis.\r\n\r\nPassing a remote object by reference means that any changes made to the state of the object by remote method invocations are reflected in the original remote object. When a remote object is passed, only those interfaces that are remote interfaces are available to the receiver. Any methods defined in the implementation class or defined in non-remote interfaces implemented by the class are not available to that receiver.\r\nFor example, if you were to pass a reference to an instance of the ComputeEngine class, the receiver would have access only to the compute engine's executeTask method. That receiver would not see the ComputeEngine constructor, its main method, or its implementation of any methods of java.lang.Object.\r\nIn the parameters and return values of remote method invocations, objects that are not remote objects are passed by value. Thus, a copy of the object is created in the receiving Java virtual machine. Any changes to the object's state by the receiver are reflected only in the receiver's copy, not in the sender's original instance. Any changes to the object's state by the sender are reflected only in the sender's original instance, not in the receiver's copy.\r\nImplementing the Server's main Method\r\nThe most complex method of the ComputeEngine implementation is the main method. The main method is used to start the ComputeEngine and therefore needs to do the necessary initialization and housekeeping to prepare the server to accept calls from clients. This method is not a remote method, which means that it cannot be invoked from a different Java virtual machine. Because the main method is declared static, the method is not associated with an object at all but rather with the class ComputeEngine.\r\nCreating and Installing a Security Manager\r\nThe main method's first task is to create and install a security manager, which protects access to system resources from untrusted downloaded code running within the Java virtual machine. A security manager determines whether downloaded code has access to the local file system or can perform any other privileged operations.\r\nIf an RMI program does not install a security manager, RMI will not download classes (other than from the local class path) for objects received as arguments or return values of remote method invocations. This restriction ensures that the operations performed by downloaded code are subject to a security policy.\r\nHere's the code that creates and installs a security manager:\r\n\r\nif (System.getSecurityManager() == null) {\r\n    System.setSecurityManager(new SecurityManager());\r\n}\r\n\r\nMaking the Remote Object Available to Clients\r\nNext, the main method creates an instance of ComputeEngine and exports it to the RMI runtime with the following statements:\r\n\r\nCompute engine = new ComputeEngine();\r\nCompute stub =\r\n    (Compute) UnicastRemoteObject.exportObject(engine, 0);\r\n\r\nThe static UnicastRemoteObject.exportObject method exports the supplied remote object so that it can receive invocations of its remote methods from remote clients. The second argument, an int, specifies which TCP port to use to listen for incoming remote invocation requests for the object. It is common to use the value zero, which specifies the use of an anonymous port. The actual port will then be chosen at runtime by RMI or the underlying operating system. However, a non-zero value can also be used to specify a specific port to use for listening. Once the exportObject invocation has returned successfully, the ComputeEngine remote object is ready to process incoming remote invocations.\r\nThe exportObject method returns a stub for the exported remote object. Note that the type of the variable stub must be Compute, not ComputeEngine, because the stub for a remote object only implements the remote interfaces that the exported remote object implements.\r\nThe exportObject method declares that it can throw a RemoteException, which is a checked exception type. The main method handles this exception with its try/catch block. If the exception were not handled in this way, RemoteException would have to be declared in the throws clause of the main method. An attempt to export a remote object can throw a RemoteException if the necessary communication resources are not available, such as if the requested port is bound for some other purpose.\r\nBefore a client can invoke a method on a remote object, it must first obtain a reference to the remote object. Obtaining a reference can be done in the same way that any other object reference is obtained in a program, such as by getting the reference as part of the return value of a method or as part of a data structure that contains such a reference.\r\nThe system provides a particular type of remote object, the RMI registry, for finding references to other remote objects. The RMI registry is a simple remote object naming service that enables clients to obtain a reference to a remote object by name. The registry is typically only used to locate the first remote object that an RMI client needs to use. That first remote object might then provide support for finding other objects.\r\nThe java.rmi.registry.Registry remote interface is the API for binding (or registering) and looking up remote objects in the registry. The java.rmi.registry.LocateRegistry class provides static methods for synthesizing a remote reference to a registry at a particular network address (host and port). These methods create the remote reference object containing the specified network address without performing any remote communication. LocateRegistry also provides static methods for creating a new registry in the current Java virtual machine, although this example does not use those methods. Once a remote object is registered with an RMI registry on the local host, clients on any host can look up the remote object by name, obtain its reference, and then invoke remote methods on the object. The registry can be shared by all servers running on a host, or an individual server process can create and use its own registry.\r\nThe ComputeEngine class creates a name for the object with the following statement:\r\n\r\nString name = \"Compute\";\r\n\r\nThe code then adds the name to the RMI registry running on the server. This step is done later with the following statements:\r\n\r\nRegistry registry = LocateRegistry.getRegistry();\r\nregistry.rebind(name, stub);\r\n\r\nThis rebind invocation makes a remote call to the RMI registry on the local host. Like any remote call, this call can result in a RemoteException being thrown, which is handled by the catch block at the end of the main method.\r\nNote the following about the Registry.rebind invocation:\r\n\r\nThe no-argument overload of LocateRegistry.getRegistry synthesizes a reference to a registry on the local host and on the default registry port, 1099. You must use an overload that has an int parameter if the registry is created on a port other than 1099.\r\nWhen a remote invocation on the registry is made, a stub for the remote object is passed instead of a copy of the remote object itself. Remote implementation objects, such as instances of ComputeEngine, never leave the Java virtual machine in which they were created. Thus, when a client performs a lookup in a server's remote object registry, a copy of the stub is returned. Remote objects in such cases are thus effectively passed by (remote) reference rather than by value.\r\nFor security reasons, an application can only bind, unbind, or rebind remote object references with a registry running on the same host. This restriction prevents a remote client from removing or overwriting any of the entries in a server's registry. A lookup, however, can be requested from any host, local or remote.\r\n\r\nOnce the server has registered with the local RMI registry, it prints a message indicating that it is ready to start handling calls. Then, the main method completes. It is not necessary to have a thread wait to keep the server alive. As long as there is a reference to the ComputeEngine object in another Java virtual machine, local or remote, the ComputeEngine object will not be shut down or garbage collected. Because the program binds a reference to the ComputeEngine in the registry, it is reachable from a remote client, the registry itself. The RMI system keeps the ComputeEngine's process running. The ComputeEngine is available to accept calls and won't be reclaimed until its binding is removed from the registry and no remote clients hold a remote reference to the ComputeEngine object.\r\nThe final piece of code in the ComputeEngine.main method handles any exception that might arise. The only checked exception type that could be thrown in the code is RemoteException, either by the UnicastRemoteObject.exportObject invocation or by the registry rebind invocation. In either case, the program cannot do much more than exit after printing an error message. In some distributed applications, recovering from the failure to make a remote invocation is possible. For example, the application could attempt to retry the operation or choose another server to continue the operation.\r\n",
        "title": "Oracle_Implementing a Remote Interface.txt",
        "type": "Oracle_"
    }, {
        "rank": 9,
        "text": "\r\n\r\nThe \r\nDataFlavor class allows you to specify the content type of your data. You need to specify a DataFlavor when fetching the data from the importData method. Several flavor types are predefined for you:\r\n\r\n\r\nimageFlavor represents data in the java.awt.Image format. This is used when dragging image data.\r\n\r\nstringFlavor represents data in the most basic form of text â\u20ac\u201d java.lang.String. This is the most commonly used data flavor for most applications.\r\n\r\njavaFileListFlavor represents java.io.File objects in a java.util.List format. This is useful for applications that drag files, such as the TopLevelTransferHandler example, discussed in the \r\nTop-Level Drop lesson.\r\n\r\nFor most applications, this is all you need to know about data flavors. However, if you require a flavor other than these predefined types, you can create your own. If you create a custom component and want it to participate in data transfer, you will need to create a custom data flavor. The constructor for specifying a data flavor is \r\nDataFlavor(Class, String). For example, to create a data flavor for the java.util.ArrayList class:\r\n\r\nnew DataFlavor(ArrayList.class, \"ArrayList\");\r\n\r\nTo create a data flavor for an integer array:\r\n\r\nnew DataFlavor(int[].class, \"Integer Array\");\r\n\r\nTransferring the data using this mechanism uses Object serialization, so the class you use to transfer the data must implement the Serializable interface, as must anything that is serialized with it. If everything is not serializable, you will see a NotSerializableException during drop or copy to the clipboard.\r\nCreating a data flavor using the DataFlavor(Class, String) constructor allows you to transfer data between applications, including native applications. If you want to create a data flavor that transfers data only within an application, use \r\njavaJVMLocalObjectMimeType and the \r\nDataFlavor(String) constructor. For example, to specify a data flavor that transfers color from a JColorChooser only within your application, you could use this code:\r\n\r\nString colorType = DataFlavor.javaJVMLocalObjectMimeType +\r\n                   \";class=java.awt.Color\";\r\nDataFlavor colorFlavor = new DataFlavor(colorType);\r\n\r\nTo create a data flavor for an ArrayList that would work only within your application:\r\n\r\nnew DataFlavor(DataFlavor.javaJVMLocalObjectMimeType +\r\n               \";class=java.util.ArrayList\");\r\n\r\nTo create a data flavor for an integer array:\r\n\r\nnew DataFlavor(DataFlavor.javaJVMLocalObjectMimeType +\r\n               \";class=\\\"\" + int[].class.getName() + \"\\\"\");\r\n\r\nA MIME type containing special characters, such as [ or ;, must have those characters enclosed in quotes.\r\nA Transferable can be implemented to support multiple flavors. For example, you can use both local and serialization flavors together, or you can use two forms of the same data, such as the ArrayList and integer array flavors, together, or you can create a TransferHandler that accepts different types of data, such as color and text.\r\nWhen you create an array of DataFlavors to be returned from the Transferable's \r\ngetTransferDataFlavors method, the flavors should be inserted in preferred order, with the most preferred appearing at element 0 of the array. Genereally the preferred order is from the richest, or most complex, form of the data down to the simpleset â\u20ac\u201d the form most likely to be understood by other objects.\r\n",
        "title": "Oracle_Using and Creating a DataFlavor.txt",
        "type": "Oracle_"
    }, {
        "rank": 10,
        "text": "\r\nCloning is not automatically available to classes. There is some help though, as all Java objects inherit theprotected Object clone()method. This base method would allocate the memory and do the bit by bit copying of the object's states.\r\nYou may ask why we need this clone method. Can't we create a constructor, pass in the same object and do the copying variable by variable? An example would be (note that accessing the privatememberVarvariable ofobjis legal as this is in the same class):\r\n\r\n\r\nThis method works but object creation with thenewkeyword is time-consuming. Theclone()method copies the whole object's memory in one operation and this is much faster than using the new keyword and copying each variable so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.\r\n\r\n\r\nNow, let's see how to make the Customer object cloneable.\r\n\r\nFirst theCustomerclass needs to implement theCloneableInterface.Override and make theclone()methodpublic, as that isprotectedin the Object class.Call thesuper.clone()method at the beginning of yourclonemethod.Override theclone()method in all the subclasses ofCustomer.\r\n\r\n\r\nIn thecode listing 4.15we used cloning for speed up object creation. Another use of cloning could be to take a snapshot of an object that can change in time. Let's say we want to store Customer objects in a collection, but we want to disassociate them from the 'live' objects.  So before adding the object, we clone them, so if the original object changes from that point forward, the added object won't.  Also let's say that the Customer object has a reference to an Activity object that contains the customer activities.  Now we are facing a problem, it is not enough to clone the Customer object, we also need to clone the referenced objects.  The solution:\r\n\r\nMake the Activity class also cloneableMake sure that if the Activity class has other 'changeable' object references, those have to be cloned as well, as seen belowChange the Customer classclone()method as follows:\r\n\r\n\r\nNote that only mutable objects need to be cloned. References to unchangeable objects such as a String can be used in the cloned object without worry.\r\n\r\n",
        "title": "Object Lifecycle_Creating object by cloning an object_text.txt",
        "type": "text"
    }]
}

post8_rec = {
    "response": [{
        "rank": 1,
        "text": "\r\nThe Java programming language allows you to define a class within another class. Such a class is called a nested class and is illustrated here:\r\n\r\nclass OuterClass {\r\n    ...\r\n    class NestedClass {\r\n        ...\r\n    }\r\n}\r\n\r\nTerminology:Â Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are called static nested classes. Non-static nested classes are called inner classes.\r\n\r\n\r\nclass OuterClass {\r\n    ...\r\n    static class StaticNestedClass {\r\n        ...\r\n    }\r\n    class InnerClass {\r\n        ...\r\n    }\r\n}\r\n\r\nA nested class is a member of its enclosing class. Non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private. Static nested classes do not have access to other members of the enclosing class. As a member of the OuterClass, a nested class can be declared private, public, protected, or package private. (Recall that outer classes can only be declared public or package private.)\r\nWhy Use Nested Classes?\r\nCompelling reasons for using nested classes include the following:\r\n\r\nIt is a way of logically grouping classes that are only used in one place: If a class is useful to only one other class, then it is logical to embed it in that class and keep the two together. Nesting such \"helper classes\" makes their package more streamlined.\r\nIt increases encapsulation: Consider two top-level classes, A and B, where B needs access to members of A that would otherwise be declared private. By hiding class B within class A, A's members can be declared private and B can access them. In addition, B itself can be hidden from the outside world.\r\nIt can lead to more readable and maintainable code: Nesting small classes within top-level classes places the code closer to where it is used.\r\n\r\nStatic Nested Classes\r\nAs with class methods and variables, a static nested class is associated with its outer class. And like static class methods, a static nested class cannot refer directly to instance variables or methods defined in its enclosing class: it can use them only through an object reference.\r\nNote:Â A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience.\r\n\r\nStatic nested classes are accessed using the enclosing class name:\r\n\r\nOuterClass.StaticNestedClass\r\n\r\nFor example, to create an object for the static nested class, use this syntax:\r\n\r\nOuterClass.StaticNestedClass nestedObject =\r\n     new OuterClass.StaticNestedClass();\r\n\r\nInner Classes\r\nAs with instance methods and variables, an inner class is associated with an instance of its enclosing class and has direct access to that object's methods and fields. Also, because an inner class is associated with an instance, it cannot define any static members itself.\r\nObjects that are instances of an inner class exist within an instance of the outer class. Consider the following classes:\r\n\r\nclass OuterClass {\r\n    ...\r\n    class InnerClass {\r\n        ...\r\n    }\r\n}\r\n\r\n\r\nAn instance of InnerClass can exist only within an instance of OuterClass and has direct access to the methods and fields of its enclosing instance.\r\nTo instantiate an inner class, you must first instantiate the outer class. Then, create the inner object within the outer object with this syntax:\r\n\r\nOuterClass.InnerClass innerObject = outerObject.new InnerClass();\r\n\r\nThere are two special kinds of inner classes:\r\nlocal classes and\r\nanonymous classes.\r\n\r\nShadowing\r\nIf a declaration of a type (such as a member variable or a parameter name) in a particular scope (such as an inner class or a method definition) has the same name as another declaration in the enclosing scope, then the declaration shadows the declaration of the enclosing scope. You cannot refer to a shadowed declaration by its name alone. The following example,\r\nShadowTest, demonstrates this:\r\n\r\n \r\npublic class ShadowTest {\r\n\r\n    public int x = 0;\r\n\r\n    class FirstLevel {\r\n\r\n        public int x = 1;\r\n\r\n        void methodInFirstLevel(int x) {\r\n            System.out.println(\"x = \" + x);\r\n            System.out.println(\"this.x = \" + this.x);\r\n            System.out.println(\"ShadowTest.this.x = \" + ShadowTest.this.x);\r\n        }\r\n    }\r\n\r\n    public static void main(String... args) {\r\n        ShadowTest st = new ShadowTest();\r\n        ShadowTest.FirstLevel fl = st.new FirstLevel();\r\n        fl.methodInFirstLevel(23);\r\n    }\r\n}\r\n\r\nThe following is the output of this example:\r\nx = 23\r\nthis.x = 1\r\nShadowTest.this.x = 0\r\nThis example defines three variables named x: the member variable of the class ShadowTest, the member variable of the inner class FirstLevel, and the parameter in the method methodInFirstLevel. The variable x defined as a parameter of the method methodInFirstLevel shadows the variable of the inner class FirstLevel. Consequently, when you use the variable x in the method methodInFirstLevel, it refers to the method parameter. To refer to the member variable of the inner class FirstLevel, use the keyword this to represent the enclosing scope:\r\nSystem.out.println(\"this.x = \" + this.x);\r\nRefer to member variables that enclose larger scopes by the class name to which they belong. For example, the following statement accesses the member variable of the class ShadowTest from the method methodInFirstLevel:\r\nSystem.out.println(\"ShadowTest.this.x = \" + ShadowTest.this.x);\r\nSerialization\r\n\r\nSerialization of inner classes, including\r\nlocal and\r\nanonymous classes, is strongly discouraged. When the Java compiler compiles certain constructs, such as inner classes, it creates synthetic constructs; these are classes, methods, fields, and other constructs that do not have a corresponding construct in the source code. Synthetic constructs enable Java compilers to implement new Java language features without changes to the JVM. However, synthetic constructs can vary among different Java compiler implementations, which means that .class files can vary among different implementations as well. Consequently, you may have compatibility issues if you serialize an inner class and then deserialize it with a different JRE implementation. See the section\r\nImplicit and Synthetic Parameters in the section\r\nObtaining Names of Method Parameters for more information about the synthetic constructs generated when an inner class is compiled.\r\n",
        "title": "Oracle_Nested Classes.txt",
        "type": "Oracle_"
    }, {
        "rank": 2,
        "text": "\r\n\r\nWith the knowledge you now have of the basics of the Java programming language, you can learn to write your own classes. In this \r\nlesson, \r\nyou will find information about defining your own classes, including declaring member variables, methods, and constructors.\r\nYou will learn to use your classes to create objects, and how to use the objects you create.\r\nThis \r\nlesson \r\n also covers nesting classes within other classes, and enumerations \r\n\r\nClasses\r\n\r\nThis section shows you the anatomy of a class, and how\r\nto declare fields, methods, and constructors.\r\n\r\n\r\n\r\n\r\n\r\nObjects\r\n\r\nThis section covers creating and using objects. You will learn how to instantiate an object, and, \r\nonce instantiated, how to use the dot operator to access the object's instance variables and methods.\r\n\r\nMore on Classes\r\n\r\nThis section covers more aspects of classes that depend on using object references and the dot operator \r\nthat you learned about in the preceding section: \r\nreturning values from methods, the this keyword, class vs. instance members, and access control.\r\n\r\nNested Classes\r\n\r\nStatic nested classes, inner classes, anonymous inner\r\nclasses, local classes, and lambda expressions are covered.\r\nThere is also a discussion on when to use which approach.\r\n\r\n\r\n\r\n\r\nEnum Types\r\n\r\nThis section covers enumerations, specialized classes that allow you to define and use sets of constants.\r\n\r\n\r\n",
        "title": "Oracle_Classes and Objects.txt",
        "type": "Oracle_"
    }, {
        "rank": 3,
        "text": "\r\nThe success of the Java platform and the concepts of the write once, run anywhere principle has led to the development of similar frameworks and platforms. Most notable of these is the Microsoft's.NET frameworkand its open-source equivalentMono.\r\n\r\nThe .NET framework[edit]\r\n\r\nThe .NET framework borrows many of the concepts and innovations of Java â\u20ac\u201d their alternative for the JVM is called theCommon Language Runtime (CLR), while their alternative for the byte-code is theCommon Intermediate Language (CIL). In fact, the .NET platform had an implementation of a Java-like language calledVisual J#(formerly known asJ++).\r\nJ# is normally not supported with the JVM because instead of compiling it in Java byte-code, the .NET platform compiles the code into CIL, thus making J# different from the Java programming language. Furthermore, because J# implements the .NET Base Class Libraries (BCL) instead of the Java Class Libraries, J# is nothing more than a non-standard extension of the Java programming language. Due to the lack of interest from developers, Microsoft had to withdraw their support for J#, and focused on a similar programming language: C#.\r\n\r\nThird-party compilers targeting the JVM[edit]\r\n\r\nThe word Java, by itself, usually refers to the Java programming language which was designed for use with the Java platform. Programming languages are typically outside of the scope of the phrase \"platform\".  However, Oracle does not encourage the use of any other languages with the platform, and lists the Java programming language as a core part of the Java 2 platform. The language and runtime are therefore commonly considered a single unit.\r\nThere are cases where you might want to program using a different language (say,Python) and yet be able to generate Java byte-code (instead of the Python compiled code) to be run with the JVM. Many third-party programming language vendors provide compilers that can compile code written in their language to Java byte-code. For instance, Python developers can useJythoncompilers to compile Python code to the Java byte-code format (as illustrated below).\r\n\r\n\r\nFigure 5:Third-party JVM-targeted compilation for non-Java source compilation to Java byte-code. Illustrated exampleshows Python source being compiled to both Python compiled code and Java byte-code.\r\n\r\nOf late, JVM-targeted third-party programming and scripting languages have seen tremendous growth. Some of these languages are also used to extend the functionalities of the Java language itself. A few examples include the following:\r\n\r\nGroovyPizzaGJ(Generic Java) â\u20ac\u201c later officially incorporated into Java SE 5.NetREXX\r\n\r\n\r\n\r\nJava OverviewJava ProgrammingThe Java PlatformGetting started\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "title": "The Java Platform_Similar concepts_text.txt",
        "type": "text"
    }, {
        "rank": 4,
        "text": "\r\nThe JRE takes care of running the Java code on multiple platforms, however as developers, we are interested in writing pure code in Java which can then be converted into Java byte-code for mass deployment. As developers, we donotneed to write Java byte-code; rather we write the code in the Java programming language (which is quite similar to writing C or C++ code).\r\nUpon downloading the JDK, a developer ensures that their system has the appropriate JRE and additional tools to help with the development of applications in the Java programming language. Java code can be found in files with the extension.java. These files are calledJava source files. In order to convert the Java code in these source files to Java byte-code, you need to use theJava compilertool installed with your JDK.\r\n\r\nThe Java compiler[edit]\r\n\r\nTheJava compilertool (namedjavacin the JDK) is the most important utility found with the JDK.  In order to compile a Java source file (say,SomeApplication.java) to its respective Java byte-code, you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):\r\n\r\nCompilationjavac SomeApplication.java\r\n\r\nThis command would convert theSomeApplication.javasource file into its equivalent Java byte-code. The resultant byte-code would exist in a newly created file namedSomeApplication.class. This process of converting Java source files into their equivalent byte-codes is known ascompilation.\r\n\r\n\r\nFigure 4:The basic Java compilation process\r\n\r\n\r\n\r\nA list of other JDK toolsThere are a huge array of tools available with the JDK that will all be explained in due time as you progress with the book. These tools are briefly listed below in order of their usage:Applet development[edit]appletviewerâ\u20ac\u201d Java applets require a particular environment to execute. Typically, this environment is provided by a browser with a Java plug-in, and a web server serving the applet. However, during development and testing of an applet it might be more convenient to start an applet without the need to fiddle with a browser and a web server. In such a case, Oracle's appletviewer from the JDK can be used to run an applet.Annotation processing[edit]For more about annotation processing,read thisIn Java 1.5 (alias Java 5.0) Oracle added a mechanism calledannotations. Annotations allow the addition of meta-data to Java source code, and even provide mechanisms to carry that meta-data into compiled.classfiles.aptâ\u20ac\u201d An annotation processing tool which digs through source code, finds annotation statements in the source code and executes actions if it finds known annotations. The most common task is to generate some particular source code. The actions apt performs when finding annotations in the source code are not hard-coded into apt. Instead, one has to code particular annotation handlers (in Java). These handlers are called annotation processors. It can also be described in a simple way without the Oracle terminology: apt can be seen as a source code preprocessor framework, and annotation processors are typically code generators.Integration of non-Java and Java code[edit]javahâ\u20ac\u201d A Java class can call native, or non-Java, code that has been prepared to be called from Java. The details and procedures are specified in the JNI (Java Native Interface). Commonly, native code is written in C (or C++). The JDK tool javah helps to write the necessary C code, by generating C header files and C stub code.Class library conflicts[edit]extcheckâ\u20ac\u201d It can be used prior to the installation of a Java extension into the JDK or JRE environment. It checks if a particular Jar file conflicts with an already installed extension. This tool appeared first with Java 1.5.Software security and cryptography tools[edit]The JDK comes with a large number of tools related to the security features of Java. Usage of these tools first requires study of the particular security mechanisms. The tools are:keytoolâ\u20ac\u201d To manage keys and certificatesjarsignerâ\u20ac\u201d To generate and verify digital signatures of JARs (Java ARchives)policytoolâ\u20ac\u201d To edit policy fileskinitâ\u20ac\u201d To obtain Kerberos v5 ticketsklistâ\u20ac\u201d To manage Kerberos credential cache and key tablektabâ\u20ac\u201d To manage entries in a key tableThe Java archiver[edit]jarâ\u20ac\u201d (short for Java archiver) is a tool for creating Java archives or jar files â\u20ac\u201d a file with.jaras the extension. A Java archive is a collection of compiled Java classes and other resources which those classes may require (such as text files, configuration files, images) at runtime. Internally, a jar file is really a.zip file.The Java debugger[edit]jdbâ\u20ac\u201d (short for Java debugger) is a command-line console that provides adebuggingenvironment for Java programs. Although you can use this command line console, IDE's normally provide easier to use debugging environments.Documenting code with Java[edit]As programs grow large and complex, programmers need ways to track changes and to understand the code better at each step of its evolution. For decades, programmers have been employing the use of special programming constructs called comments â\u20ac\u201d regions that help declare user definitions for a code snippet within the source code. But comments are prone to be verbose and incomprehensible, let alone be difficult to read in applications having hundreds of lines of code.javadocâ\u20ac\u201d Java provides the user with a way to easily publish documentation about the code using a special commenting system and the javadoc tool. The javadoc tool generates documentation about the Application Programming Interface (API) of a set of user-created Java classes. javadoc reads source file comments from the.javasource files and generates HTML documents that are easier to read and understand without looking at the code itself.javapâ\u20ac\u201d Where Javadoc provide a detailed view into the API and documentation of a Java class, the javap tool prints information regarding members (constructors, methods and variables) in a class. In other words, it lists the class' API and/or the compiled instructions of the class. javap is a formatting disassembler for Java bytecode.The native2ascii tool[edit]native2asciiis an important, though underappreciated, tool for writing properties files â\u20ac\u201d files containing configuration data â\u20ac\u201d or resource bundles â\u20ac\u201d files containing language translations of text.Such files can contain only ASCII and Latin-1 characters, but international programmers need a full range of character sets. Text using these characters can appear in properties files and resource bundles only if the non-ASCII and non-Latin-^1 characters are converted intoUnicode escape sequences(\\uXXXX notation).The task of writing such escape sequences is handled bynative2ascii. You can write the international text in an editor using the appropriate character encoding, then usenative2asciito generate the necessary ASCII text with embedded Unicode escape sequences. Despite the name,native2asciican also convert from ASCII to native, so it is useful for converting an existing properties file or resource bundle back to some other encoding.native2asciimakes most sense when integrated into a build system to automate the conversion.Remote Method Invocation (RMI) tools[edit]To do:Add sectionJava IDL and RMI-IIOP Tools[edit]To do:Add sectionDeployment & Web Start Tools[edit]To do:Add sectionBrowser Plug-In Tools[edit]To do:Add sectionMonitoring and Management Tools / Troubleshooting Tools[edit]With Java 1.5 a set of monitoring and management tools have been added to the JDK, in addition to a set of troubleshooting tools.The monitoring and management tools are intended for monitoring and managing the virtual machine and the execution environment. They allow, for example, monitoring memory usage during the execution of a Java program.The troubleshooting tools provide rather esoteric insight into aspects of the virtual machine. (Interestingly, the Java debugger is not categorized as a troubleshooting tool.)All the monitoring and management and troubleshooting tools are currently marked as \"experimental\" (which does not affect jdb). So they might disappear in future JDKs.\r\n\r\nJava class libraries (JCL)[edit]\r\n\r\nIn most modern operating systems, a large body of reusable code is provided to simplify the programmer's job.  This code is typically provided as a set ofdynamically loadable librariesthat applications can call at runtime.  Because the Java platform is not dependent on any specific operating system, applications cannot rely on any of the existing libraries.  Instead, the Java platform provides a comprehensive set of standard class libraries, containing much of the same reusable functions commonly found in modern operating systems.\r\nThe Java class libraries serve three purposes within the Java platform.  Like other standard code libraries, they provide the programmer with a well-known set of functions to perform common tasks, such as maintaining lists of items or performing complex string parsing.  In addition, the class libraries provide an abstract interface to tasks that would normally depend heavily on the hardware and operating system.  Tasks such as network access and file access are often heavily dependent on the native capabilities of the platform.  The Java java.net and java.io libraries implement the required native code internally, then provide a standard interface for the Java applications to perform those tasks.  Finally, some underlying platforms may not support all of the features a Java application expects.  In these cases, the class libraries can either emulate those features using whatever is available, or provide a consistent way to check for the presence of a specific feature.\r\n\r\n",
        "title": "The Java Platform_Java Development Kit JDK_text.txt",
        "type": "text"
    }, {
        "rank": 5,
        "text": "\r\nIf you are importing library packages and classes that reside in a.jarfile, you must ensure that the file is in the current classpath (both at compile- and execution-time). Apart from this requirement, importing these packages and classes is the same as if they were in their full, expanded, directory structure.\r\n\r\nJavac[edit]\r\n\r\nFor example, to compile and run a class from a project's top directory (that contains the two directories/sourceand/libraries) you could use the following command:\r\n\r\nCompilation$ javac -classpath libraries/lib.jar source/MainClass.java\r\n\r\nAnd then to run it, similarly:\r\n\r\nExecution$ java -classpath libraries/lib.jar source/MainClass\r\n\r\nThe above is simplified, and demands thatMainClassbe in the default package, or a package calledsource, which isn't very desirable.\r\n\r\nBlueJ[edit]\r\n\r\nWith BlueJ just click onTools, Preferences, Libraries, and add the .jar one by one.\r\n\r\n",
        "title": "Packages_Importing packages from .jar files_text.txt",
        "type": "text"
    }, {
        "rank": 6,
        "text": "\r\nYou can obtain the names of the formal parameters of any method or constructor with the method\r\njava.lang.reflect.Executable.getParameters. (The classes\r\nMethod and \r\nConstructor extend the class \r\nExecutable and therefore inherit the method Executable.getParameters.) However, .class files do not store formal parameter names by default. This is because many tools that produce and consume class files may not expect the larger static and dynamic footprint of .class files that contain parameter names. In particular, these tools would have to handle larger .class files, and the Java Virtual Machine (JVM) would use more memory. In addition, some parameter names, such as secret or password, may expose information about security-sensitive methods.\r\nTo store formal parameter names in a particular .class file, and thus enable the Reflection API to retrieve formal parameter names, compile the source file with the -parameters option to the javac compiler.\r\nThe \r\nMethodParameterSpy example illustrates how to retrieve the names of the formal parameters of all constructors and methods of a given class. The example also prints other information about each parameter.\r\nThe following command prints the formal parameter names of the constructors and methods of the class\r\nExampleMethods. Note: Remember to compile the example ExampleMethods with the -parameters compiler option:\r\njava MethodParameterSpy ExampleMethods\r\nThis command prints the following:\r\nNumber of constructors: 1\r\n\r\nConstructor #1\r\npublic ExampleMethods()\r\n\r\nNumber of declared constructors: 1\r\n\r\nDeclared constructor #1\r\npublic ExampleMethods()\r\n\r\nNumber of methods: 4\r\n\r\nMethod #1\r\npublic boolean ExampleMethods.simpleMethod(java.lang.String,int)\r\n             Return type: boolean\r\n     Generic return type: boolean\r\n         Parameter class: class java.lang.String\r\n          Parameter name: stringParam\r\n               Modifiers: 0\r\n            Is implicit?: false\r\n        Is name present?: true\r\n           Is synthetic?: false\r\n         Parameter class: int\r\n          Parameter name: intParam\r\n               Modifiers: 0\r\n            Is implicit?: false\r\n        Is name present?: true\r\n           Is synthetic?: false\r\n\r\nMethod #2\r\npublic int ExampleMethods.varArgsMethod(java.lang.String...)\r\n             Return type: int\r\n     Generic return type: int\r\n         Parameter class: class [Ljava.lang.String;\r\n          Parameter name: manyStrings\r\n               Modifiers: 0\r\n            Is implicit?: false\r\n        Is name present?: true\r\n           Is synthetic?: false\r\n\r\nMethod #3\r\npublic boolean ExampleMethods.methodWithList(java.util.List<java.lang.String>)\r\n             Return type: boolean\r\n     Generic return type: boolean\r\n         Parameter class: interface java.util.List\r\n          Parameter name: listParam\r\n               Modifiers: 0\r\n            Is implicit?: false\r\n        Is name present?: true\r\n           Is synthetic?: false\r\n\r\nMethod #4\r\npublic <T> void ExampleMethods.genericMethod(T[],java.util.Collection<T>)\r\n             Return type: void\r\n     Generic return type: void\r\n         Parameter class: class [Ljava.lang.Object;\r\n          Parameter name: a\r\n               Modifiers: 0\r\n            Is implicit?: false\r\n        Is name present?: true\r\n           Is synthetic?: false\r\n         Parameter class: interface java.util.Collection\r\n          Parameter name: c\r\n               Modifiers: 0\r\n            Is implicit?: false\r\n        Is name present?: true\r\n           Is synthetic?: false\r\nThe MethodParameterSpy example uses the following methods from the\r\nParameter class:\r\n\r\n\r\ngetType: Returns a\r\nClass object that identifies the declared type for the parameter.\r\n\r\ngetName: Returns the name of the parameter. If the parameter's name is present, then this method returns the name provided by the .class file. Otherwise, this method synthesizes a name of the form argN, where N is the index of the parameter in the descriptor of the method that declares the parameter.\r\nFor example, suppose you compiled the class ExampleMethods without specifying the -parameters compiler option. The example MethodParameterSpy would print the following for the method ExampleMethods.simpleMethod:\r\npublic boolean ExampleMethods.simpleMethod(java.lang.String,int)\r\n             Return type: boolean\r\n     Generic return type: boolean\r\n         Parameter class: class java.lang.String\r\n          Parameter name: arg0\r\n               Modifiers: 0\r\n            Is implicit?: false\r\n        Is name present?: false\r\n           Is synthetic?: false\r\n         Parameter class: int\r\n          Parameter name: arg1\r\n               Modifiers: 0\r\n            Is implicit?: false\r\n        Is name present?: false\r\n           Is synthetic?: false\r\n\r\ngetModifiers  : Returns an integer that represents various characteristics that the formal parameter possesses. This value is the sum of the following values, if applicable to the formal parameter:\r\n\r\n\r\nValue (in decimal)\r\nValue (in hexadecimal\r\nDescription\r\n\r\n\r\n16\r\n0x0010\r\nThe formal parameter is declared final\r\n\r\n\r\n4096\r\n0x1000\r\nThe formal parameter is synthetic. Alternatively, you can invoke the method isSynthetic.\r\n\r\n\r\n32768\r\n0x8000\r\nThe parameter is implicitly declared in source code. Alternatively, you can invoke the method isImplicit\r\n\r\n\r\n\r\n\r\nisImplicit: Returns true if this parameter is implicitly declared in source code. See the section Implicit and Synthetic Parameters for more information.\r\n\r\nisNamePresent: Returns true if the parameter has a name according to the .class file.\r\n\r\nisSynthetic: Returns true if this parameter is neither implicitly nor explicitly declared in source code. See the section Implicit and Synthetic Parameters for more information.\r\n\r\nImplicit and Synthetic Parameters\r\nCertain constructs are implicitly declared in the source code if they have not been written explicitly. For example, the\r\nExampleMethods example does not contain a constructor. A default constructor is implicitly declared for it. The MethodParameterSpy example prints information about the implicitly declared constructor of ExampleMethods:\r\nNumber of declared constructors: 1\r\npublic ExampleMethods()\r\nConsider the following excerpt from\r\nMethodParameterExamples:\r\npublic class MethodParameterExamples {\r\n    public class InnerClass { }\r\n}\r\nThe class InnerClass is a non-static\r\nnested class or inner class. A constructor for inner classes is also implicitly declared. However, this constructor will contain a parameter. When the Java compiler compiles InnerClass, it creates a .class file that represents code similar to the following:\r\npublic class MethodParameterExamples {\r\n    public class InnerClass {\r\n        final MethodParameterExamples parent;\r\n        InnerClass(final MethodParameterExamples this$0) {\r\n            parent = this$0; \r\n        }\r\n    }\r\n}\r\nThe InnerClass constructor contains a parameter whose type is the class that encloses InnerClass, which is MethodParameterExamples. Consequently, the example MethodParameterExamples prints the following:\r\npublic MethodParameterExamples$InnerClass(MethodParameterExamples)\r\n         Parameter class: class MethodParameterExamples\r\n          Parameter name: this$0\r\n               Modifiers: 32784\r\n            Is implicit?: true\r\n        Is name present?: true\r\n           Is synthetic?: false\r\nBecause the constructor of the class InnerClass is implicitly declared, its parameter is implicit as well.\r\nNote:\r\n\r\nThe Java compiler creates a formal parameter for the constructor of an inner class to enable the compiler to pass a reference (representing the immediately enclosing instance) from the creation expression to the member class's constructor.\r\nThe value 32784 means that the parameter of the InnerClass constructor is both final (16) and implicit (32768).\r\nThe Java programming language allows variable names with dollar signs ($); however, by convention, dollar signs are not used in variable names.\r\n\r\nConstructs emitted by a Java compiler are marked as synthetic if they do not correspond to a construct declared explicitly or implicitly in source code, unless they are class initialization methods. Synthetic constructs are artifacts generated by compilers that vary among different implementations. Consider the following excerpt from\r\nMethodParameterExamples:\r\npublic class MethodParameterExamples {\r\n    enum Colors {\r\n        RED, WHITE;\r\n    }\r\n}\r\nWhen the Java compiler encounters an enum construct, it creates several methods that are compatible with the .class file structure and provide the expected functionality of the enum construct. For example, the Java compiler would create a .class file for the enum construct Colors that represents code similar to the following:\r\nfinal class Colors extends java.lang.Enum<Colors> {\r\n    public final static Colors RED = new Colors(\"RED\", 0);\r\n    public final static Colors BLUE = new Colors(\"WHITE\", 1);\r\n \r\n    private final static values = new Colors[]{ RED, BLUE };\r\n \r\n    private Colors(String name, int ordinal) {\r\n        super(name, ordinal);\r\n    }\r\n \r\n    public static Colors[] values(){\r\n        return values;\r\n    }\r\n \r\n    public static Colors valueOf(String name){\r\n        return (Colors)java.lang.Enum.valueOf(Colors.class, name);\r\n    }\r\n}\r\nThe Java compiler creates three constructors and methods for this enum construct: Colors(String name, int ordinal), Colors[] values(), and Colors valueOf(String name). The methods values and valueOf are implicitly declared. Consequently, their formal parameter names are implicitly declared as well.\r\nThe enum constructor Colors(String name, int ordinal) is a default constructor and it is implicitly declared. However, the formal parameters of this constructor (name and ordinal) are not implicitly declared. Because these formal parameters are neither explicitly or implicitly declared, they are synthetic. (The formal parameters for the default constructor of an enum construct are not implicitly declared because different compilers need not agree on the form of this constructor; another Java compiler might specify different formal parameters for it. When compilers compile expressions that use enum constants, they rely only on the  public static fields of the enum construct, which are implicitly declared, and not on their constructors or how these constants are initialized.)\r\nConsequently, the example MethodParameterExample prints the following about the enum construct Colors:\r\nenum Colors:\r\n\r\nNumber of constructors: 0\r\n\r\nNumber of declared constructors: 1\r\n\r\nDeclared constructor #1\r\nprivate MethodParameterExamples$Colors()\r\n         Parameter class: class java.lang.String\r\n          Parameter name: $enum$name\r\n               Modifiers: 4096\r\n            Is implicit?: false\r\n        Is name present?: true\r\n           Is synthetic?: true\r\n         Parameter class: int\r\n          Parameter name: $enum$ordinal\r\n               Modifiers: 4096\r\n            Is implicit?: false\r\n        Is name present?: true\r\n           Is synthetic?: true\r\n\r\nNumber of methods: 2\r\n\r\nMethod #1\r\npublic static MethodParameterExamples$Colors[]\r\n    MethodParameterExamples$Colors.values()\r\n             Return type: class [LMethodParameterExamples$Colors;\r\n     Generic return type: class [LMethodParameterExamples$Colors;\r\n\r\nMethod #2\r\npublic static MethodParameterExamples$Colors\r\n    MethodParameterExamples$Colors.valueOf(java.lang.String)\r\n             Return type: class MethodParameterExamples$Colors\r\n     Generic return type: class MethodParameterExamples$Colors\r\n         Parameter class: class java.lang.String\r\n          Parameter name: name\r\n               Modifiers: 32768\r\n            Is implicit?: true\r\n        Is name present?: true\r\n           Is synthetic?: false\r\nRefer to the Java Language Specification for more information about implicitly declared constructs, including parameters that appear as implicit in the Reflection API.\r\n",
        "title": "Oracle_Obtaining Names of Method Parameters.txt",
        "type": "Oracle_"
    }, {
        "rank": 7,
        "text": "\r\nThis trail covers the fundamentals of programming in the Java programming language. \r\n Object-Oriented Programming Concepts teaches you the core concepts behind object-oriented programming: objects, messages, classes, and inheritance. This lesson ends by showing you how these concepts translate into code. Feel free to skip this lesson if you are already familiar with object-oriented programming. \r\n Language Basics describes the traditional features of the language, including variables, arrays, data types, operators, and control flow. \r\n Classes and Objects describes how to write the classes from which objects are created, and how to create and use the objects. \r\n Annotations are a form of metadata and provide information for the compiler. This lesson describes where and how to use annotations in a program effectively.\r\n Interfaces and Inheritance describes interfacesâ\u20ac\u201dwhat they are, why you would want to write one, and how to write one. This section also describes the way in which you can derive one class from another. That is, how a subclass can inherit fields and methods from a superclass. You will learn that all classes are derived from the Object class, and how to modify the methods that a subclass inherits from superclasses. \r\n Numbers and Strings This lesson describes how to use Number and String objects The lesson also shows you how to format data for output. \r\n Generics are a powerful feature of the Java programming language. They improve the type safety of your code, making more of your bugs detectable at compile time. \r\n Packages are a feature of the Java programming language that help you to organize and structure your classes and their relationships to one another.\r\n",
        "title": "Oracle_Learning the Java Language.txt",
        "type": "Oracle_"
    }, {
        "rank": 8,
        "text": "\r\nEvery type is either a reference or a primitive. Classes, enums, and arrays (which all inherit from\r\njava.lang.Object) as well as interfaces are all reference types. Examples of reference types include \r\njava.lang.String, all of the wrapper classes for primitive types such as \r\njava.lang.Double, the interface \r\njava.io.Serializable, and the enum \r\njavax.swing.SortOrder. There is a fixed set of primitive types: boolean, byte, short, int, long, char, float, and double.\r\nFor every type of object, the Java virtual machine instantiates an immutable instance of \r\njava.lang.Class which provides methods to examine the runtime properties of the object including its members and type information. \r\nClass also provides the ability to create new classes and objects. Most importantly, it is the entry point for all of the Reflection APIs. This lesson covers the most commonly used reflection operations involving classes:\r\n\r\nRetrieving Class Objects describes the ways to get a \r\nClass\r\nExamining Class Modifiers and Types shows how to access the class declaration information\r\nDiscovering Class Members illustrates how to list the constructors, fields, methods, and nested classes in a class\r\n\r\nTroubleshooting describes common errors encountered when using \r\nClass\r\n\r\n",
        "title": "Oracle_Classes.txt",
        "type": "Oracle_"
    }, {
        "rank": 9,
        "text": "\r\nThere are several modifiers that may be part of a field declaration:\r\n\r\nAccess modifiers: public, protected, and private\r\nField-specific modifiers governing runtime behavior: transient and volatile\r\nModifier restricting to one instance: static\r\nModifier prohibiting value modification: final\r\nAnnotations\r\n\r\nThe method \r\nField.getModifiers() can be used to return the integer representing the set of declared modifiers for the field. The bits representing the modifiers in this integer are defined in \r\njava.lang.reflect.Modifier.\r\nThe \r\nFieldModifierSpy example illustrates how to search for fields with a given modifier. It also determines whether the located field is synthetic (compiler-generated) or is an enum constant by invoking \r\nField.isSynthetic() and \r\nField.isEnumCostant() respectively.\r\n\r\n\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.Modifier;\r\nimport static java.lang.System.out;\r\n\r\nenum Spy { BLACK , WHITE }\r\n\r\npublic class FieldModifierSpy {\r\n    volatile int share;\r\n    int instance;\r\n    class Inner {}\r\n\r\n    public static void main(String... args) {\r\n\ttry {\r\n\t    Class<?> c = Class.forName(args[0]);\r\n\t    int searchMods = 0x0;\r\n\t    for (int i = 1; i < args.length; i++) {\r\n\t\tsearchMods |= modifierFromString(args[i]);\r\n\t    }\r\n\r\n\t    Field[] flds = c.getDeclaredFields();\r\n\t    out.format(\"Fields in Class '%s' containing modifiers:  %s%n\",\r\n\t\t       c.getName(),\r\n\t\t       Modifier.toString(searchMods));\r\n\t    boolean found = false;\r\n\t    for (Field f : flds) {\r\n\t\tint foundMods = f.getModifiers();\r\n\t\t// Require all of the requested modifiers to be present\r\n\t\tif ((foundMods & searchMods) == searchMods) {\r\n\t\t    out.format(\"%-8s [ synthetic=%-5b enum_constant=%-5b ]%n\",\r\n\t\t\t       f.getName(), f.isSynthetic(),\r\n\t\t\t       f.isEnumConstant());\r\n\t\t    found = true;\r\n\t\t}\r\n\t    }\r\n\r\n\t    if (!found) {\r\n\t\tout.format(\"No matching fields%n\");\r\n\t    }\r\n\r\n        // production code should handle this exception more gracefully\r\n\t} catch (ClassNotFoundException x) {\r\n\t    x.printStackTrace();\r\n\t}\r\n    }\r\n\r\n    private static int modifierFromString(String s) {\r\n\tint m = 0x0;\r\n\tif (\"public\".equals(s))           m |= Modifier.PUBLIC;\r\n\telse if (\"protected\".equals(s))   m |= Modifier.PROTECTED;\r\n\telse if (\"private\".equals(s))     m |= Modifier.PRIVATE;\r\n\telse if (\"static\".equals(s))      m |= Modifier.STATIC;\r\n\telse if (\"final\".equals(s))       m |= Modifier.FINAL;\r\n\telse if (\"transient\".equals(s))   m |= Modifier.TRANSIENT;\r\n\telse if (\"volatile\".equals(s))    m |= Modifier.VOLATILE;\r\n\treturn m;\r\n    }\r\n}\r\n\r\nSample output follows:\r\n\r\n$ java FieldModifierSpy FieldModifierSpy volatile\r\nFields in Class 'FieldModifierSpy' containing modifiers:  volatile\r\nshare    [ synthetic=false enum_constant=false ]\r\n\r\n$ java FieldModifierSpy Spy public\r\nFields in Class 'Spy' containing modifiers:  public\r\nBLACK    [ synthetic=false enum_constant=true  ]\r\nWHITE    [ synthetic=false enum_constant=true  ]\r\n\r\n$ java FieldModifierSpy FieldModifierSpy\\$Inner final\r\nFields in Class 'FieldModifierSpy$Inner' containing modifiers:  final\r\nthis$0   [ synthetic=true  enum_constant=false ]\r\n\r\n$ java FieldModifierSpy Spy private static final\r\nFields in Class 'Spy' containing modifiers:  private static final\r\n$VALUES  [ synthetic=true  enum_constant=false ]\r\n\r\nNotice that some fields are reported even though they are not declared in the original code. This is because the compiler will generate some synthetic fields which are needed during runtime. To test whether a field is synthetic, the example invokes \r\nField.isSynthetic(). The set of synthetic fields is compiler-dependent; however commonly used fields include this$0 for inner classes (i.e. nested classes that are not static member classes) to reference the outermost enclosing class and $VALUES used by enums to implement the implicitly defined static method values(). The names of synthetic class members are not specified and may not be the same in all compiler implementations or releases. These and other synthetic fields will be included in the array returned by \r\nClass.getDeclaredFields() but not identified by \r\nClass.getField() since synthetic members are not typically public.\r\nBecause \r\nField implements the interface \r\njava.lang.reflect.AnnotatedElement, it is possible to retrieve any runtime annotation with \r\njava.lang.annotation.RetentionPolicy.RUNTIME. For an example of obtaining annotations see the section Examining Class Modifiers and Types.\r\n",
        "title": "Oracle_Retrieving and Parsing Field Modifiers.txt",
        "type": "Oracle_"
    }, {
        "rank": 10,
        "text": "\r\nBecause of the role of constructors in the language, fewer modifiers are meaningful than for methods:\r\n\r\nAccess modifiers: public, protected, and private\r\nAnnotations\r\n\r\nThe \r\nConstructorAccess example searches for constructors in a given class with the specified access modifier. It also displays whether the constructor is synthetic (compiler-generated) or of variable arity.\r\n\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Modifier;\r\nimport java.lang.reflect.Type;\r\nimport static java.lang.System.out;\r\n\r\npublic class ConstructorAccess {\r\n    public static void main(String... args) {\r\n\ttry {\r\n\t    Class<?> c = Class.forName(args[0]);\r\n\t    Constructor[] allConstructors = c.getDeclaredConstructors();\r\n\t    for (Constructor ctor : allConstructors) {\r\n\t\tint searchMod = modifierFromString(args[1]);\r\n\t\tint mods = accessModifiers(ctor.getModifiers());\r\n\t\tif (searchMod == mods) {\r\n\t\t    out.format(\"%s%n\", ctor.toGenericString());\r\n\t\t    out.format(\"  [ synthetic=%-5b var_args=%-5b ]%n\",\r\n\t\t\t       ctor.isSynthetic(), ctor.isVarArgs());\r\n\t\t}\r\n\t    }\r\n\r\n        // production code should handle this exception more gracefully\r\n\t} catch (ClassNotFoundException x) {\r\n\t    x.printStackTrace();\r\n\t}\r\n    }\r\n\r\n    private static int accessModifiers(int m) {\r\n\treturn m & (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED);\r\n    }\r\n\r\n    private static int modifierFromString(String s) {\r\n\tif (\"public\".equals(s))               return Modifier.PUBLIC;\r\n\telse if (\"protected\".equals(s))       return Modifier.PROTECTED;\r\n\telse if (\"private\".equals(s))         return Modifier.PRIVATE;\r\n\telse if (\"package-private\".equals(s)) return 0;\r\n\telse return -1;\r\n    }\r\n}\r\n\r\nThere is not an explicit \r\nModifier constant which corresponds to \"package-private\" access, so it is necessary to check for the absence of all three access modifiers to identify a package-private constructor.\r\nThis output shows the private constructors in \r\njava.io.File:\r\n\r\n$ java ConstructorAccess java.io.File private\r\nprivate java.io.File(java.lang.String,int)\r\n  [ synthetic=false var_args=false ]\r\nprivate java.io.File(java.lang.String,java.io.File)\r\n  [ synthetic=false var_args=false ]\r\n\r\nSynthetic constructors are rare; however the \r\nSyntheticConstructor example illustrates a typical situation where this may occur:\r\n\r\n\r\npublic class SyntheticConstructor {\r\n    private SyntheticConstructor() {}\r\n    class Inner {\r\n\t// Compiler will generate a synthetic constructor since\r\n\t// SyntheticConstructor() is private.\r\n\tInner() { new SyntheticConstructor(); }\r\n    }\r\n}\r\n\r\n\r\n$ java ConstructorAccess SyntheticConstructor package-private\r\nSyntheticConstructor(SyntheticConstructor$1)\r\n  [ synthetic=true  var_args=false ]\r\n\r\nSince the inner class's constructor references the private constructor of the enclosing class, the compiler must generate a package-private constructor. The parameter type SyntheticConstructor$1 is arbitrary and dependent on the compiler implementation. Code which depends on the presence of any synthetic or non-public class members may not be portable.\r\nConstructors implement \r\njava.lang.reflect.AnnotatedElement, which provides methods to retrieve runtime annotations with \r\njava.lang.annotation.RetentionPolicy.RUNTIME. For an example of obtaining annotations see the Examining Class Modifiers and Types section.\r\n",
        "title": "Oracle_Retrieving and Parsing Constructor Modifiers.txt",
        "type": "Oracle_"
    }]
}

post9_rec = {
    "response": [{
        "rank": 1,
        "text": "\r\nComputers running on the Internet communicate to each other using either the Transmission Control Protocol (TCP) or the User Datagram Protocol (UDP), as this diagram illustrates:\r\nWhen you write Java programs that communicate over the network, you are programming at the application layer. Typically, you don't need to concern yourself with the TCP and UDP layers. Instead, you can use the classes in the java.net package. These classes provide system-independent network communication. However, to decide which Java classes your programs should use, you do need to understand how TCP and UDP differ.\r\nTCP\r\nWhen two applications want to communicate to each other reliably, they establish a connection and send data back and forth over that connection. This is analogous to making a telephone call. If you want to speak to Aunt Beatrice in Kentucky, a connection is established when you dial her phone number and she answers. You send data back and forth over the connection by speaking to one another over the phone lines. Like the phone company, TCP guarantees that data sent from one end of the connection actually gets to the other end and in the same order it was sent. Otherwise, an error is reported.\r\nTCP provides a point-to-point channel for applications that require reliable communications. The Hypertext Transfer Protocol (HTTP), File Transfer Protocol (FTP), and Telnet are all examples of applications that require a reliable communication channel. The order in which the data is sent and received over the network is critical to the success of these applications. When HTTP is used to read from a URL, the data must be received in the order in which it was sent. Otherwise, you end up with a jumbled HTML file, a corrupt zip file, or some other invalid information.\r\nDefinition:Â TCP (Transmission Control Protocol) is a connection-based protocol that provides a reliable flow of data between two computers.\r\n\r\nUDP\r\nThe UDP protocol provides for communication that is not guaranteed between two applications on the network. UDP is not connection-based like TCP. Rather, it sends independent packets of data, called datagrams, from one application to another. Sending datagrams is much like sending a letter through the postal service: The order of delivery is not important and is not guaranteed, and each message is independent of any other.\r\nDefinition:Â UDP (User Datagram Protocol) is a protocol that sends independent packets of data, called datagrams, from one computer to another with no guarantees about arrival. UDP is not connection-based like TCP.\r\n\r\nFor many applications, the guarantee of reliability is critical to the success of the transfer of information from one end of the connection to the other. However, other forms of communication don't require such strict standards. In fact, they may be slowed down by the extra overhead or the reliable connection may invalidate the service altogether.\r\nConsider, for example, a clock server that sends the current time to its client when requested to do so. If the client misses a packet, it doesn't really make sense to resend it because the time will be incorrect when the client receives it on the second try. If the client makes two requests and receives packets from the server out of order, it doesn't really matter because the client can figure out that the packets are out of order and make another request. The reliability of TCP is unnecessary in this instance because it causes performance degradation and may hinder the usefulness of the service.\r\nAnother example of a service that doesn't need the guarantee of a reliable channel is the ping command. The purpose of the ping command is to test the communication between two programs over the network. In fact, ping needs to know about dropped or out-of-order packets to determine how good or bad the connection is. A reliable channel would invalidate this service altogether.\r\nThe UDP protocol provides for communication that is not guaranteed between two applications on the network. UDP is not connection-based like TCP. Rather, it sends independent packets of data from one application to another. Sending datagrams is much like sending a letter through the mail service: The order of delivery is not important and is not guaranteed, and each message is independent of any others.\r\nNote:Â Many firewalls and routers have been configured not to allow UDP packets. If you're having trouble connecting to a service outside your firewall, or if clients are having trouble connecting to your service, ask your system administrator if UDP is permitted.\r\n\r\nUnderstanding Ports\r\nGenerally speaking, a computer has a single physical connection to the network. All data destined for a particular computer arrives through that connection. However, the data may be intended for different applications running on the computer. So how does the computer know to which application to forward the data? Through the use of ports.\r\nData transmitted over the Internet is accompanied by addressing information that identifies the computer and the port for which it is destined. The computer is identified by its 32-bit IP address, which IP uses to deliver data to the right computer on the network. Ports are identified by a 16-bit number, which TCP and UDP use to deliver the data to the right application.\r\nIn connection-based communication such as TCP, a server application binds a socket to a specific port number. This has the effect of registering the server with the system to receive all data destined for that port. A client can then rendezvous with the server at the server's port, as illustrated here:\r\nDefinition:Â The TCP and UDP protocols use ports to map incoming data to a particular process running on a computer.\r\n\r\nIn datagram-based communication such as UDP, the datagram packet contains the port number of its destination and UDP routes the packet to the appropriate application, as illustrated in this figure:\r\nPort numbers range from 0 to 65,535 because ports are represented by 16-bit numbers. The port numbers ranging from 0 - 1023 are restricted; they are reserved for use by well-known services such as HTTP and FTP and other system services. These ports are called well-known ports. Your applications should not attempt to bind to them.\r\nNetworking Classes in the JDK\r\nThrough the classes in java.net, Java programs can use TCP or UDP to communicate over the Internet. The URL, URLConnection, Socket, and ServerSocket classes all use TCP to communicate over the network. The DatagramPacket, DatagramSocket, and MulticastSocket classes are for use with UDP.\r\n",
        "title": "Oracle_Networking Basics.txt",
        "type": "Oracle_"
    }, {
        "rank": 2,
        "text": "\r\nAs the focus was shifting from reaching GUI clients to thin client applications, with Java version 2, Sun introduced J2EE (Java 2 Extended Edition). J2EE addedÂ :\r\n\r\nComponents Base Architecture, (Servlet, JSP, EJB Containers)\r\n\r\nWith J2EE the following Java component executions are possible:\r\n\r\nFigure 2: Servlet Execution\r\n\r\nJava Servlet code(Figure 2) Java got its popularity with server side programming, more specifically withJ2EEservlets. Servlets are running in a simple J2EE framework to handle clientHTTPrequests. They are meant to replaceCGI programmingfor web pages rendering dynamic content.The servlet is running in a so calledservlet-container/web container. The servlet's responsibility is to:Handle the request by doing the business logic computation,Connecting to a database if needed,Create HTML to present to the user through the browserThe HTML output represents both the presention logic and the results of the business computations.  This represents a huge problem, and there is no real application relying only on servlets to handle the presention part of the responsibility. There are two main solutions to this:Use a template tool (Store the presentation part in an HTML file, marking the areas that need to be replaced after business logic computations).Use JSP (See next section)Wikipedia also has an article aboutServlets.\r\n\r\nFigure 3: Jsp Execution\r\n\r\nJava Server Pages (JSP) code(Figure 3) JSP is an HTML file with embedded Java code inside.  The first time the JSP is accessed, the JSP is converted to a Java Servlet. This servlet outputs HTML which has inside the result of the business logic computation. There are special JSP tags that helps to add data dynamically to the HTML. Also JSP technology allows to create custom tags.Using the JSP technology correctly, business logic computations should not be in the embedded Java part of the JSP. JSP should be used to render the presentation of the static and dynamic data. Depending on the complexity of the data, 100% separation is not easy to achieve. Using custom tags, however may help to get closer to 100%. This is advocated also inMVCarchitecture (see below).\r\n\r\nFigure 4: EJB Execution\r\n\r\nEJB code(Figure 4) In the 1990s, with the client server computing, a trend started, that is to move away from Mainframe computing. That resulted in many small separate applications in a Company/Enterprise. Many times the same data was used in different applications. A new philosophy, \"Enterprise Computing\", was created to address these issues.  The idea was to create components that can be reused throughout the Enterprise. The Enterprise Java Beans (EJBs) were supposed to address this.AnEJBis an application component that runs in an EJB container. The client accesses the EJB modules through the container, never directly.  The container manages the life cycle of the EJB modules, and handles all the issues that arise from network/enterpise computing. Some of those aresecurity/access control,object pooling,transaction management, ... .EJBs have the same problems as any reusable code: they need to be generic enough to be able to be reused and the changes or maintenance of EJBs can affect existing clients. Many times EJBs are used unnecessarily when they are not really needed. An EJB should be designed as a separate application in the enterprise, fulfilling one function.\r\n\r\n\r\n\r\nFigure 5: MVC Execution\r\n\r\nCombine J2EE components to create an MVC architectureThis leads us to the three layers/tiers as shown in (Figure 5).In modern web applications, with lots of static data and nice graphics, how the data is presented to the user became very important and usually needs the help of a graphic artist.To help programmers and graphic artists to work together, the separation between data, code, and how it is presented became crucial.Theview(User Interface Logic) contains the logic that is necessary to construct the presentation.  This could be handled by JSP technology.The servlet acts as thecontrollerand contains the logic that is necessary to process user events and to select an appropriate response.The business logic (model) actually accomplishes the goal of the interaction. This might be a query or an update to a database.  This could be handled by EJB technology.For more information about MVC, please seeMVC.\r\n\r\n",
        "title": "Execution_J2EE code execution_text.txt",
        "type": "text"
    }, {
        "rank": 3,
        "text": "\r\nThe HTTP state management mechanism specifies a way to create a stateful session with HTTP requests and responses.\r\nGenerally, HTTP request/response pairs are independent of each other. However, the state management mechanism enables clients and servers that can exchange state information to put these pairs in a larger context, which is called a session. The state information used to create and maintain the session is called a cookie.\r\nA cookie is a piece of data that can be stored in a browser's cache. If you visit a web site and then revisit it, the cookie data can be used to identify you as a return visitor. Cookies enable state information, such as an online shopping cart, to be remembered. A cookie can be short term, holding data for a single web session, that is, until you close the browser, or a cookie can be longer term, holding data for a week or a year.\r\nFor more information about HTTP state management, see \r\n\r\nRFC 2965: HTTP State Management Mechanism.\r\n",
        "title": "Oracle_HTTP State Management With Cookies.txt",
        "type": "Oracle_"
    }, {
        "rank": 4,
        "text": "\r\nSome applications that you write to communicate over the network will not require the reliable, point-to-point channel provided by TCP. Rather, your applications might benefit from a mode of communication that delivers independent packages of information whose arrival and order of arrival are not guaranteed.\r\nThe UDP protocol provides a mode of network communication whereby applications send packets of data, called datagrams, to one another. A datagram is an independent, self-contained message sent over the network whose arrival, arrival time, and content are not guaranteed. The DatagramPacket and DatagramSocket classes in the java.net package implement system-independent datagram communication using UDP.\r\nWhat Is a Datagram?\r\nA datagram is an independent, self-contained message sent over the network whose arrival, arrival time, and content are not guaranteed.\r\nWriting a Datagram Client and Server\r\nThis section walks you through an example that contains two Java programs that use datagrams to communicate. The server side is a quote server that listens to its DatagramSocket and sends a quotation to a client whenever the client requests it. The client side is a simple program that simply makes a request of the server.\r\nBroadcasting to Multiple Recipients\r\nThis section modifies the quote server so that instead of sending a quotation to a single client upon request, the quote server broadcasts a quote every minute to as many clients as are listening. The client program must be modified accordingly.\r\nNote:Â Many firewalls and routers are configured not to allow UDP packets. If you have trouble connecting to a service outside your firewall, or if clients have trouble connecting to your service, ask your system administrator if UDP is permitted.\r\n\r\n",
        "title": "Oracle_All About Datagrams.txt",
        "type": "Oracle_"
    }, {
        "rank": 5,
        "text": "\r\nThe Java platform is highly regarded in part because of its suitability for writing programs that use and interact with the resources on the Internet and the World Wide Web. In fact, Java-compatible browsers use this ability of the Java platform to the extreme to transport and run applets over the Internet.\r\nThis trail walks you through the complexities of writing Java applications and applets that can be used on the Internet. \r\n Overview of Networking has two sections. The first describes the networking capabilities of the Java platform that you may already be using without realizing that you are using the network. The second provides a brief overview of networking to familiarize you with terms and concepts that you should understand before reading how to use URLs, sockets, and datagrams. \r\n Working With URLs discusses how your Java programs can use URLs to access information on the Internet. A URL (Uniform Resource Locator) is the address of a resource on the Internet. Your Java programs can use URLs to connect to and retrieve information over a network. This lesson provides a more complete definition of a URL and shows you how to create and parse a URL, how to open a connection to a URL, and how to read from and write to that connection. \r\n All About Sockets explains how to use sockets so that your programs can communicate with other programs on the network. A socket is one endpoint of a two-way communication link between two programs running on the network. This lesson shows you how a client can connect to a standard server, the Echo server, and communicate with it via a socket. It then walks you through the details of a complete client/server example, which shows you how to implement both the client side and the server side of a client/server pair. \r\n All About Datagrams takes you step by step through a simple client/server example that uses datagrams to communicate. It then challenges you to rewrite the example using multicast socket instead. \r\n Programmatic Access to Network Parameters explains why you might want to access network interface parameters and how to do so. It gives examples of how to list all the IP addresses assigned to the machine as well as other useful information such as whether the interface is running. \r\n Working With Cookies discusses how cookies are used to create a session between a client and server, and how you can take advantage of cookies in your HTTP URL connections.\r\nSecurity considerations:Â Note that communications over the network are subject to approval by the current security manager. \r\nThe Security Manager\r\n describes what a security manager is and how it impacts your applications. For general information about the security features provided by the JDK, refer to \r\n\r\nSecurity Features in Java SE\r\n.\r\nThe example programs in the following lessons that cover URLs, sockets, and datagrams are standalone applications, which, by default, have no security manager. If you convert these applications to applets, they may be unable to communicate over the network, depending on the browser or viewer in which they are running. See \r\n\r\nWhat Applets Can and Cannot Do\r\n for information about the security restrictions placed on applets.\r\n\r\n",
        "title": "Oracle_Custom Networking.txt",
        "type": "Oracle_"
    }, {
        "rank": 6,
        "text": "\r\nJava language first edition came out in the client-server era.  Thick clients were developed with rich GUI interfaces. Java first edition, JSE (Java Standard Edition) had/has the following in its belt:\r\n\r\nGUI capabilities (AWT, Swing)Network computing capabilities (RMI)Multi-tasking capabilities (Threads)\r\n\r\nWith JSE the following Java code executions are possible:\r\n\r\nFigure 1: Stand alone execution\r\n\r\nStand alone Java application(Figure 1) Stand alone application refers to a Java program where both the user interface and business modules are running on the same computer.  The application may or may not use a database to persist data. The user interface could be either AWT or Swing.The application would start with amain()method of a Class.  The application stops when themain()method exits, or if an exception is thrown from the application to the JVM. Classes are loaded to memory and compiled as needed, either from the file system or from a *.jar file, by the JVM.Invocation of Java programs distributed in this manner requires usage of the command line.  Once the user has all the class files, he needs to launch the application by the following command line (where Main is the name of the class containing the main() method.)\r\n\r\nExecution of classjava Main\r\n\r\nJava 'jar' class librariesUtility classes, framework classes, and/or third party classes are usually packaged and distributed in Java ' *.jar' files.  These 'jar' files need to be put in the CLASSPATH of the java program from  which these classes are going to be used.If a jar file is executable, it can be run from the command line:\r\n\r\nExecution of archivejava -jar Application.jar\r\n\r\n\r\n\r\nClient Server applicationsThe client server applications consist of a front-end, and a back-end part, each running on a separate computer. The idea is that the business logic would be on the back-end part of the program, which would be reused by all the clients. Here the challenge is to achieve a separation between front-end user interface code, and the back-end business logic code.The communication between the front-end and the back-end can be achieved by two ways.One way is to define a data communicationprotocolbetween the two tiers. The back-end part would listen for an incoming request. Based on theprotocolit interprets the request and sends back the result in data form.The other way is to useJava Remote Invocation(RMI). With the use of RMI, a remote object can be created and used by the client.  In this case Java objects are transmitted across the network.More information can be found about client-server programming, with sample code, at theClient Server Chapterin this book.\r\n\r\nWeb ApplicationsFor applications needed by lots of client installations, the client-server model did not work. Maintaining and upgrading the hundreds or thousands of clients caused a problem. It was not practical. The solution to this problem was to create a unified, standard client, for all applications, and that is theBrowser.Having a standard client, it makes sense to create a unified, standard back-end service as well, and that is theApplication Server.Web Applicationis an application that is running in theApplication Server, and it can be accessed and used by theBrowserclient.There are three main area of interest in Web Applications, those are:TheWeb Browser. This is the container of rendering HTML text, and running client scriptsTheHTTPprotocol. Text data are sent back and forth between Browser and the ServerTheWeb serverto serve static content,Application serverto serve dynamic content and hostEJBs.Wikipedia also has an article aboutWeb application.\r\n\r\n",
        "title": "Execution_JSE code execution_text.txt",
        "type": "text"
    }, {
        "rank": 7,
        "text": "\r\nThe URLConnection class contains many methods that let you communicate with the URL over the network. URLConnection is an HTTP-centric class; that is, many of its methods are useful only when you are working with HTTP URLs. However, most URL protocols allow you to read from and write to the connection. This section describes both functions.\r\nReading from a URLConnection\r\nThe following program performs the same function as the URLReader program shown in \r\nReading Directly from a URL.\r\nHowever, rather than getting an input stream directly from the URL, this program explicitly retrieves a URLConnection object and gets an input stream from the connection. The connection is opened implicitly by calling getInputStream. Then, like URLReader, this program creates a BufferedReader on the input stream and reads from it. The bold statements highlight the differences between this example and the previous:\r\n\r\nimport java.net.*;\r\nimport java.io.*;\r\n\r\npublic class URLConnectionReader {\r\n    public static void main(String[] args) throws Exception {\r\n        URL oracle = new URL(\"http://www.oracle.com/\");\r\n        URLConnection yc = oracle.openConnection();\r\n        BufferedReader in = new BufferedReader(new InputStreamReader(\r\n                                    yc.getInputStream()));\r\n        String inputLine;\r\n        while ((inputLine = in.readLine()) != null) \r\n            System.out.println(inputLine);\r\n        in.close();\r\n    }\r\n}\r\n\r\nThe output from this program is identical to the output from the program that opens a stream directly from the URL. You can use either way to read from a URL. However, reading from a URLConnection instead of reading directly from a URL might be more useful. This is because you can use the URLConnection object for other tasks (like writing to the URL) at the same time.\r\nAgain, if the program hangs or you see an error message, you may have to set the proxy host so that the program can find the Oracle server.\r\nWriting to a URLConnection\r\nMany HTML pages contain forms â\u20ac\u201d text fields and other GUI objects that let you enter data to send to the server. After you type in the required information and initiate the query by clicking a button, your Web browser writes the data to the URL over the network. At the other end the server receives the data, processes it, and then sends you a response, usually in the form of a new HTML page.\r\nMany of these HTML forms use the HTTP POST METHOD to send data to the server. Thus writing to a URL is often called posting to a URL. The server recognizes the POST request and reads the data sent from the client.\r\nFor a Java program to interact with a server-side process it simply must be able to write to a URL, thus providing data to the server. It can do this by following these steps:\r\n\r\nCreate a URL.\r\nRetrieve the URLConnection object.\r\nSet output capability on the URLConnection.\r\nOpen a connection to the resource.\r\nGet an output stream from the connection.\r\nWrite to the output stream.\r\nClose the output stream.\r\n\r\n\r\nHere is a small servlet named \r\n\r\nReverseServlet (or if you prefer a cgi-bin script).\r\nYou can use this servlet to test the following example program.\r\nThe servlet running in a container reads from its InputStream, reverses the string, and writes it to its OutputStream. The servlet requires input of the form string=string_to_reverse, where string_to_reverse is the string whose characters you want displayed in reverse order.\r\nHere's an example program that runs the ReverseServlet over the network through a URLConnection:\r\n\r\nimport java.io.*;\r\nimport java.net.*;\r\n\r\npublic class Reverse {\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        if (args.length != 2) {\r\n            System.err.println(\"Usage:  java Reverse \"\r\n                + \"http://<location of your servlet/script>\"\r\n                + \" string_to_reverse\");\r\n            System.exit(1);\r\n        }\r\n\r\n        String stringToReverse = URLEncoder.encode(args[1], \"UTF-8\");\r\n\r\n        URL url = new URL(args[0]);\r\n        URLConnection connection = url.openConnection();\r\n        connection.setDoOutput(true);\r\n\r\n        OutputStreamWriter out = new OutputStreamWriter(\r\n                                         connection.getOutputStream());\r\n        out.write(\"string=\" + stringToReverse);\r\n        out.close();\r\n\r\n        BufferedReader in = new BufferedReader(\r\n                                    new InputStreamReader(\r\n                                    connection.getInputStream()));\r\n        String decodedString;\r\n        while ((decodedString = in.readLine()) != null) {\r\n            System.out.println(decodedString);\r\n        }\r\n        in.close();\r\n    }\r\n}\r\n\r\nLet's examine the program and see how it works. First, the program processes its command-line arguments:\r\n\r\nif (args.length != 2) {\r\n    System.err.println(\"Usage:  java Reverse \"\r\n        + \"http://<location of your servlet/script>\"\r\n        + \" string_to_reverse\");\r\n    System.exit(1);\r\n}       \r\n\r\nString stringToReverse = URLEncoder.encode(args[1], \"UTF-8\");\r\n\r\nThese statements ensure that the user provides two and only two command-line arguments to the program. The command-line arguments are the location of the ReverseServlet and the string that will be reversed. It may contain spaces or other non-alphanumeric characters. These characters must be encoded because the string is processed on its way to the server. The URLEncoder class methods encode the characters.\r\nNext, the program creates the URL object, and sets the connection so that it can write to it:\r\n\r\nURL url = new URL(args[0]);\r\nURLConnection connection = url.openConnection();\r\nconnection.setDoOutput(true);\r\n\r\nThe program then creates an output stream on the connection and opens an OutputStreamWriter on it:\r\n\r\nOutputStreamWriter out = new OutputStreamWriter(connection.getOutputStream());\r\n\r\nIf the URL does not support output, getOutputStream method throws an UnknownServiceException. If the URL does support output, then this method returns an output stream that is connected to the input stream of the URL on the server side â\u20ac\u201d the client's output is the server's input.\r\nNext, the program writes the required information to the output stream and closes the stream:\r\n\r\nout.write(\"string=\" + stringToReverse);\r\nout.close();\r\n\r\nThis code writes to the output stream using the write method. So you can see that writing data to a URL is as easy as writing data to a stream. The data written to the output stream on the client side is the input for the servlet on the server side. The Reverse program constructs the input in the form required by the script by prepending string= to the encoded string to be reversed.\r\nThe servlet reads the information you write, performs a reverse operation on the string value, and then sends this back to you. You now need to read the string the server has sent back. The Reverse program does it like this:\r\n\r\nBufferedReader in = new BufferedReader(\r\n                            new InputStreamReader(\r\n                            connection.getInputStream()));\r\nString decodedString;\r\nwhile ((decodedString = in.readLine()) != null) {\r\n    System.out.println(decodedString);\r\n}\r\nin.close();\r\n\r\nIf your ReverseServlet is located at http://example.com/servlet/ReverseServlet, then when you run the Reverse program using\r\n\r\nhttp://example.com/servlet/ReverseServlet \"Reverse Me\"\r\n\r\nas the argument (including the double quote marks), you should see this output:\r\n\r\nReverse Me\r\n reversed is: \r\neM esreveR\r\n\r\n",
        "title": "Oracle_Reading from and Writing to a URLConnection.txt",
        "type": "Oracle_"
    }, {
        "rank": 8,
        "text": "\r\nThe JDBC API is a Java API that can access any kind of tabular data, especially data stored in a Relational Database.\r\n JDBC helps you to write Java applications that manage these three programming activities:\r\n\r\nConnect to a data source, like a database\r\nSend queries and update statements to the database\r\nRetrieve and process the results received from the database in answer to your query\r\n\r\nThe following simple code fragment gives a simple example of these three steps:\r\n\r\npublic void connectToAndQueryDatabase(String username, String password) {\r\n\r\n    Connection con = DriverManager.getConnection(\r\n                         \"jdbc:myDriver:myDatabase\",\r\n                         username,\r\n                         password);\r\n\r\n    Statement stmt = con.createStatement();\r\n    ResultSet rs = stmt.executeQuery(\"SELECT a, b, c FROM Table1\");\r\n\r\n    while (rs.next()) {\r\n        int x = rs.getInt(\"a\");\r\n        String s = rs.getString(\"b\");\r\n        float f = rs.getFloat(\"c\");\r\n    }\r\n}\r\n\r\nThis short code fragment instantiates a DriverManager object to connect to a database driver and log into the database, instantiates a Statement object that carries your SQL language query to the database; instantiates a ResultSet object that retrieves the results of your query, and executes a simple while loop, which retrieves and displays those results. It's that simple.\r\nJDBC Product Components\r\nJDBC includes four components:\r\n\r\n\r\nThe JDBC APIÂ â\u20ac\u201dÂ  The JDBCâ\u201e¢ API provides programmatic access to relational data from the Javaâ\u201e¢ programming language. Using the JDBC API, applications can execute SQL statements, retrieve results, and propagate changes back to an underlying data source. The JDBC API can also interact with multiple data sources in a distributed, heterogeneous environment.\r\nThe JDBC API is part of the Java platform, which includes the Javaâ\u201e¢ Standard Edition (Javaâ\u201e¢ SE ) and the Javaâ\u201e¢ Enterprise Edition (Javaâ\u201e¢ EE). The JDBC 4.0 API is divided into two packages: java.sql and javax.sql. Both packages are included in the Java SE and Java EE platforms.\r\n\r\n\r\nJDBC Driver ManagerÂ â\u20ac\u201dÂ  The JDBC DriverManager class defines objects which can connect Java applications to a JDBC driver. DriverManager has traditionally been the backbone of the JDBC architecture. It is quite small and simple.\r\nThe Standard Extension packages javax.naming and javax.sql let you use a DataSource object registered with a Java Naming and Directory Interfaceâ\u201e¢ (JNDI) naming service to establish a connection with a data source. You can use either connecting mechanism, but using a DataSource object is recommended whenever possible.\r\n\r\n\r\nJDBC Test SuiteÂ â\u20ac\u201dÂ  The JDBC driver test suite helps you to determine that JDBC drivers will run your program. These tests are not comprehensive or exhaustive, but they do exercise many of the important features in the JDBC API.\r\n\r\n\r\nJDBC-ODBC BridgeÂ â\u20ac\u201dÂ  The Java Software bridge provides JDBC access via ODBC drivers. Note that you need to load ODBC binary code onto each client machine that uses this driver. As a result, the ODBC driver is most appropriate on a corporate network where client installations are not a major problem, or for application server code written in Java in a three-tier architecture.\r\n\r\n\r\nThis Trail uses the first two of these these four JDBC components to connect to a database and then build a java program that uses SQL commands to communicate with a test Relational Database. The last two components are used in specialized environments to test web applications, or to communicate with ODBC-aware DBMSs.\r\nJDBC Architecture\r\n\r\nTwo-tier and Three-tier Processing Models\r\nThe JDBC API supports both two-tier and three-tier processing models for database access.\r\n\r\nFigure 1: Two-tier Architecture for Data Access.\r\n\r\n\r\n\r\nIn the two-tier model, a Java applet or application talks directly to the data source. This requires a JDBC driver that can communicate with the particular data source being accessed. A user's commands are delivered to the database or other data source, and the results of those statements are sent back to the user. The data source may be located on another machine to which the user is connected via a network. This is referred to as a client/server configuration, with the user's machine as the client, and the machine housing the data source as the server. The network can be an intranet, which, for example, connects employees within a corporation, or it can be the Internet.\r\n In the three-tier model, commands are sent to a \"middle tier\" of services, which then sends the commands to the data source. The data source processes the commands and sends the results back to the middle tier, which then sends them to the user. MIS directors find the three-tier model very attractive because the middle tier makes it possible to maintain control over access and the kinds of updates that can be made to corporate data. Another advantage is that it simplifies the deployment of applications. Finally, in many cases, the three-tier architecture can provide performance advantages.\r\n\r\nFigure 2: Three-tier Architecture for Data Access.\r\n\r\n\r\n\r\n Until recently, the middle tier has often been written in languages such as C or C++, which offer fast performance. However, with the introduction of optimizing compilers that translate Java bytecode into efficient machine-specific code and technologies such as Enterprise JavaBeansâ\u201e¢, the Java platform is fast becoming the standard platform for middle-tier development. This is a big plus, making it possible to take advantage of Java's robustness, multithreading, and security features.\r\n With enterprises increasingly using the Java programming language for writing server code, the JDBC API is being used more and more in the middle tier of a three-tier architecture. Some of the features that make JDBC a server technology are its support for connection pooling, distributed transactions, and disconnected rowsets. The JDBC API is also what allows access to a data source from a Java middle tier.\r\n\r\nA Relational Database Overview\r\nA database is a means of storing information in such a way that information can be retrieved from it. In simplest terms, a relational database is one that presents information in tables with rows and columns. A table is referred to as a relation in the sense that it is a collection of objects of the same type (rows). Data in a table can be related according to common keys or concepts, and the ability to retrieve related data from a table is the basis for the term relational database. A Database Management System (DBMS) handles the way data is stored, maintained, and retrieved. In the case of a relational database, a Relational Database Management System (RDBMS) performs these tasks. DBMS as used in this book is a general term that includes RDBMS.\r\n\r\nIntegrity Rules\r\nRelational tables follow certain integrity rules to ensure that the data they contain stay accurate and are always accessible. First, the rows in a relational table should all be distinct. If there are duplicate rows, there can be problems resolving which of two possible selections is the correct one. For most DBMSs, the user can specify that duplicate rows are not allowed, and if that is done, the DBMS will prevent the addition of any rows that duplicate an existing row.\r\nA second integrity rule of the traditional relational model is that column values must not be repeating groups or arrays. A third aspect of data integrity involves the concept of a null value. A database takes care of situations where data may not be available by using a null value to indicate that a value is missing. It does not equate to a blank or zero. A blank is considered equal to another blank, a zero is equal to another zero, but two null values are not considered equal.\r\nWhen each row in a table is different, it is possible to use one or more columns to identify a particular row. This unique column or group of columns is called a primary key. Any column that is part of a primary key cannot be null; if it were, the primary key containing it would no longer be a complete identifier. This rule is referred to as entity integrity.\r\nThe Employees table illustrates some of these relational database concepts. It has five columns and six rows, with each row representing a different employee.\r\n\r\nEmployees Table\r\n\r\n\r\nEmployee_Number\r\nFirst_name\r\nLast_Name\r\nDate_of_Birth\r\nCar_Number\r\n\r\n\r\n10001\r\nAxel\r\nWashington\r\n28-Aug-43\r\n5\r\n\r\n\r\n10083\r\nArvid\r\nSharma\r\n24-Nov-54\r\nnull\r\n\r\n\r\n10120\r\nJonas\r\nGinsberg\r\n01-Jan-69\r\nnull\r\n\r\n\r\n10005\r\nFlorence\r\nWojokowski\r\n04-Jul-71\r\n12\r\n\r\n\r\n10099\r\nSean\r\nWashington\r\n21-Sep-66\r\nnull\r\n\r\n\r\n10035\r\nElizabeth\r\nYamaguchi\r\n24-Dec-59\r\nnull\r\n\r\n\r\nThe primary key for this table would generally be the employee number because each one is guaranteed to be different. (A number is also more efficient than a string for making comparisons.) It would also be possible to use First_Name and Last_Name because the combination of the two also identifies just one row in our sample database. Using the last name alone would not work because there are two employees with the last name of \"Washington.\" In this particular case the first names are all different, so one could conceivably use that column as a primary key, but it is best to avoid using a column where duplicates could occur. If Elizabeth Yamaguchi gets a job at this company and the primary key is First_Name, the RDBMS will not allow her name to be added (if it has been specified that no duplicates are permitted). Because there is already an Elizabeth in the table, adding a second one would make the primary key useless as a way of identifying just one row. Note that although using First_Name and Last_Name is a unique composite key for this example, it might not be unique in a larger database. Note also that the Employee table assumes that there can be only one car per employee.\r\nSELECT Statements\r\nSQL is a language designed to be used with relational databases. There is a set of basic SQL commands that is considered standard and is used by all RDBMSs. For example, all RDBMSs use the SELECT statement.\r\nA SELECT statement, also called a query, is used to get information from a table. It specifies one or more column headings, one or more tables from which to select, and some criteria for selection. The RDBMS returns rows of the column entries that satisfy the stated requirements. A SELECT statement such as the following will fetch the first and last names of employees who have company cars:\r\n\r\nSELECT First_Name, Last_Name\r\nFROM Employees\r\nWHERE Car_Number IS NOT NULL\r\n\r\nThe result set (the set of rows that satisfy the requirement of not having null in the Car_Number column) follows. The first name and last name are printed for each row that satisfies the requirement because the SELECT statement (the first line) specifies the columns First_Name and Last_Name. The FROM clause (the second line) gives the table from which the columns will be selected.\r\n\r\n\r\nFIRST_NAME\r\nLAST_NAME\r\n\r\n\r\nAxel\r\nWashington\r\n\r\n\r\nFlorence\r\nWojokowski\r\n\r\n\r\nThe following code produces a result set that includes the whole table because it asks for all of the columns in the table Employees with no restrictions (no WHERE clause). Note that SELECT * means \"SELECT all columns.\"\r\n\r\nSELECT *\r\nFROM Employees\r\n\r\n\r\nWHERE Clauses\r\nThe WHERE clause in a SELECT statement provides the criteria for selecting values. For example, in the following code fragment, values will be selected only if they occur in a row in which the column Last_Name begins with the string 'Washington'.\r\n\r\nSELECT First_Name, Last_Name\r\nFROM Employees\r\nWHERE Last_Name LIKE 'Washington%'\r\n\r\nThe keyword LIKE is used to compare strings, and it offers the feature that patterns containing wildcards can be used. For example, in the code fragment above, there is a percent sign (%) at the end of 'Washington', which signifies that any value containing the string 'Washington' plus zero or more additional characters will satisfy this selection criterion. So 'Washington' or 'Washingtonian' would be matches, but 'Washing' would not be. The other wildcard used in LIKE clauses is an underbar (_), which stands for any one character. For example,\r\n\r\nWHERE Last_Name LIKE 'Ba_man'\r\n\r\nwould match 'Batman', 'Barman', 'Badman', 'Balman', 'Bagman', 'Bamman', and so on.\r\nThe code fragment below has a WHERE clause that uses the equal sign (=) to compare numbers. It selects the first and last name of the employee who is assigned car 12.\r\n\r\nSELECT First_Name, Last_Name\r\nFROM Employees\r\nWHERE Car_Number = 12\r\n\r\nThe next code fragment selects the first and last names of employees whose employee number is greater than 10005:\r\n\r\nSELECT First_Name, Last_Name\r\nFROM Employees\r\nWHERE Employee_Number > 10005\r\n\r\nWHERE clauses can get rather elaborate, with multiple conditions and, in some DBMSs, nested conditions. This overview will not cover complicated WHERE clauses, but the following code fragment has a WHERE clause with two conditions; this query selects the first and last names of employees whose employee number is less than 10100 and who do not have a company car.\r\n\r\nSELECT First_Name, Last_Name\r\nFROM Employees\r\nWHERE Employee_Number < 10100 and Car_Number IS NULL\r\n\r\nA special type of WHERE clause involves a join, which is explained in the next section.\r\n\r\nJoins\r\nA distinguishing feature of relational databases is that it is possible to get data from more than one table in what is called a join. Suppose that after retrieving the names of employees who have company cars, one wanted to find out who has which car, including the make, model, and year of car. This information is stored in another table, Cars:\r\n\r\nCars Table\r\n\r\n\r\nCar_Number\r\nMake\r\nModel\r\nYear\r\n\r\n\r\n5\r\nHonda\r\nCivic DX\r\n1996\r\n\r\n\r\n12\r\nToyota\r\nCorolla\r\n1999\r\n\r\n\r\nThere must be one column that appears in both tables in order to relate them to each other. This column, which must be the primary key in one table, is called the foreign key in the other table. In this case, the column that appears in two tables is Car_Number, which is the primary key for the table Cars and the foreign key in the table Employees. If the 1996 Honda Civic were wrecked and deleted from the Cars table, then Car_Number 5 would also have to be removed from the Employees table in order to maintain what is called referential integrity. Otherwise, the foreign key column (Car_Number) in the Employees table would contain an entry that did not refer to anything in Cars. A foreign key must either be null or equal to an existing primary key value of the table to which it refers. This is different from a primary key, which may not be null. There are several null values in the Car_Number column in the table Employees because it is possible for an employee not to have a company car.\r\nThe following code asks for the first and last names of employees who have company cars and for the make, model, and year of those cars. Note that the FROM clause lists both Employees and Cars because the requested data is contained in both tables. Using the table name and a dot (.) before the column name indicates which table contains the column.\r\n\r\nSELECT Employees.First_Name, Employees.Last_Name,\r\n    Cars.Make, Cars.Model, Cars.Year\r\nFROM Employees, Cars\r\nWHERE Employees.Car_Number = Cars.Car_Number\r\n\r\nThis returns a result set that will look similar to the following:\r\n\r\n\r\nFIRST_NAME\r\nLAST_NAME\r\nMAKE\r\nMODEL\r\nYEAR\r\n\r\n\r\nAxel\r\nWashington\r\nHonda\r\nCivic DX\r\n1996\r\n\r\n\r\nFlorence\r\nWojokowski\r\nToyota\r\nCorolla\r\n1999\r\n\r\n\r\n\r\nCommon SQL Commands\r\nSQL commands are divided into categories, the two main ones being Data Manipulation Language (DML) commands and Data Definition Language (DDL) commands. DML commands deal with data, either retrieving it or modifying it to keep it up-to-date. DDL commands create or change tables and other database objects such as views and indexes.\r\nA list of the more common DML commands follows:\r\n\r\n\r\nSELECTÂ â\u20ac\u201dÂ  used to query and display data from a database. The SELECT statement specifies which columns to include in the result set. The vast majority of the SQL commands used in applications are SELECT statements.\r\n\r\n\r\nINSERTÂ â\u20ac\u201dÂ  adds new rows to a table. INSERT is used to populate a newly created table or to add a new row (or rows) to an already-existing table.\r\n\r\n\r\nDELETEÂ â\u20ac\u201dÂ  removes a specified row or set of rows from a table\r\n\r\n\r\nUPDATEÂ â\u20ac\u201dÂ  changes an existing value in a column or group of columns in a table\r\n\r\n\r\nThe more common DDL commands follow:\r\n\r\n\r\nCREATE TABLEÂ â\u20ac\u201dÂ  creates a table with the column names the user provides. The user also needs to specify a type for the data in each column. Data types vary from one RDBMS to another, so a user might need to use metadata to establish the data types used by a particular database. CREATE TABLE is normally used less often than the data manipulation commands because a table is created only once, whereas adding or deleting rows or changing individual values generally occurs more frequently.\r\n\r\n\r\nDROP TABLEÂ â\u20ac\u201dÂ  deletes all rows and removes the table definition from the database. A JDBC API implementation is required to support the DROP TABLE command as specified by SQL92, Transitional Level. However, support for the CASCADE and RESTRICT options of DROP TABLE is optional. In addition, the behavior of DROP TABLE is implementation-defined when there are views or integrity constraints defined that reference the table being dropped.\r\n\r\n\r\nALTER TABLEÂ â\u20ac\u201dÂ  adds or removes a column from a table. It also adds or drops table constraints and alters column attributes\r\n\r\n\r\n\r\nResult Sets and Cursors\r\nThe rows that satisfy the conditions of a query are called the result set. The number of rows returned in a result set can be zero, one, or many. A user can access the data in a result set one row at a time, and a cursor provides the means to do that. A cursor can be thought of as a pointer into a file that contains the rows of the result set, and that pointer has the ability to keep track of which row is currently being accessed. A cursor allows a user to process each row of a result set from top to bottom and consequently may be used for iterative processing. Most DBMSs create a cursor automatically when a result set is generated.\r\nEarlier JDBC API versions added new capabilities for a result set's cursor, allowing it to move both forward and backward and also allowing it to move to a specified row or to a row whose position is relative to another row.\r\n\r\nTransactions\r\nWhen one user is accessing data in a database, another user may be accessing the same data at the same time. If, for instance, the first user is updating some columns in a table at the same time the second user is selecting columns from that same table, it is possible for the second user to get partly old data and partly updated data. For this reason, DBMSs use transactions to maintain data in a consistent state (data consistency) while allowing more than one user to access a database at the same time (data concurrency).\r\nA transaction is a set of one or more SQL statements that make up a logical unit of work. A transaction ends with either a commit or a rollback, depending on whether there are any problems with data consistency or data concurrency. The commit statement makes permanent the changes resulting from the SQL statements in the transaction, and the rollback statement undoes all changes resulting from the SQL statements in the transaction.\r\nA lock is a mechanism that prohibits two transactions from manipulating the same data at the same time. For example, a table lock prevents a table from being dropped if there is an uncommitted transaction on that table. In some DBMSs, a table lock also locks all of the rows in a table. A row lock prevents two transactions from modifying the same row, or it prevents one transaction from selecting a row while another transaction is still modifying it.\r\n\r\nStored Procedures\r\nA stored procedure is a group of SQL statements that can be called by name. In other words, it is executable code, a mini-program, that performs a particular task that can be invoked the same way one can call a function or method. Traditionally, stored procedures have been written in a DBMS-specific programming language. The latest generation of database products allows stored procedures to be written using the Java programming language and the JDBC API. Stored procedures written in the Java programming language are bytecode portable between DBMSs. Once a stored procedure is written, it can be used and reused because a DBMS that supports stored procedures will, as its name implies, store it in the database.\r\nThe following code is an example of how to create a very simple stored procedure using the Java programming language. Note that the stored procedure is just a static Java method that contains normal JDBC code. It accepts two input parameters and uses them to change an employee's car number.\r\nDo not worry if you do not understand the example at this point. The code example below is presented only to illustrate what a stored procedure looks like. You will learn how to write the code in this example in the tutorials that follow.\r\n\r\nimport java.sql.*;\r\n\r\npublic class UpdateCar {\r\n\r\n    public static void UpdateCarNum(int carNo, int empNo)\r\n        throws SQLException {\r\n\r\n        Connection con = null;\r\n        PreparedStatement pstmt = null;   \r\n      \r\n        try {\r\n            con = DriverManager.getConnection(\r\n                      \"jdbc:default:connection\");\r\n\r\n            pstmt = con.prepareStatement(\r\n                        \"UPDATE EMPLOYEES \" +\r\n                        \"SET CAR_NUMBER = ? \" +\r\n                        \"WHERE EMPLOYEE_NUMBER = ?\");\r\n\r\n            pstmt.setInt(1, carNo);\r\n            pstmt.setInt(2, empNo);\r\n            pstmt.executeUpdate();\r\n        }\r\n        finally {\r\n            if (pstmt != null) pstmt.close();\r\n        }\r\n    }\r\n}\r\n\r\n\r\nMetadata\r\nDatabases store user data, and they also store information about the database itself. Most DBMSs have a set of system tables, which list tables in the database, column names in each table, primary keys, foreign keys, stored procedures, and so forth. Each DBMS has its own functions for getting information about table layouts and database features. JDBC provides the interface DatabaseMetaData, which a driver writer must implement so that its methods return information about the driver and/or DBMS for which the driver is written. For example, a large number of methods return whether or not the driver supports a particular functionality. This interface gives users and tools a standardized way to get metadata.\r\nIn general, developers writing tools and drivers are the ones most likely to be concerned with metadata.\r\n",
        "title": "Oracle_JDBC Introduction.txt",
        "type": "Oracle_"
    }, {
        "rank": 9,
        "text": "\r\n\r\nBufferStrategy\r\nIn Java 2 Standard Edition, you don't have to worry about video pointers or video memory in order to take full advantage of either double-buffering or page-flipping. The new class java.awt.image.BufferStrategy has been added for the convenience of dealing with drawing to surfaces and components in a general way, regardless of the number of buffers used or the technique used to display them.\r\nA buffer strategy gives you two all-purpose methods for drawing: getDrawGraphics and show. When you want to start drawing, get a draw graphics and use it. When you are finished drawing and want to present your information to the screen, call show. These two methods are designed to fit rather gracefully into a rendering loop:\r\n\r\nBufferStrategy myStrategy;\r\n\r\nwhile (!done) {\r\n    Graphics g = myStrategy.getDrawGraphics();\r\n    render(g);\r\n    g.dispose();\r\n    myStrategy.show();\r\n}\r\n\r\nBuffer strategies have also been set up to help you monitor VolatileImage issues. When in full-screen exclusive mode, VolatileImage issues are especially important because the windowing system can sometimes take back the video memory it has given you. One important example is when the user presses the ALT+TAB key combination in Windows--suddenly your full-screen program is running in the background and your video memory is lost. You can call the contentsLost method to find out if this has happened. Similarly, when the windowing system returns your memory to you, you can find out using the contentsRestored method.\r\nBufferCapabilities\r\nAs mentioned before, different operating systems, or even different graphics cards on the same operating system, have different techniques available at their disposal. These capabilities are exposed for you so that you can pick the best technique for your application.\r\nThe class java.awt.BufferCapabilities encapsulates these capabilities. Every buffer strategy is controlled by its buffer capabilities, so picking the right ones for your application is very crucial. To find out what capabilities are available, call the getBufferCapabilities method from the GraphicsConfiguration objects available on your graphics device.\r\nThe capabilities available in Java 2 Standard Edition version 1.4 are:\r\n\r\n\r\nisPageFlipping\r\nThis capability returns whether or not hardware page-flipping is available on this graphics configuration.\r\n\r\nisFullScreenRequired\r\nThis capability returns whether or not full-screen exclusive mode is required before hardware page-flipping should be attempted.\r\n\r\nisMultiBufferAvailable\r\nThis capability returns whether or not multiple buffering (two or more back buffers plus the primary surface) in hardware is available.\r\n\r\ngetFlipContents\r\nThis capability returns a hint of the technique used to do hardware page-flipping. This is important because the contents of the back buffer after a show are different depending on the technique used. The value returned can be null (if isPageFlipping returns false) or one of the following values. Any value can be specified for a buffer strategy so long as the isPageFlipping method returns true, though performance will vary depending on the available capabilities.\r\n\r\nFlipContents.COPIED\r\nThis value means that the contents of the back buffer are copied to the primary surface. A \"flip\" is probably performed as a hardware blt, which means that hardware double-buffering is probably done using blitting instead of true page-flipping. This should (in theory) be faster, or at least as fast, as blitting from a VolatileImage to the primary surface, though your mileage may vary. The contents of the back buffer are the same as the primary surface after a flip.\r\n\r\nFlipContents.BACKGROUND\r\nThis value means that the contents of the back buffer have been cleared with the background color. Either a true page-flip or a blt has occurred.\r\n\r\nFlipContents.PRIOR\r\nThis value means that the contents of the back buffer are now the contents of the old primary surface, and vice versa. Generally this value indicates that true page-flipping occurs, though this is not guaranteed and, once again, your mileage on this operation may vary.\r\n\r\nFlipContents.UNKNOWN\r\nThis value means that the contents of the back buffer are undefined after a flip. You may have to experiment to find which technique works best for you (or you may not care), and you will definitely have to set up the contents of the back buffer yourself each time you draw.\r\n\r\n\r\nTo create a buffer strategy for a component, call the createBufferStrategy method, supplying the number of buffers desired (this number includes the primary surface).Â  If any particular buffering technique is desired, supply an appropriate BufferCapabilities object. Note that when you use this version of the method, you must catch an AWTException in the event that your choice is not available. Also note that these methods are only available on Canvas and Window.\r\nOnce a particular buffer strategy has been created for a component, you can manipulate it using the getBufferStrategy method. Note that this method is also only available for canvases and windows.\r\nProgramming Tips\r\nSome tips about using buffer capabilities and buffer strategies:\r\n\r\nGetting, using, and disposing a graphics object are more robust in a try...finally clause:\r\n\r\nBufferStrategy myStrategy;\r\n\r\nwhile (!done) {\r\n    Graphics g;\r\n    try {\r\n        g = myStrategy.getDrawGraphics();\r\n        render(g);\r\n    } finally {\r\n        g.dispose();\r\n    }\r\n    myStrategy.show();\r\n}\r\n\r\n\r\nCheck the available capabilities before using a buffer strategy.\r\nFor best results, create your buffer strategy on a full-screen exclusive window. Make sure you check the isFullScreenRequired and isPageFlipping capabilities before using page-flipping.\r\nDon't make any assumptions about performance. Tweak your code as necessary, but remember that different operating systems and graphics cards have different capabilities. Profile your application!\r\nYou may want to subclass your component to override the createBufferStrategy method. Use an algorithm for choosing a strategy that is best suited to your application. The FlipBufferStrategy andÂ  BltBufferStrategy inner classes are protected and can be subclassed.\r\nDon't forget that you may lose your drawing surfaces!Â  Be sure to check contentsLost and contentsRestored before drawing. All buffers that have been lost have to be redrawn when they are restored.\r\nIf you use a buffer strategy for double-buffering in a Swing application, you probably want to turn off double-buffering for your Swing components, since they will already be double-buffered. Video memory is somewhat valuable and should only be used whenever absolutely necessary.\r\nIt may be end up being wasteful to use more than one back buffer. Multi-buffering is only useful when the drawing time exceeds the time spent to do a show. Profile your application!\r\n\r\n",
        "title": "Oracle_BufferStrategy and BufferCapabilities.txt",
        "type": "Oracle_"
    }, {
        "rank": 10,
        "text": "\r\nThe example featured in this section consists of two applications: a client and a server. The server continuously receives datagram packets over a datagram socket. Each datagram packet received by the server indicates a client request for a quotation. When the server receives a datagram, it replies by sending a datagram packet that contains a one-line \"quote of the moment\" back to the client.\r\nThe client application in this example is fairly simple. It sends a single datagram packet to the server indicating that the client would like to receive a quote of the moment. The client then waits for the server to send a datagram packet in response.\r\nTwo classes implement the server application: QuoteServer and QuoteServerThread. A single class implements the client application: QuoteClient.\r\nLet's investigate these classes, starting with the class that contains the main method for the server application. \r\n\r\nWorking With a Server-Side Application \r\n contains an applet version of the QuoteClient class.\r\nThe QuoteServer Class\r\nThe \r\nQuoteServer class, shown here in its entirety, contains a single method: the main method for the quote server application. The main method simply creates a new QuoteServerThread object and starts it:\r\n\r\nimport java.io.*;\r\n\r\npublic class QuoteServer {\r\n    public static void main(String[] args) throws IOException {\r\n        new QuoteServerThread().start();\r\n    }\r\n}\r\n\r\nThe QuoteServerThread class implements the main logic of the quote server.\r\nThe QuoteServerThread Class\r\nWhen created, the \r\nQuoteServerThread creates a DatagramSocket on port 4445 (arbitrarily chosen). This is the DatagramSocket through which the server communicates with all of its clients.\r\n\r\npublic QuoteServerThread() throws IOException {\r\n    this(\"QuoteServer\");\r\n}\r\n\r\npublic QuoteServerThread(String name) throws IOException {\r\n    super(name);\r\n    socket = new DatagramSocket(4445);\r\n\r\n    try {\r\n        in = new BufferedReader(new FileReader(\"one-liners.txt\"));\r\n    }   \r\n    catch (FileNotFoundException e){\r\n        System.err.println(\"Couldn't open quote file.  Serving time instead.\");\r\n    }\r\n}  \r\n\r\nRemember that certain ports are dedicated to well-known services and you cannot use them. If you specify a port that is in use, the creation of the DatagramSocket will fail.\r\nThe constructor also opens a BufferedReader on a file named \r\none-liners.txt\r\nwhich contains a list of quotes. Each quote in the file is on a line by itself.\r\nNow for the interesting part of the QuoteServerThread: its run method. The run method overrides run in the Thread class and provides the implementation for the thread. For information about threads, see \r\nDefining and Starting a Thread.\r\nThe run method contains a while loop that continues as long as there are more quotes in the file. During each iteration of the loop, the thread waits for a DatagramPacket to arrive over the DatagramSocket. The packet indicates a request from a client. In response to the client's request, the QuoteServerThread gets a quote from the file, puts it in a DatagramPacket and sends it over the DatagramSocket to the client that asked for it.\r\nLet's look first at the section that receives the requests from clients:\r\n\r\nbyte[] buf = new byte[256];\r\nDatagramPacket packet = new DatagramPacket(buf, buf.length);\r\nsocket.receive(packet);\r\n\r\nThe first statement creates an array of bytes which is then used to create a DatagramPacket. The DatagramPacket will be used to receive a datagram from the socket because of the constructor used to create it. This constructor requires only two arguments: a byte array that contains client-specific data and the length of the byte array. When constructing a DatagramPacket to send over the DatagramSocket, you also must supply the Internet address and port number of the packet's destination. You'll see this later when we discuss how the server responds to a client request.\r\nThe last statement in the previous code snippet receives a datagram from the socket (the information received from the client gets copied into the packet). The receive method waits forever until a packet is received. If no packet is received, the server makes no further progress and just waits.\r\nNow assume that, the server has received a request from a client for a quote. Now the server must respond. This section of code in the run method constructs the response:\r\n\r\nString dString = null;\r\nif (in == null)\r\n    dString = new Date().toString();\r\nelse\r\n    dString = getNextQuote();\r\nbuf = dString.getBytes();\r\n\r\nIf the quote file did not get opened for some reason, then in equals null. If this is the case, the quote server serves up the time of day instead. Otherwise, the quote server gets the next quote from the already opened file. Finally, the code converts the string to an array of bytes.\r\nNow, the run method sends the response to the client over the DatagramSocket with this code:\r\n\r\nInetAddress address = packet.getAddress();\r\nint port = packet.getPort();\r\npacket = new DatagramPacket(buf, buf.length, address, port);\r\nsocket.send(packet);\r\n\r\nThe first two statements in this code segment get the Internet address and the port number, respectively, from the datagram packet received from the client. The Internet address and port number indicate where the datagram packet came from. This is where the server must send its response. In this example, the byte array of the datagram packet contains no relevant information. The arrival of the packet itself indicates a request from a client that can be found at the Internet address and port number indicated in the datagram packet.\r\nThe third statement creates a new DatagramPacket object intended for sending a datagram message over the datagram socket. You can tell that the new DatagramPacket is intended to send data over the socket because of the constructor used to create it. This constructor requires four arguments. The first two arguments are the same required by the constructor used to create receiving datagrams: a byte array containing the message from the sender to the receiver and the length of this array. The next two arguments are different: an Internet address and a port number. These two arguments are the complete address of the destination of the datagram packet and must be supplied by the sender of the datagram. The last line of code sends the DatagramPacket on its way.\r\nWhen the server has read all the quotes from the quote file, the while loop terminates and the run method cleans up:\r\n\r\nsocket.close();\r\n\r\nThe QuoteClient Class\r\nThe \r\nQuoteClient class implements a client application for the QuoteServer. This application sends a request to the QuoteServer, waits for the response, and, when the response is received, displays it to the standard output. Let's look at the code in detail.\r\nThe QuoteClient class contains one method, the main method for the client application. The top of the main method declares several local variables for its use:\r\n\r\nint port;\r\nInetAddress address;\r\nDatagramSocket socket = null;\r\nDatagramPacket packet;\r\nbyte[] sendBuf = new byte[256];\r\n\r\nFirst, the main method processes the command-line arguments used to invoke the QuoteClient application:\r\n\r\nif (args.length != 1) {\r\n    System.out.println(\"Usage: java QuoteClient <hostname>\");\r\n    return;\r\n}\r\n\r\nThe QuoteClient application requires one command-line arguments: the name of the machine on which the QuoteServer is running.\r\nNext, the main method creates a DatagramSocket:\r\n\r\nDatagramSocket socket = new DatagramSocket();\r\n\r\nThe client uses a constructor that does not require a port number. This constructor just binds the DatagramSocket to any available local port. It doesn't matter what port the client is bound to because the DatagramPackets contain the addressing information. The server gets the port number from the DatagramPackets and send its response to that port.\r\nNext, the QuoteClient program sends a request to the server:\r\n\r\nbyte[] buf = new byte[256];\r\nInetAddress address = InetAddress.getByName(args[0]);\r\nDatagramPacket packet = new DatagramPacket(buf, buf.length, \r\n                                address, 4445);\r\nsocket.send(packet);\r\n\r\nThe code segment gets the Internet address for the host named on the command line (presumably the name of the machine on which the server is running). This InetAddress and the port number 4445 (the port number that the server used to create its DatagramSocket) are then used to create DatagramPacket destined for that Internet address and port number. Therefore the DatagramPacket will be delivered to the quote server.\r\nNote that the code creates a DatagramPacket with an empty byte array. The byte array is empty because this datagram packet is simply a request to the server for information. All the server needs to know to send a response--the address and port number to which reply--is automatically part of the packet.\r\nNext, the client gets a response from the server and displays it:\r\n\r\npacket = new DatagramPacket(buf, buf.length);\r\nsocket.receive(packet);\r\nString received = new String(packet.getData(), 0, packet.getLength());\r\nSystem.out.println(\"Quote of the Moment: \" + received);\r\n\r\nTo get a response from the server, the client creates a \"receive\" packet and uses the DatagramSocket receive method to receive the reply from the server. The receive method waits until a datagram packet destined for the client comes through the socket. Note that if the server's reply is somehow lost, the client will wait forever because of the no-guarantee policy of the datagram model. Normally, a client sets a timer so that it doesn't wait forever for a reply; if no reply arrives, the timer goes off and the client retransmits.\r\nWhen the client receives a reply from the server, the client uses the getData method to retrieve that data from the packet. The client then converts the data to a string and displays it.\r\nRunning the Server and Client\r\nAfter you've successfully compiled the server and the client programs, you run them. You have to run the server program first. Just use the Java interpreter and specify the QuoteServer class name.\r\nOnce the server has started, you can run the client program. Remember to run the client program with one command-line argument: the name of the host on which the QuoteServer is running.\r\nAfter the client sends a request and receives a response from the server, you should see output similar to this:\r\n\r\nQuote of the Moment:\r\nGood programming is 99% sweat and 1% coffee.\r\n\r\n",
        "title": "Oracle_Writing a Datagram Client and Server.txt",
        "type": "Oracle_"
    }]
}

post10_rec = {
    "response": [{
        "rank": 1,
        "text": "\r\nA bean has the property of persistence when its properties, fields, and state information are saved to and retrieved from storage. Component models provide a mechanism for persistence that enables the state of components to be stored in a non-volatile place for later retrieval.\r\nThe mechanism that makes persistence possible is called serialization. Object serialization means converting an object into a data stream and writing it to storage. Any applet, application, or tool that uses that bean can then \"reconstitute\" it by deserialization. The object is then restored to its original state.\r\nFor example, a Java application can serialize a Frame window on a Microsoft Windows machine, the serialized file can be sent with e-mail to a Solaris machine, and then a Java application can restore the Frame window to the exact state which existed on the Microsoft Windows machine.\r\nAny applet, application, or tool that uses that bean can then \"reconstitute\" it by deserialization.\r\nAll beans must persist. To persist, your beans must support serialization by implementing either the \r\njava.io.Serializable (in the API reference documentation) interface, or the \r\njava.io.Externalizable (in the API reference documentation) interface. These interfaces offer you the choices of automatic serialization and customized serialization. If any class in a class's inheritance hierarchy implements Serializable or Externalizable, then that class is serializable.\r\nClasses That Are Serializable\r\nAny class is serializable as long as that class or a parent class implements the java.io.Serializable interface. Examples of serializable classes include Component, String, Date, Vector, and Hashtable. Thus, any subclass of the Component class, including Applet, can be serialized. Notable classes not supporting serialization include Image, Thread, Socket, and InputStream. Attempting to serialize objects of these types will result in an NotSerializableException.\r\nThe Java Object Serialization API automatically serializes most fields of a Serializable object to the storage stream. This includes primitive types, arrays,and strings. The API does not serialize or deserialize fields that are marked transient or static.\r\nControlling Serialization\r\nYou can control the level of serialization that your beans undergo. Three ways to control serilization are:\r\n\r\nAutomatic serialization, implemented by the Serializable interface. The Java serialization software serializes the entire object, except transient and static fields.\r\nCustomized serialization. Selectively exclude fields you do not want serialized by marking with the transient (or static) modifier.\r\nCustomized file format, implemented by the Externalizable interface and its two methods. Beans are written in a specific file format.\r\n\r\nDefault Serialization: The Serializable Interface\r\nThe Serializable interface provides automatic serialization by using the Java Object Serialization tools. Serializable declares no methods; it acts as a marker, telling the Object Serialization tools that your bean class is serializable. Marking your class Serializable means you are telling the Java Virtual Machine (JVM) that you have made sure your class will work with default serialization. Here are some important points about working with the Serializable interface:\r\n\r\nClasses that implement Serializable must have an access to a no-argument constructor of supertype. This constructor will be called when an object is \"reconstituted\" from a .ser file.\r\nYou don't need to implement Serializable in your class if it is already implemented in a superclass.\r\nAll fields except static and transient fields are serialized. Use the transient modifier to specify fields you do not want serialized, and to specify classes that are not serializable.\r\n\r\nSelective Serialization Using the transient Keyword\r\nTo exclude fields from serialization in a Serializable object mark the fields with the transient modifier.\r\n\r\ntransient int status;\r\n\r\nDefault serialization will not serialize transient and static fields.\r\nSelective Serialization: writeObject and readObject\r\nIf your serializable class contains either of the following two methods (the signatures must be exact), then the default serialization will not take place.\r\n\r\nprivate void writeObject(java.io.ObjectOutputStream out)\r\n    throws IOException;\r\nprivate void readObject(java.io.ObjectInputStream in)\r\n    throws IOException, ClassNotFoundException;\r\n\r\nYou can control how more complex objects are serialized, by writing your own implementations of the writeObject and readObject methods. Implement writeObject when you need to exercise greater control over what gets serialized when you need to serialize objects that default serialization cannot handle, or when you need to add data to the serialization stream that is not an object data member. Implement readObject to reconstruct the data stream you wrote with writeObject.\r\nThe Externalizable Interface\r\nUse the Externalizable interface when you need complete control over your bean's serialization (for example, when writing and reading a specific file format). To use the Externalizable interface you need to implement two methods: readExternal and writeExternal. Classes that implement Externalizable must have a no-argument constructor.\r\n",
        "title": "Oracle_Bean Persistence.txt",
        "type": "Oracle_"
    }, {
        "rank": 2,
        "text": "\r\nTo serialize an object means to convert its state to a byte stream so that the byte stream can be reverted back into a copy of the object. A Java object is serializable if its class or any of its superclasses implements either the java.io.Serializable interface or its subinterface, java.io.Externalizable. Deserialization is the process of converting the serialized form of an object back into a copy of the object.\r\nFor example, the java.awt.Button class implements the Serializable interface, so you can serialize a java.awt.Button object and store that serialized state in a file. Later, you can read back the serialized state and deserialize into a java.awt.Button object.\r\nThe Java platform specifies a default way by which serializable objects are serialized. A (Java) class can override this default serialization and define its own way of serializing objects of that class. The \r\nObject Serialization Specification describes object serialization in detail.\r\nWhen an object is serialized, information that identifies its class is recorded in the serialized stream. However, the class's definition (\"class file\") itself is not recorded. It is the responsibility of the system that is deserializing the object to determine how to locate and load the necessary class files. For example, a Java application might include in its classpath a JAR file that contains the class files of the serialized object(s) or load the class definitions by using information stored in the directory, as explained later in this lesson. \r\nBinding a Serializable Object\r\nYou can store a serializable object in the directory if the underlying service provider supports that action, as does Oracle's LDAP service provider.\r\nThe following example invokes \r\nContext.bind to bind an AWT button to the name \"cn=Button\". To associate attributes with the new binding, you use \r\nDirContext.bind. To overwrite an existing binding, use \r\nContext.rebind and \r\nDirContext.rebind.\r\n\r\n// Create the object to be bound\r\nButton b = new Button(\"Push me\");\r\n\r\n// Perform the bind\r\nctx.bind(\"cn=Button\", b);\r\n\r\nYou can then read the object back using \r\nContext.lookup, as follows.\r\n\r\n// Check that it is bound\r\nButton b2 = (Button)ctx.lookup(\"cn=Button\");\r\nSystem.out.println(b2);\r\n\r\nRunning \r\nthis example produces the following output.\r\n\r\n# java SerObj\r\njava.awt.Button[button0,0,0,0x0,invalid,label=Push me]\r\n\r\n\r\nSpecifying a Codebase\r\n\r\nNote: The procedures described here are for binding a serializable object in a directory service that follows the schema defined in \r\nRFC 2713. These procedures might not be generally applicable to other naming and directory services that support binding a serializable object with a specified codebase.\r\n\r\nWhen a serialized object is bound in the directory as shown in the previous example, applications that read the serialized object from the directory must have access to the class definitions necessary to deserialize the object.\r\nAlternatively, you can record a codebase with the serialized object in the directory, either when you bind the object or subsequently by adding an attribute by using \r\nDirContext.modifyAttributes. You can use any attribute to record this codebase and have your application read that attribute from the directory and use it appropriately. Or you can use the \"javaCodebase\" attribute specified in . In the latter case, Oracle's LDAP service provider will automatically use the attribute to load the class definitions as needed. \"javaCodebase\" should contain the URL of a codebase directory or a JAR file. If the codebase contains more than one URL, then each URL must be separated by a space character.\r\nThe following example resembles the one for binding a java.awt.Button. It differs in that it uses a user-defined Serializable class, \r\nFlower, and supplies a \"javaCodebase\" attribute that contains the location of Flower's class definition. Here's the code that does the binding.\r\n\r\nString codebase = ...;\r\n\r\n// Create the object to be bound\r\nFlower f = new Flower(\"rose\", \"pink\");\r\n\r\n// Perform the bind and specify the codebase\r\nctx.bind(\"cn=Flower\", f, new BasicAttributes(\"javaCodebase\", codebase));\r\n\r\nWhen you run \r\nthis example, you must supply the URL of the location at which the class file Flower.class was installed. For example, if Flower.class was installed at the Web server web1, in the directory example/classes, then you would run this example as follows.\r\n\r\n# java SerObjWithCodebase http://web1/example/classes/\r\npink rose\r\n\r\nAfterward, you may remove Flower.class from your classpath and run any program that looks up or lists this object without directly referencing the Flower class. If your program references Flower directly, then you must make its class file available for compilation and execution.\r\n",
        "title": "Oracle_Serializable Objects.txt",
        "type": "Oracle_"
    }, {
        "rank": 3,
        "text": "\r\n\r\nThe \r\nDataFlavor class allows you to specify the content type of your data. You need to specify a DataFlavor when fetching the data from the importData method. Several flavor types are predefined for you:\r\n\r\n\r\nimageFlavor represents data in the java.awt.Image format. This is used when dragging image data.\r\n\r\nstringFlavor represents data in the most basic form of text â\u20ac\u201d java.lang.String. This is the most commonly used data flavor for most applications.\r\n\r\njavaFileListFlavor represents java.io.File objects in a java.util.List format. This is useful for applications that drag files, such as the TopLevelTransferHandler example, discussed in the \r\nTop-Level Drop lesson.\r\n\r\nFor most applications, this is all you need to know about data flavors. However, if you require a flavor other than these predefined types, you can create your own. If you create a custom component and want it to participate in data transfer, you will need to create a custom data flavor. The constructor for specifying a data flavor is \r\nDataFlavor(Class, String). For example, to create a data flavor for the java.util.ArrayList class:\r\n\r\nnew DataFlavor(ArrayList.class, \"ArrayList\");\r\n\r\nTo create a data flavor for an integer array:\r\n\r\nnew DataFlavor(int[].class, \"Integer Array\");\r\n\r\nTransferring the data using this mechanism uses Object serialization, so the class you use to transfer the data must implement the Serializable interface, as must anything that is serialized with it. If everything is not serializable, you will see a NotSerializableException during drop or copy to the clipboard.\r\nCreating a data flavor using the DataFlavor(Class, String) constructor allows you to transfer data between applications, including native applications. If you want to create a data flavor that transfers data only within an application, use \r\njavaJVMLocalObjectMimeType and the \r\nDataFlavor(String) constructor. For example, to specify a data flavor that transfers color from a JColorChooser only within your application, you could use this code:\r\n\r\nString colorType = DataFlavor.javaJVMLocalObjectMimeType +\r\n                   \";class=java.awt.Color\";\r\nDataFlavor colorFlavor = new DataFlavor(colorType);\r\n\r\nTo create a data flavor for an ArrayList that would work only within your application:\r\n\r\nnew DataFlavor(DataFlavor.javaJVMLocalObjectMimeType +\r\n               \";class=java.util.ArrayList\");\r\n\r\nTo create a data flavor for an integer array:\r\n\r\nnew DataFlavor(DataFlavor.javaJVMLocalObjectMimeType +\r\n               \";class=\\\"\" + int[].class.getName() + \"\\\"\");\r\n\r\nA MIME type containing special characters, such as [ or ;, must have those characters enclosed in quotes.\r\nA Transferable can be implemented to support multiple flavors. For example, you can use both local and serialization flavors together, or you can use two forms of the same data, such as the ArrayList and integer array flavors, together, or you can create a TransferHandler that accepts different types of data, such as color and text.\r\nWhen you create an array of DataFlavors to be returned from the Transferable's \r\ngetTransferDataFlavors method, the flavors should be inserted in preferred order, with the most preferred appearing at element 0 of the array. Genereally the preferred order is from the richest, or most complex, form of the data down to the simpleset â\u20ac\u201d the form most likely to be understood by other objects.\r\n",
        "title": "Oracle_Using and Creating a DataFlavor.txt",
        "type": "Oracle_"
    }, {
        "rank": 4,
        "text": "\r\nWhen an object is sent through a network, the object needs to bere-createdat the receiving host.\r\n\r\nObject SerializationThe termObject Serializationrefers to the act of converting the object to a byte stream. The byte stream can be stored on the file system or can be sent through a network.At a later time the object can be re-created from that stream of bytes. The only requirement is that the same class has to be available both times, when the object is serialized and also when the object is re-created. If that happens on different servers, then the same class must be available on both servers.  Same class means that exactly the same version of the class must be available, otherwise the object won't be able to be re-created. This is a maintenance problem for those applications where java serialization is used to make objects persistent or to sent the object through the network.When a class is modified, there could be a problem re-creating those objects that were serialized using an earlier version of the class.\r\n\r\nJava has built-in support for serialization, using theSerializableinterface; however, a class must first implement theSerializableinterface.\r\nBy default, a class will have all of its fields serialized when converted into a data stream (withtransientfields being skipped).  If additional handling is required beyond the default of writing all fields, you need to provide an implementation for the following three methods:\r\n\r\nprivate void writeObject(java.io.ObjectOutputStream out) throws IOException;\r\n\r\nprivate void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;\r\n\r\nprivate void readObjectNoData() throws ObjectStreamException;\r\n\r\nIf the object needs to write or provide a replacement object during serialization, it needs to implement the following two methods, with any access specifier:\r\n\r\nObject writeReplace() throws ObjectStreamException;\r\n\r\nObject readResolve() throws ObjectStreamException;\r\n\r\nNormally, a minor change to the class can cause the serialization to fail.  You can still allow the class to be loaded by defining the serialization version id:\r\n\r\n\r\n",
        "title": "Object Lifecycle_Re-creating an object received from a remote source_text.txt",
        "type": "text"
    }, {
        "rank": 5,
        "text": "\r\nThe requirements for an object to be a bean is to define a public parameterless constructor, so that beans can be instantiated by builder tools in an uncomplicated way (In the Point bean, the parameterless constructor is given implicitly). Secondly, one of the interfacesjava.io.Serializableorjava.io.Externalizableneed to be implemented. The interfaces do not prescribe the implementation of any methods, but are an approval, that the bean may be saved in persistent storage as in a file or database. In doing so, the bean can be restored after an application was shut down or transferred across networks. The ability to store state of a component in persistent storage is calledpersistence. Java offers a standard serialization mechanism, which makes it very easy to serialize objects. Alternatively, a component can be stored in a customized manner (e.g. in xml format) by implementing theExternalizableinterface.\r\n\r\n",
        "title": "JavaBeans_Persistence_text.txt",
        "type": "text"
    }, {
        "rank": 6,
        "text": "\r\nThe Java programming language allows you to define a class within another class. Such a class is called a nested class and is illustrated here:\r\n\r\nclass OuterClass {\r\n    ...\r\n    class NestedClass {\r\n        ...\r\n    }\r\n}\r\n\r\nTerminology:Â Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are called static nested classes. Non-static nested classes are called inner classes.\r\n\r\n\r\nclass OuterClass {\r\n    ...\r\n    static class StaticNestedClass {\r\n        ...\r\n    }\r\n    class InnerClass {\r\n        ...\r\n    }\r\n}\r\n\r\nA nested class is a member of its enclosing class. Non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private. Static nested classes do not have access to other members of the enclosing class. As a member of the OuterClass, a nested class can be declared private, public, protected, or package private. (Recall that outer classes can only be declared public or package private.)\r\nWhy Use Nested Classes?\r\nCompelling reasons for using nested classes include the following:\r\n\r\nIt is a way of logically grouping classes that are only used in one place: If a class is useful to only one other class, then it is logical to embed it in that class and keep the two together. Nesting such \"helper classes\" makes their package more streamlined.\r\nIt increases encapsulation: Consider two top-level classes, A and B, where B needs access to members of A that would otherwise be declared private. By hiding class B within class A, A's members can be declared private and B can access them. In addition, B itself can be hidden from the outside world.\r\nIt can lead to more readable and maintainable code: Nesting small classes within top-level classes places the code closer to where it is used.\r\n\r\nStatic Nested Classes\r\nAs with class methods and variables, a static nested class is associated with its outer class. And like static class methods, a static nested class cannot refer directly to instance variables or methods defined in its enclosing class: it can use them only through an object reference.\r\nNote:Â A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience.\r\n\r\nStatic nested classes are accessed using the enclosing class name:\r\n\r\nOuterClass.StaticNestedClass\r\n\r\nFor example, to create an object for the static nested class, use this syntax:\r\n\r\nOuterClass.StaticNestedClass nestedObject =\r\n     new OuterClass.StaticNestedClass();\r\n\r\nInner Classes\r\nAs with instance methods and variables, an inner class is associated with an instance of its enclosing class and has direct access to that object's methods and fields. Also, because an inner class is associated with an instance, it cannot define any static members itself.\r\nObjects that are instances of an inner class exist within an instance of the outer class. Consider the following classes:\r\n\r\nclass OuterClass {\r\n    ...\r\n    class InnerClass {\r\n        ...\r\n    }\r\n}\r\n\r\n\r\nAn instance of InnerClass can exist only within an instance of OuterClass and has direct access to the methods and fields of its enclosing instance.\r\nTo instantiate an inner class, you must first instantiate the outer class. Then, create the inner object within the outer object with this syntax:\r\n\r\nOuterClass.InnerClass innerObject = outerObject.new InnerClass();\r\n\r\nThere are two special kinds of inner classes:\r\nlocal classes and\r\nanonymous classes.\r\n\r\nShadowing\r\nIf a declaration of a type (such as a member variable or a parameter name) in a particular scope (such as an inner class or a method definition) has the same name as another declaration in the enclosing scope, then the declaration shadows the declaration of the enclosing scope. You cannot refer to a shadowed declaration by its name alone. The following example,\r\nShadowTest, demonstrates this:\r\n\r\n \r\npublic class ShadowTest {\r\n\r\n    public int x = 0;\r\n\r\n    class FirstLevel {\r\n\r\n        public int x = 1;\r\n\r\n        void methodInFirstLevel(int x) {\r\n            System.out.println(\"x = \" + x);\r\n            System.out.println(\"this.x = \" + this.x);\r\n            System.out.println(\"ShadowTest.this.x = \" + ShadowTest.this.x);\r\n        }\r\n    }\r\n\r\n    public static void main(String... args) {\r\n        ShadowTest st = new ShadowTest();\r\n        ShadowTest.FirstLevel fl = st.new FirstLevel();\r\n        fl.methodInFirstLevel(23);\r\n    }\r\n}\r\n\r\nThe following is the output of this example:\r\nx = 23\r\nthis.x = 1\r\nShadowTest.this.x = 0\r\nThis example defines three variables named x: the member variable of the class ShadowTest, the member variable of the inner class FirstLevel, and the parameter in the method methodInFirstLevel. The variable x defined as a parameter of the method methodInFirstLevel shadows the variable of the inner class FirstLevel. Consequently, when you use the variable x in the method methodInFirstLevel, it refers to the method parameter. To refer to the member variable of the inner class FirstLevel, use the keyword this to represent the enclosing scope:\r\nSystem.out.println(\"this.x = \" + this.x);\r\nRefer to member variables that enclose larger scopes by the class name to which they belong. For example, the following statement accesses the member variable of the class ShadowTest from the method methodInFirstLevel:\r\nSystem.out.println(\"ShadowTest.this.x = \" + ShadowTest.this.x);\r\nSerialization\r\n\r\nSerialization of inner classes, including\r\nlocal and\r\nanonymous classes, is strongly discouraged. When the Java compiler compiles certain constructs, such as inner classes, it creates synthetic constructs; these are classes, methods, fields, and other constructs that do not have a corresponding construct in the source code. Synthetic constructs enable Java compilers to implement new Java language features without changes to the JVM. However, synthetic constructs can vary among different Java compiler implementations, which means that .class files can vary among different implementations as well. Consequently, you may have compatibility issues if you serialize an inner class and then deserialize it with a different JRE implementation. See the section\r\nImplicit and Synthetic Parameters in the section\r\nObtaining Names of Method Parameters for more information about the synthetic constructs generated when an inner class is compiled.\r\n",
        "title": "Oracle_Nested Classes.txt",
        "type": "Oracle_"
    }, {
        "rank": 7,
        "text": "\r\n\r\nThis page maps sections in the Java Tutorials to topics covered in the Java SE 8 Programmer I exam. This exam is associated with the Oracle Certified Associate, Java SE 8 Programmer certificate.  The topics covered in this exam are:\r\n\r\nJava Basics\r\nWorking with Java Data Types\r\nUsing Operators and Decision Constructs\r\nCreating and Using Arrays\r\nUsing Loop Constructs\r\nWorking with Methods and Encapsulation\r\nWorking with Inheritance\r\nHandling Exceptions\r\nWorking with Selected classes from the Java API\r\n\r\nSection 1: Java Basics\r\nItem 1: Define the scope of variables.\r\n\r\n\r\nVariables\r\n\r\n\r\nItem 2: Define the structure of a Java class.\r\n\r\n\r\nA Closer Look at the \"Hello World!\" Application\r\n\r\nClasses\r\n\r\n\r\nItem 3:  Create executable Java applications with a main method; run a Java program from the command line; produce console output.\r\n\r\n\r\n\"Hello World!\" for the NetBeans IDE\r\n\r\n\"Hello World!\" for Microsoft Windows\r\n\r\n\"Hello World!\" for Solaris OS and Linux\r\n\r\nA Closer Look at the \"Hello World!\" Application\r\n\r\n\r\nItem 4: Import other Java packages to make them accessible in your code.\r\n\r\n\r\nCreating and Using Packages\r\n\r\nUsing Package Members\r\n\r\n\r\nItem 5: Compare and contrast the features and components of Java such as: platform independence, object orientation, encapsulation, etc.\r\n\r\n\r\nAbout the Java Technology\r\n\r\nObject-Oriented Programming Concepts\r\n\r\n\r\n\r\nSection 2: Working with Java Data Types\r\nItem 1: Declare and initialize variables (including casting of primitive data types).\r\n\r\n\r\nVariables\r\n\r\nInitializing Fields\r\n\r\n\r\nItem 2: Differentiate between object reference variables and primitive variables.\r\n\r\n\r\nPrimitive Data Types\r\n\r\nThe Numbers Classes\r\n\r\n\r\nItem 3: Know how to read or write to object fields.\r\n\r\n\r\nInheritance\r\n\r\nDeclaring Member Variables\r\n\r\nCreating Objects\r\n\r\nUsing Objects\r\n\r\n\r\nItem 4:  Explain an object's lifecycle (creation, \"dereference by reassignment\" and garbage collection).\r\n\r\n\r\nObjects\r\n\r\nCreating Objects\r\n\r\nUsing Objects\r\n\r\n\r\n\r\nSection 3: Using Operators and Decision Constructs\r\nItem 1: Use Java operators; use parentheses to override operator precedence.\r\n\r\n\r\nOperators\r\n\r\nAssignment, Arithmetic, and Unary Operators\r\n\r\nEquality, Relational, and Conditional Operators \r\n\r\nBitwise and Bit Shift Operators\r\n\r\nExpressions, Statements, and Blocks\r\n\r\n\r\nItem 2: Test equality between strings and other objects using == and equals().\r\n\r\n\r\nObject as a Superclass\r\n\r\n\r\nItem 3: Create and use if, if-else, and ternary constructs.\r\n\r\n\r\nThe if-then and if-then-else Statements\r\n\r\nEquality, Relational, and Conditional Operators \r\n\r\n\r\nItem 4: Use a switch statement.\r\n\r\n\r\nThe switch Statement\r\n\r\n\r\n\r\nSection 4: Creating and Using Arrays\r\nItem 1: Declare, instantiate, initialize and use a one-dimensional array.\r\n\r\n\r\nArrays\r\n\r\n\r\nItem 2: Declare, instantiate, initialize and use a multi-dimensional array.\r\n\r\n\r\nArrays\r\n\r\n\r\n\r\nSection 5: Using Loop Constructs\r\nItem 1: Create and use while loops.\r\n\r\n\r\nThe while and do-while Statements\r\n\r\n\r\nItem 2: Create and use for loops including the enhanced for loop.\r\n\r\n\r\nThe for Statement\r\n\r\n\r\nItem 3: Create and use do-while loops.\r\n\r\n\r\nThe while and do-while Statements\r\n\r\n\r\nItem 4: Compare loop constructs.\r\n\r\n\r\nSummary of Control Flow Statements\r\n\r\n\r\nItem 5: Use break and continue.\r\n\r\n\r\nBranching Statements\r\n\r\n\r\n\r\nSection 6: Working with Methods and Encapsulation\r\nItem 1: Create methods with arguments and return values, including overloaded methods.\r\n\r\n\r\nReturning a Value from a Method\r\n\r\nDefining Methods\r\n\r\n\r\nItem 2: Apply the static keyword to methods and fields.\r\n\r\n\r\nVariables\r\n\r\nUnderstanding Class Members\r\n\r\nDefault Methods\r\n\r\n\r\nItem 3: Create an overloaded method; differentiate between default and user defined constructors.\r\n\r\n\r\nDefining Methods\r\n\r\nProviding Constructors for Your Classes\r\n\r\n\r\nItem 4: Apply access modifiers.\r\n\r\n\r\nControlling Access to Members of a Class\r\n\r\n\r\nItem 5: Apply encapsulation principles to a class.\r\n\r\n\r\nInheritance\r\n\r\nInner Class Example\r\n\r\nNested Classes\r\n\r\n\r\nItem 6: Determine the effect upon object references and primitive values when they are passed into methods that change the values.\r\n\r\n\r\nPassing Information to a Method or a Constructor\r\n\r\n\r\n\r\nSection 7: Working with Inheritance\r\nItem 1: Describe inheritance and its benefits.\r\n\r\n\r\nInheritance\r\n\r\nOverriding and Hiding Methods\r\n\r\n\r\nItem 2: Develop code that makes use of polymorphism; develop code that overrides methods; differentiate between the type of a reference and the type of an object.\r\n\r\n\r\nPolymorphism\r\n\r\nCreating Objects\r\n\r\nUsing Objects\r\n\r\n\r\nItem 3: Determine when casting is necessary.\r\n\r\n\r\nInheritance\r\n\r\n\r\nItem 4: Use super and this to access objects and constructors.\r\n\r\n\r\nUsing the Keyword super\r\n\r\nUsing the this Keyword\r\n\r\n\r\nItem 5: Use abstract classes and interfaces.\r\n\r\n\r\nAbstract Methods and Classes\r\n\r\nDefining an Interface\r\n\r\nImplementing an Interface\r\n\r\n\r\n\r\nSection 8: Handling Exceptions\r\nItem 1: Differentiate among checked exceptions, RuntimeException, and Error.\r\n\r\n\r\nThe Catch or Specify Requirement\r\n\r\n\r\nItem 2: Create a try-catch block and determine how exceptions alter normal program flow.\r\n\r\n\r\nCatching and Handling Exceptions\r\n\r\nThe try Block\r\n\r\nThe catch Blocks\r\n\r\n\r\nItem 3: Describe the advantages of exception handling .\r\n\r\n\r\nWhat Is an Exception?\r\n\r\nAdvantages of Exceptions\r\n\r\n\r\nItem 4: Create and invoke a method that throws an exception.\r\n\r\n\r\nCatching Exceptions\r\n\r\n\r\nItem 5: Recognize common exception classes and categories (such as NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException, ClassCastException).\r\n\r\n\r\nSection 9: Working with Selected classes from the Java API\r\nItem 1: Manipulate data using the StringBuilder class and its methods.\r\n\r\n\r\nThe StringBuilder Class\r\n\r\nSummary of Characters and Strings\r\n\r\n\r\nItem 2: Create and manipulate strings.\r\n\r\n\r\nStrings\r\n\r\nConverting Between Numbers and Strings\r\n\r\nComparing Strings and Portions of Strings\r\n\r\nManipulating Characters in a String\r\n\r\n\r\nItem 3: Create and manipulate calendar data using classes from java.time.LocalDateTime,  java.time.LocalDate, java.time.LocalTime, java.time.format.DateTimeFormatter, java.time.Period.\r\n\r\n\r\nDate and Time Classes\r\n\r\nDate Classes\r\n\r\nParsing and Formatting\r\n\r\nPeriod and Duration\r\n\r\n\r\nItem 4: Declare and use an ArrayList of a given type.\r\n\r\n\r\nThe List Interface\r\n\r\nList Implementations\r\n\r\n\r\nItem 5: Write a simple Lambda expression that consumes a Lambda Predicate expression.\r\n\r\n\r\n\r\nLambda Expressions\r\n\r\nAggregate Operations\r\n\r\n",
        "title": "Oracle_Java SE 8 Programmer I Exam.txt",
        "type": "Oracle_"
    }, {
        "rank": 8,
        "text": "\r\nThis section discusses several design considerations to keep in mind when implementing event handlers in your application. We then introduce you to event objects small objects that describe each event. In particular, we talk about EventObject, the superclass for all AWT and Swing events. Next, we introduce the concepts of low-level events and semantic events, recommending that you prefer semantic events when possible. The remainder of this section discusses implementation techniques you might use in some event listeners or see in event listeners created by other people or by GUI builders.\r\n\r\nDesign Considerations\r\nGetting Event Information: Event Objects\r\nConcepts: Low-Level Events and Semantic Events\r\nEvent Adapters\r\nInner Classes and Anonymous Inner Classes\r\nThe EventHandler Class\r\n\r\n\r\nDesign Considerations\r\nThe most important rule to keep in mind about event listeners is that they should execute very quickly. Because all drawing and event-listening methods are executed in the same thread, a slow event-listener method can make the program seem unresponsive and slow to repaint itself. If you need to perform some lengthy operation as the result of an event, do it by starting up another thread (or somehow sending a request to another thread) to perform the operation. For help on using threads, see \r\nConcurrency in Swing.\r\nYou have many choices on how to implement an event listener. We can not recommend a specific approach because one solution would not suit all situations. However, we can give you some hints and show you some techniques that you might see, even if you do not use the same solution in your program.\r\nFor example, you might choose to implement separate classes for different kinds of event listeners. This can be an easy architecture to maintain, but many classes can also mean reduced performance.\r\nWhen designing your program, you might want to implement your event listeners in a class that is not public, but somewhere more hidden. A private implementation is a more secure implementation.\r\nIf you have a very specific kind of simple event listener, you might be able to avoid creating a class at all by using the EventHandler class. \r\nGetting Event Information: Event Objects\r\nEvery event-listener method has a single argument an object that inherits from the \r\nEventObject class. Although the argument always descends from EventObject, its type is generally specified more precisely. For example, the argument for methods that handle mouse events is an instance of MouseEvent, where MouseEvent is an indirect subclass of EventObject.\r\nThe EventObject class defines one very useful method:\r\n\r\nObject getSource()\r\nReturns the object that fired the event.\r\n\r\nNote that the getSource method returns an Object. Event classes sometimes define methods similar to getSource, but that have more restricted return types. For example, the ComponentEvent class defines a getComponent method that just like getSource returns the object that fired the event. The difference is that getComponent always returns a Component. Each how-to page for event listeners mentions whether you should use getSource or another method to get the event source.\r\nOften, an event class defines methods that return information about the event. For example, you can query a MouseEvent object for information about where the event occurred, how many clicks the user made, which modifier keys were pressed, and so on.\r\nConcepts: Low-Level Events and Semantic Events\r\nEvents can be divided into two groups: low-level events and semantic events. Low-level events represent window-system occurrences or low-level input. Everything else is a semantic event.\r\nExamples of low-level events include mouse and key events both of which result directly from user input. Examples of semantic events include action and item events. A semantic event might be triggered by user input; for example, a button customarily fires an action event when the user clicks it, and a text field fires an action event when the user presses Enter. However, some semantic events are not triggered by low-level events, at all. For example, a table-model event might be fired when a table model receives new data from a database.\r\nWhenever possible, you should listen for semantic events rather than low-level events. That way, you can make your code as robust and portable as possible. For example, listening for action events on buttons, rather than mouse events, means that the button will react appropriately when the user tries to activate the button using a keyboard alternative or a look-and-feel-specific gesture. When dealing with a compound component such as a combo box, it is imperative that you stick to semantic events, since you have no reliable way of registering listeners on all the look-and-feel-specific components that might be used to form the compound component.\r\nEvent Adapters\r\nSome listener interfaces contain more than one method. For example, the MouseListener interface contains five methods: mousePressed, mouseReleased, mouseEntered, mouseExited, and mouseClicked. Even if you care only about mouse clicks, if your class directly implements MouseListener, then you must implement all five MouseListener methods. Methods for those events you do not care about can have empty bodies. Here is an example:\r\n\r\n//An example that implements a listener interface directly.\r\npublic class MyClass implements MouseListener {\r\n    ...\r\n        someObject.addMouseListener(this);\r\n    ...\r\n    /* Empty method definition. */\r\n    public void mousePressed(MouseEvent e) {\r\n    }\r\n\r\n    /* Empty method definition. */\r\n    public void mouseReleased(MouseEvent e) {\r\n    }\r\n\r\n    /* Empty method definition. */\r\n    public void mouseEntered(MouseEvent e) {\r\n    }\r\n\r\n    /* Empty method definition. */\r\n    public void mouseExited(MouseEvent e) {\r\n    }\r\n\r\n    public void mouseClicked(MouseEvent e) {\r\n        ...//Event listener implementation goes here...\r\n    }\r\n}\r\n\r\nThe resulting collection of empty method bodies can make code harder to read and maintain. To help you avoid implementing empty method bodies, the API generally includes an adapter class for each listener interface with more than one method. (The Listener API Table lists all the listeners and their adapters.) For example, the MouseAdapter class implements the MouseListener interface. An adapter class implements empty versions of all its interface's methods.\r\nTo use an adapter, you create a subclass of it and override only the methods of interest, rather than directly implementing all methods of the listener interface. Here is an example of modifying the preceding code to extend MouseAdapter. By extending MouseAdapter, it inherits empty definitions of all five of the methods that MouseListener contains.\r\n\r\n/*\r\n * An example of extending an adapter class instead of\r\n * directly implementing a listener interface.\r\n */\r\npublic class MyClass extends MouseAdapter {\r\n    ... \r\n        someObject.addMouseListener(this);\r\n    ... \r\n    public void mouseClicked(MouseEvent e) {\r\n        ...//Event listener implementation goes here...\r\n    }\r\n}\r\n\r\nInner Classes and Anonymous Inner Classes\r\nWhat if you want to use an adapter class, but do not want your public class to inherit from an adapter class? For example, suppose you write an applet, and you want your Applet subclass to contain some code to handle mouse events. Since the Java language does not permit multiple inheritance, your class cannot extend both the Applet and MouseAdapter classes. A solution is to define an inner class a class inside of your Applet subclass that extends the MouseAdapter class.\r\nInner classes can also be useful for event listeners that implement one or more interfaces directly.\r\n\r\n//An example of using an inner class.\r\npublic class MyClass extends Applet {\r\n    ...\r\n        someObject.addMouseListener(new MyAdapter());\r\n    ...\r\n    class MyAdapter extends MouseAdapter {\r\n        public void mouseClicked(MouseEvent e) {\r\n            ...//Event listener implementation goes here...\r\n        }\r\n    }\r\n}\r\n\r\nPerformance note:Â When considering whether to use an inner class, keep in mind that application startup time and memory footprint are typically directly proportional to the number of classes you load. The more classes you create, the longer your program takes to start up and the more memory it will take. As an application developer you have to balance this with other design constraints you may have. We are not suggesting you turn your application into a single monolithic class in hopes of cutting down startup time and memory footprint this would lead to unnecessary headaches and maintenance burdens.\r\n\r\nYou can create an inner class without specifying a name this is known as an anonymous inner class. While it might look strange at first glance, anonymous inner classes can make your code easier to read because the class is defined where it is referenced. However, you need to weigh the convenience against possible performance implications of increasing the number of classes.\r\nHere is an example of using an anonymous inner class:\r\n\r\n//An example of using an anonymous inner class.\r\npublic class MyClass extends Applet {\r\n    ...\r\n        someObject.addMouseListener(new MouseAdapter() {\r\n            public void mouseClicked(MouseEvent e) {\r\n                ...//Event listener implementation goes here...\r\n            }\r\n        });\r\n    ...\r\n    }\r\n}\r\n\r\nNote:Â One drawback of anonymous inner classes is that they can not be seen by the long-term persistence mechanism. For more information see the API documentation for the \r\nJavaBeansâ\u201e¢ package and the \r\nBean Persistence lesson in the \r\nJavaBeans trail.\r\n\r\nInner classes work even if your event listener needs access to private instance variables from the enclosing class. As long as you do not declare an inner class to be static, an inner class can refer to instance variables and methods just as if its code is in the containing class. To make a local variable available to an inner class, just save a copy of the variable as a final local variable.\r\nTo refer to the enclosing instance, you can use EnclosingClass.this. For more information about inner classes, see \r\nNested Classes.\r\nThe EventHandler Class\r\nAn \r\nEventHandler class supports dynamic generation of simple, one-statement event listeners. Although EventHandler is only useful for a certain type of extremely simple event listeners, it is worth mentioning for two reasons. It is useful for:\r\n\r\nMaking an event listener that persistence can see and yet does not clog up your own classes with event listener interfaces and methods.\r\nNot adding to the number of classes defined in an application this can help performance.\r\n\r\nCreating an EventHandler by hand is difficult. An EventHandler must be carefully constructed. If you make a mistake, you would not be notified at compile time it will throw an obscure exception at runtime. For this reason, EventHandlers are best created by a GUI builder. EventHandlers should be carefully documented. Otherwise you run the risk of producing hard-to-read code.\r\nThe EventHandler class is intended to be used by interactive tools, such as application builders, that allow developers to make connections between beans. Typically connections are made from a user interface bean (the event source) to an application logic bean (the target). The most effective connections of this kind isolate the application logic from the user interface. For example, the EventHandler for a connection from a JCheckBox to a method that accepts a boolean value can deal with extracting the state of the check box and passing it directly to the method so that the method is isolated from the user interface layer.\r\nInner classes are another, more general way to handle events from user interfaces. The EventHandler class handles only a subset of what is possible using inner classes. However, EventHandler works better with the long-term persistence scheme than inner classes. Also, using EventHandler in large applications in which the same interface is implemented many times can reduce the disk and memory footprint of the application.\r\nExamples of Using EventHandler The simplest use of EventHandler is to install a listener that calls a method on the target object with no arguments. In the following example we create an ActionListener that invokes the toFront method on an instance of javax.swing.JFrame.\r\n\r\n    myButton.addActionListener(\r\n        (ActionListener)EventHandler.create(ActionListener.class, frame, \"toFront\"));\r\n\r\nWhen myButton is pressed, the statement frame.toFront() will be executed. One could get the same effect, with some additional compile-time type safety, by defining a new implementation of the ActionListener interface and adding an instance of it to the button:\r\n\r\n    //Equivalent code using an inner class instead of EventHandler.\r\n    myButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            frame.toFront();\r\n        }\r\n    });\r\n\r\nThe next simplest use of EventHandler is to extract a property value from the first argument of the method in the listener interface (typically an event object) and use it to set the value of a property in the target object. In the following example we create an ActionListener that sets the nextFocusableComponent property of the target (myButton) object to the value of the \"source\" property of the event.\r\n\r\n    EventHandler.create(ActionListener.class, myButton, \"nextFocusableComponent\", \"source\")\r\n\r\nThis would correspond to the following inner class implementation:\r\n\r\n    //Equivalent code using an inner class instead of EventHandler.\r\n    new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            myButton.setNextFocusableComponent((Component)e.getSource()); \r\n        }\r\n    }\r\n\r\nIt is also possible to create an EventHandler that just passes the incoming event object to the target's action. If the fourth EventHandler.create argument is an empty string, then the event is just passed along:\r\n\r\n    EventHandler.create(ActionListener.class, target, \"doActionEvent\", \"\")\r\n\r\nThis would correspond to the following inner class implementation:\r\n\r\n    //Equivalent code using an inner class instead of EventHandler.\r\n    new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            target.doActionEvent(e);\r\n        }\r\n    }\r\n\r\nProbably the most common use of EventHandler is to extract a property value from the source of the event object and set this value as the value of a property of the target object. In the following example we create an ActionListener that sets the \"label\" property of the target object to the value of the \"text\" property of the source (the value of the \"source\" property) of the event.\r\n\r\n    EventHandler.create(ActionListener.class, myButton, \"label\", \"source.text\")\r\n\r\nThis would correspond to the following inner class implementation:\r\n\r\n    //Equivalent code using an inner class instead of EventHandler.\r\n    new ActionListener {\r\n        public void actionPerformed(ActionEvent e) {\r\n            myButton.setLabel(((JTextField)e.getSource()).getText()); \r\n        }\r\n    }\r\n\r\n",
        "title": "Oracle_General Information about Writing Event Listeners.txt",
        "type": "Oracle_"
    }, {
        "rank": 9,
        "text": "\r\nAs we have seen above, generics give the impression that a new container type is created with each different type parameter. We have also seen that in addition to the normal type checking, the type parameter has to match as well when we assign generics variables.\r\nIn some cases this is too restrictive.  What if we would like to relax this additional checking? What if we would like to define a collection variable that can hold any generic collection, regardless of the parameter type it holds?\r\nThe wildcard type is represented by the character<?>, and pronouncedUnknown, orAny-Type. Any-Type can be expressed also by<? extends Object>. Any-Type includes Interfaces, not only Classes.\r\nSo now we can define a collection whose element type matches anything. See below:\r\n\r\n\r\nUpper bounded wildcards[edit]\r\n\r\nYou can specify a restriction on the types of classes that may be used. For example,<? extends ClassName>only allows objects of classClassNameor a subclass.\r\nFor example, to create a collection that may only contain \"Serializable\" objects, specify:\r\n\r\n\r\nThe above code is valid because theStringclass is serializable. Use of a class that is not serializable would cause a compilation error. The added items can be retrieved asSerializableobject. You can call methods of theSerializableinterface or cast it toString. The following collection can only contain objects that extend the classAnimal.\r\n\r\n\r\n\r\nLower bounded wildcards[edit]\r\n\r\n<? super ClassName>specifies a restriction on the types of classes that may be used.\r\nFor example, to declare a Comparator that can compare Dogs, you use:\r\n\r\n\r\nNow suppose you define a comparator that can compare Animals:\r\n\r\n\r\nSinceDogsareAnimals, you can use this comparator to compare Dogs also. Comparators for any superclass of Dog can also compare Dog; but comparators for any strict subclass cannot.\r\n\r\n\r\nThe above code is valid because theAnimalclass is a supertype of theDogclass. Use of a class that is not a supertype would cause a compilation error.\r\n\r\nUnbounded wildcard[edit]\r\n\r\nThe advantage of the unbounded wildcard (i.e.<?>) compared to a raw type (i.e. without generic) is to explicitly say that the parameterized type is unknown, notany type. That way, all the operations that implies to know the type are forbidden to avoid unsafe operation. Consider the following code:\r\n\r\n\r\nThis code will compile but this code may corrupt the collection if the collection only contains strings:\r\n\r\n\r\nThis situation could have been avoided if theaddAtBottom(Collection)method was defined with an unbounded wildcard:addAtBottom(Collection<?>). With this signature, it is impossible to compile a code that is dependent of the parameterized type. Only independent methods of a collection (clear(),isEmpty(),iterator(),remove(Object o),size(), ...) can be called. For instance,addAtBottom(Collection<?>)could contain the following code:\r\n\r\n\r\n",
        "title": "Generics_Wildcard Types_text.txt",
        "type": "text"
    }, {
        "rank": 10,
        "text": "\r\nThe entry point for all reflection operations is \r\njava.lang.Class. With the exception of \r\njava.lang.reflect.ReflectPermission, none of the classes in \r\njava.lang.reflect have public constructors. To get to these classes, it is necessary to invoke appropriate methods on \r\nClass. There are several ways to get a \r\nClass depending on whether the code has access to an object, the name of class, a type, or an existing \r\nClass.\r\nObject.getClass()\r\nIf an instance of an object is available, then the simplest way to get its \r\nClass is to invoke \r\nObject.getClass(). Of course, this only works for reference types which all inherit from \r\nObject. Some examples follow.\r\n\r\nClass c = \"foo\".getClass();\r\n\r\nReturns the \r\nClass for \r\nString\r\n\r\nClass c = System.console().getClass();\r\n\r\nThere is a unique console associated with the virtual machine which is returned by the static method \r\nSystem.console(). The value returned by \r\ngetClass() is the \r\nClass corresponding to \r\njava.io.Console.\r\n\r\nenum E { A, B }\r\nClass c = A.getClass();\r\n\r\nA is is an instance of the enum E; thus \r\ngetClass() returns the \r\nClass corresponding to the enumeration type E.\r\n\r\nbyte[] bytes = new byte[1024];\r\nClass c = bytes.getClass();\r\n\r\nSince arrays are \r\nObjects, it is also possible to invoke \r\ngetClass() on an instance of an array. The returned \r\nClass corresponds to an array with component type byte.\r\n\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\nSet<String> s = new HashSet<String>();\r\nClass c = s.getClass();\r\n\r\nIn this case, \r\njava.util.Set is an interface to an object of type \r\njava.util.HashSet. The value returned by \r\ngetClass() is the class corresponding to \r\njava.util.HashSet.\r\nThe .class Syntax\r\nIf the type is available but there is no instance then it is possible to obtain a \r\nClass by appending \".class\" to the name of the type. This is also the easiest way to obtain the \r\nClass for a primitive type.\r\n\r\nboolean b;\r\nClass c = b.getClass();   // compile-time error\r\n\r\nClass c = boolean.class;  // correct\r\n\r\nNote that the statement boolean.getClass() would produce a compile-time error because a boolean is a primitive type and cannot be dereferenced. The .class syntax returns the \r\nClass corresponding to the type boolean.\r\n\r\nClass c = java.io.PrintStream.class;\r\n\r\nThe variable c will be the \r\nClass corresponding to the type \r\njava.io.PrintStream.\r\n\r\nClass c = int[][][].class;\r\n\r\nThe .class syntax may be used to retrieve a \r\nClass corresponding to a multi-dimensional array of a given type.\r\nClass.forName()\r\nIf the fully-qualified name of a class is available, it is possible to get the corresponding \r\nClass using the static method \r\nClass.forName(). This cannot be used for primitive types. The syntax for names of array classes is described by \r\nClass.getName(). This syntax is applicable to references and primitive types.\r\n\r\nClass c = Class.forName(\"com.duke.MyLocaleServiceProvider\");\r\n\r\nThis statement will create a class from the given fully-qualified name.\r\n\r\nClass cDoubleArray = Class.forName(\"[D\");\r\n\r\nClass cStringArray = Class.forName(\"[[Ljava.lang.String;\");\r\n\r\nThe variable cDoubleArray will contain the \r\nClass corresponding to an array of primitive type double (i.e. the same as double[].class). The cStringArray variable will contain the \r\nClass corresponding to a two-dimensional array of \r\nString (i.e. identical to String[][].class).\r\nTYPE Field for Primitive Type Wrappers\r\nThe .class syntax is a more convenient and the preferred way to obtain the \r\nClass for a primitive type; however there is another way to acquire the \r\nClass. Each of the primitive types and void has a wrapper class in \r\njava.lang that is used for boxing of primitive types to reference types. Each wrapper class contains a field named TYPE which is equal to the \r\nClass for the primitive type being wrapped.\r\n\r\nClass c = Double.TYPE;\r\n\r\nThere is a class \r\njava.lang.Double which is used to wrap the primitive type double whenever an \r\nObject is required. The value of \r\nDouble.TYPE is identical to that of double.class.\r\n\r\nClass c = Void.TYPE;\r\n\r\n\r\nVoid.TYPE is identical to void.class.\r\nMethods that Return Classes\r\nThere are several Reflection APIs which return classes but these may only be accessed if a \r\nClass has already been obtained either directly or indirectly.\r\n\r\n\r\nClass.getSuperclass()\r\nReturns the super class for the given class.\r\n\r\nClass c = javax.swing.JButton.class.getSuperclass();\r\n\r\nThe super class of \r\njavax.swing.JButton is \r\njavax.swing.AbstractButton.\r\n\r\n\r\n\r\nClass.getClasses()\r\nReturns all the public classes, interfaces, and enums that are members of the class including inherited members.\r\n\r\nClass<?>[] c = Character.class.getClasses();\r\n\r\nCharacter contains two member classes \r\nCharacter.Subset and \r\nCharacter.UnicodeBlock.\r\n\r\n\r\n\r\nClass.getDeclaredClasses()\r\nReturns all of the classes interfaces, and enums that are explicitly declared in this class.\r\n\r\nClass<?>[] c = Character.class.getDeclaredClasses();\r\n\r\nCharacter contains two public member classes \r\nCharacter.Subset and \r\nCharacter.UnicodeBlock and one private class Character.CharacterCache.\r\n\r\n\r\n\r\nClass.getDeclaringClass()\r\njava.lang.reflect.Field.getDeclaringClass()\r\njava.lang.reflect.Method.getDeclaringClass()\r\njava.lang.reflect.Constructor.getDeclaringClass()\r\nReturns the \r\nClass in which these members were declared. \r\nAnonymous Class Declarations will not have a declaring class but will have an enclosing class.\r\n\r\nimport java.lang.reflect.Field;\r\n\r\nField f = System.class.getField(\"out\");\r\nClass c = f.getDeclaringClass();\r\n\r\nThe field \r\nout is declared in \r\nSystem.\r\n\r\npublic class MyClass {\r\n    static Object o = new Object() {\r\n        public void m() {} \r\n    };\r\n    static Class<c> = o.getClass().getEnclosingClass();\r\n}\r\n\r\nThe declaring class of the anonymous class defined by o is null.\r\n\r\n\r\n\r\nClass.getEnclosingClass()\r\nReturns the immediately enclosing class of the class.\r\n\r\nClass c = Thread.State.class().getEnclosingClass();\r\n\r\nThe enclosing class of the enum \r\nThread.State is \r\nThread.\r\n\r\npublic class MyClass {\r\n    static Object o = new Object() { \r\n        public void m() {} \r\n    };\r\n    static Class<c> = o.getClass().getEnclosingClass();\r\n}\r\n\r\nThe anonymous class defined by o is enclosed by MyClass.\r\n\r\n",
        "title": "Oracle_Retrieving Class Objects.txt",
        "type": "Oracle_"
    }]
}
