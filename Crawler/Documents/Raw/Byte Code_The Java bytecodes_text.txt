
See Oracle's Java Virtual Machine Specification[1]for more detailed descriptions
The manipulation of the operand stack is notated as [before]→[after], where [before] is the stack before the instruction is executed and [after] is the stack after the instruction is executed. A stack with the element 'b' on the top and element 'a' just after the top element is denoted 'a,b'.

MnemonicOpcode(inhex)Other bytesStack[before]→[after]DescriptionAaaload32arrayref, index → valueloads onto the stack a reference from an arrayaastore53arrayref, index, value →stores a reference into an arrayaconst_null01→ nullpushes anullreference onto the stackaload19index→ objectrefloads a reference onto the stack from a local variable#indexaload_02a→ objectrefloads a reference onto the stack from local variable 0aload_12b→ objectrefloads a reference onto the stack from local variable 1aload_22c→ objectrefloads a reference onto the stack from local variable 2aload_32d→ objectrefloads a reference onto the stack from local variable 3anewarraybdindexbyte1, indexbyte2count → arrayrefcreates a new array of references of lengthcountand component type identified by the class referenceindex(indexbyte1 << 8 + indexbyte2) in the constant poolareturnb0objectref → [empty]returns a reference from a methodarraylengthbearrayref → lengthgets the length of an arrayastore3aindexobjectref →stores a reference into a local variable#indexastore_04bobjectref →stores a reference into local variable 0astore_14cobjectref →stores a reference into local variable 1astore_24dobjectref →stores a reference into local variable 2astore_34eobjectref →stores a reference into local variable 3athrowbfobjectref → [empty], objectrefthrows an error or exception (notice that the rest of the stack is cleared, leaving only a reference to the Throwable)Bbaload33arrayref, index → valueloads a byte or Boolean value from an arraybastore54arrayref, index, value →stores a byte or Boolean value into an arraybipush10byte→ valuepushes abyteonto the stack as an integervalueCcaload34arrayref, index → valueloads a char from an arraycastore55arrayref, index, value →stores a char into an arraycheckcastc0indexbyte1, indexbyte2objectref → objectrefchecks whether anobjectrefis of a certain type, the class reference of which is in the constant pool atindex(indexbyte1 << 8 + indexbyte2)Dd2f90value → resultconverts a double to a floatd2i8evalue → resultconverts a double to an intd2l8fvalue → resultconverts a double to a longdadd63value1, value2 → resultadds two doublesdaload31arrayref, index → valueloads a double from an arraydastore52arrayref, index, value →stores a double into an arraydcmpg98value1, value2 → resultcompares two doublesdcmpl97value1, value2 → resultcompares two doublesdconst_00e→ 0.0pushes the constant0.0onto the stackdconst_10f→ 1.0pushes the constant1.0onto the stackddiv6fvalue1, value2 → resultdivides two doublesdload18index→ valueloads a doublevaluefrom a local variable#indexdload_026→ valueloads a double from local variable 0dload_127→ valueloads a double from local variable 1dload_228→ valueloads a double from local variable 2dload_329→ valueloads a double from local variable 3dmul6bvalue1, value2 → resultmultiplies two doublesdneg77value → resultnegates a doubledrem73value1, value2 → resultgets the remainder from a division between two doublesdreturnafvalue → [empty]returns a double from a methoddstore39indexvalue →stores a doublevalueinto a local variable#indexdstore_047value →stores a double into local variable 0dstore_148value →stores a double into local variable 1dstore_249value →stores a double into local variable 2dstore_34avalue →stores a double into local variable 3dsub67value1, value2 → resultsubtracts a double from anotherdup59value → value, valueduplicates the value on top of the stackdup_x15avalue2, value1 → value1, value2, value1inserts a copy of the top value into the stack two values from the topdup_x25bvalue3, value2, value1 → value1, value3, value2, value1inserts a copy of the top value into the stack two (if value2 is double or long it takes up the entry of value3, too) or three values (if value2 is neither double nor long) from the topdup25c{value2, value1} → {value2, value1}, {value2, value1}duplicate top two stack words (two values, if value1 is not double nor long; a single value, if value1 is double or long)dup2_x15dvalue3, {value2, value1} → {value2, value1}, value3, {value2, value1}duplicate two words and insert beneath third word (see explanation above)dup2_x25e{value4, value3}, {value2, value1} → {value2, value1}, {value4, value3}, {value2, value1}duplicate two words and insert beneath fourth wordFf2d8dvalue → resultconverts a float to a doublef2i8bvalue → resultconverts a float to an intf2l8cvalue → resultconverts a float to a longfadd62value1, value2 → resultadds two floatsfaload30arrayref, index → valueloads a float from an arrayfastore51arreyref, index, value →stores a float in an arrayfcmpg96value1, value2 → resultcompares two floatsfcmpl95value1, value2 → resultcompares two floatsfconst_00b→ 0.0fpushes0.0fon the stackfconst_10c→ 1.0fpushes1.0fon the stackfconst_20d→ 2.0fpushes2.0fon the stackfdiv6evalue1, value2 → resultdivides two floatsfload17index→ valueloads a floatvaluefrom a local variable#indexfload_022→ valueloads a floatvaluefrom local variable 0fload_123→ valueloads a floatvaluefrom local variable 1fload_224→ valueloads a floatvaluefrom local variable 2fload_325→ valueloads a floatvaluefrom local variable 3fmul6avalue1, value2 → resultmultiplies two floatsfneg76value → resultnegates a floatfrem72value1, value2 → resultgets the remainder from a division between two floatsfreturnaevalue → [empty]returns a float from methodfstore38indexvalue →stores a floatvalueinto a local variable#indexfstore_043value →stores a floatvalueinto local variable 0fstore_144value →stores a floatvalueinto local variable 1fstore_245value →stores a floatvalueinto local variable 2fstore_346value →stores a floatvalueinto local variable 3fsub66value1, value2 → resultsubtracts two floatsGgetfieldb4index1, index2objectref → valuegets a fieldvalueof an objectobjectref, where the field is identified by field reference in the constant poolindex(index1 << 8 + index2)getstaticb2index1, index2→ valuegets a static fieldvalueof a class, where the field is identified by field reference in the constant poolindex(index1 << 8 + index2)gotoa7branchbyte1, branchbyte2[no change]goes to another instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)goto_wc8branchbyte1, branchbyte2, branchbyte3, branchbyte4[no change]goes to another instruction atbranchoffset(signed int constructed from unsigned bytesbranchbyte1 << 24 +branchbyte2 << 16 +branchbyte3 << 8 + branchbyte4)Ii2b91value → resultconverts an int into a bytei2c92value → resultconverts an int into a characteri2d87value → resultconverts an int into a doublei2f86value → resultconverts an int into a floati2l85value → resultconverts an int into a longi2s93value → resultconverts an int into a shortiadd60value1, value2 → resultadds two ints togetheriaload2earrayref, index → valueloads an int from an arrayiand7evalue1, value2 → resultperforms a logical and on two integersiastore4farrayref, index, value →stores an int into an arrayiconst_m102→ -1loads the int value -1 onto the stackiconst_003→ 0loads the int value 0 onto the stackiconst_104→ 1loads the int value 1 onto the stackiconst_205→ 2loads the int value 2 onto the stackiconst_306→ 3loads the int value 3 onto the stackiconst_407→ 4loads the int value 4 onto the stackiconst_508→ 5loads the int value 5 onto the stackidiv6cvalue1, value2 → resultdivides two integersif_acmpeqa5branchbyte1, branchbyte2value1, value2 →if references are equal, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)if_acmpnea6branchbyte1, branchbyte2value1, value2 →if references are not equal, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)if_icmpeq9fbranchbyte1, branchbyte2value1, value2 →if ints are equal, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)if_icmpnea0branchbyte1, branchbyte2value1, value2 →if ints are not equal, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)if_icmplta1branchbyte1, branchbyte2value1, value2 →ifvalue1is less thanvalue2, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)if_icmpgea2branchbyte1, branchbyte2value1, value2 →ifvalue1is greater than or equal tovalue2, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)if_icmpgta3branchbyte1, branchbyte2value1, value2 →ifvalue1is greater thanvalue2, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)if_icmplea4branchbyte1, branchbyte2value1, value2 →ifvalue1is less than or equal tovalue2, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)ifeq99branchbyte1, branchbyte2value →ifvalueis 0, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)ifne9abranchbyte1, branchbyte2value →ifvalueis not 0, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)iflt9bbranchbyte1, branchbyte2value →ifvalueis less than 0, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)ifge9cbranchbyte1, branchbyte2value →ifvalueis greater than or equal to 0, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)ifgt9dbranchbyte1, branchbyte2value →ifvalueis greater than 0, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)ifle9ebranchbyte1, branchbyte2value →ifvalueis less than or equal to 0, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)ifnonnullc7branchbyte1, branchbyte2value →ifvalueis not null, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)ifnullc6branchbyte1, branchbyte2value →ifvalueis null, branch to instruction atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2)iinc84index, const[No change]increment local variable#indexby signed byteconstiload15index→ valueloads an intvaluefrom a variable#indexiload_01a→ valueloads an intvaluefrom variable 0iload_11b→ valueloads an intvaluefrom variable 1iload_21c→ valueloads an intvaluefrom variable 2iload_31d→ valueloads an intvaluefrom variable 3imul68value1, value2 → resultmultiply two integersineg74value → resultnegate intinstanceofc1indexbyte1, indexbyte2objectref → resultdetermines if an objectobjectrefis of a given type, identified by class referenceindexin constant pool (indexbyte1 << 8 + indexbyte2)invokeinterfaceb9indexbyte1, indexbyte2, count, 0objectref, [arg1, arg2, ...] →invokes an interface method on objectobjectref, where the interface method is identified by method referenceindexin constant pool (indexbyte1 << 8 + indexbyte2) andcountis the number of arguments to pop from the stack frame including the object on which the method is being called and must always be greater than or equal to 1invokespecialb7indexbyte1, indexbyte2objectref, [arg1, arg2, ...] →invoke instance method on objectobjectrefrequiring special handling (instance initialization method, a private method, or a superclass method), where the method is identified by method referenceindexin constant pool (indexbyte1 << 8 + indexbyte2)invokestaticb8indexbyte1, indexbyte2[arg1, arg2, ...] →invoke a static method, where the method is identified by method referenceindexin constant pool (indexbyte1 << 8 + indexbyte2)invokevirtualb6indexbyte1, indexbyte2objectref, [arg1, arg2, ...] →invoke virtual method on objectobjectref, where the method is identified by method referenceindexin constant pool (indexbyte1 << 8 + indexbyte2)ior80value1, value2 → resultlogical int orirem70value1, value2 → resultlogical int remainderireturnacvalue → [empty]returns an integer from a methodishl78value1, value2 → resultint shift leftishr7avalue1, value2 → resultint shift rightistore36indexvalue →store intvalueinto variable#indexistore_03bvalue →store intvalueinto variable 0istore_13cvalue →store intvalueinto variable 1istore_23dvalue →store intvalueinto variable 2istore_33evalue →store intvalueinto variable 3isub64value1, value2 → resultint subtractiushr7cvalue1, value2 → resultint shift rightixor82value1, value2 → resultint xorJjsra8branchbyte1, branchbyte2→ addressjump to subroutine atbranchoffset(signed short constructed from unsigned bytesbranchbyte1 << 8 + branchbyte2) and place the return address on the stackjsr_wc9branchbyte1, branchbyte2, branchbyte3, branchbyte4→ addressjump to subroutine atbranchoffset(signed int constructed from unsigned bytesbranchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4) and place the return address on the stackLl2d8avalue → resultconverts a long to a doublel2f89value → resultconverts a long to a floatl2i88value → resultconverts a long to an intladd61value1, value2 → resultadd two longslaload2farrayref, index → valueload a long from an arrayland7fvalue1, value2 → resultbitwise and of two longslastore50arrayref, index, value →store a long to an arraylcmp94value1, value2 → resultcompares two longs valueslconst_009→ 0Lpushes the long 0 onto the stacklconst_10a→ 1Lpushes the long 1 onto the stackldc12index→ valuepushes a constant#indexfrom a constant pool (String, int, float or class type) onto the stackldc_w13indexbyte1, indexbyte2→ valuepushes a constant#indexfrom a constant pool (String, int, float or class type) onto the stack (wideindexis constructed asindexbyte1 << 8 + indexbyte2)ldc2_w14indexbyte1, indexbyte2→ valuepushes a constant#indexfrom a constant pool (double or long) onto the stack (wideindexis constructed asindexbyte1 << 8 + indexbyte2)ldiv6dvalue1, value2 → resultdivide two longslload16index→ valueload a long value from a local variable#indexlload_01e→ valueload a long value from a local variable 0lload_11f→ valueload a long value from a local variable 1lload_220→ valueload a long value from a local variable 2lload_321→ valueload a long value from a local variable 3lmul69value1, value2 → resultmultiplies two longslneg75value → resultnegates a longlookupswitchab<0-3 bytes padding>, defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, npairs1, npairs2, npairs3, npairs4, match-offset pairs...key →a target address is looked up from a table using a key and execution continues from the instruction at that addresslor81value1, value2 → resultbitwise or of two longslrem71value1, value2 → resultremainder of division of two longslreturnadvalue → [empty]returns a long valuelshl79value1, value2 → resultbitwise shift left of a longvalue1byvalue2positionslshr7bvalue1, value2 → resultbitwise shift right of a longvalue1byvalue2positionslstore37indexvalue →store a longvaluein a local variable#indexlstore_03fvalue →store a longvaluein a local variable 0lstore_140value →store a longvaluein a local variable 1lstore_241value →store a longvaluein a local variable 2lstore_342value →store a longvaluein a local variable 3lsub65value1, value2 → resultsubtract two longslushr7dvalue1, value2 → resultbitwise shift right of a longvalue1byvalue2positions, unsignedlxor83value1, value2 → resultbitwise exclusive or of two longsMmonitorenterc2objectref →enter monitor for object ("grab the lock" - start of synchronized() section)monitorexitc3objectref →exit monitor for object ("release the lock" - end of synchronized() section)multianewarrayc5indexbyte1, indexbyte2, dimensionscount1, [count2,...] → arrayrefcreate a new array ofdimensionsdimensions with elements of type identified by class reference in constant poolindex(indexbyte1 << 8 + indexbyte2); the sizes of each dimension is identified bycount1, [count2, etc]Nnewbbindexbyte1, indexbyte2→ objectrefcreates new object of type identified by class reference in constant poolindex(indexbyte1 << 8 + indexbyte2)newarraybcatypecount → arrayrefcreates new array withcountelements of primitive type identified byatypenop00[No change]performs no operationPpop57value →discards the top value on the stackpop258{value2, value1} →discards the top two values on the stack (or one value, if it is a double or long)putfieldb5indexbyte1, indexbyte2objectref, value →set field tovaluein an objectobjectref, where the field is identified by a field referenceindexin constant pool (indexbyte1 << 8 + indexbyte2)putstaticb3indexbyte1, indexbyte2value →set static field tovaluein a class, where the field is identified by a field referenceindexin constant pool (indexbyte1 << 8 + indexbyte2)Rreta9index[No change]continue execution from address taken from a local variable#index(the asymmetry with jsr is intentional)returnb1→ [empty]return void from methodSsaload35arrayref, index → valueload short from arraysastore56arrayref, index, value →store short to arraysipush11byte1, byte2→ valuepushes a signed integer (byte1 << 8 + byte2) onto the stackswap5fvalue2, value1 → value1, value2swaps two top words on the stack (note that value1 and value2 must not be double or long)Ttableswitchaa[0-3 bytes padding], defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, lowbyte1, lowbyte2, lowbyte3, lowbyte4, highbyte1, highbyte2, highbyte3, highbyte4, jump offsets...index →continue execution from an address in the table at offsetindexWwidec4opcode, indexbyte1, indexbyte2oriinc, indexbyte1, indexbyte2, countbyte1, countbyte2[same as for corresponding instructions]executeopcode, whereopcodeis either iload, fload, aload, lload, dload, istore, fstore, astore, lstore, dstore, or ret, but assume theindexis 16 bit; or execute iinc, where theindexis 16 bits and the constant to increment by is a signed 16 bit shortUnusedbreakpointcareserved for breakpoints in Java debuggers; should not appear in any class fileimpdep1fereserved for implementation-dependent operations within debuggers; should not appear in any class fileimpdep2ffreserved for implementation-dependent operations within debuggers; should not appear in any class file(no name)cb-fdthese values are currently unassigned for opcodes and are reserved for future usexxxunusedxxxbathis opcode is reserved "for historical reasons"

