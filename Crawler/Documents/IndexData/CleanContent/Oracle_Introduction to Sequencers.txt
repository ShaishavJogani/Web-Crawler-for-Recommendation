In world MIDI , sequencer hardware software device precisely play record sequence time-stamped MIDI message . Similarly , Java Sound API , Sequencer abstract interface define property object play record sequence MidiEvent object . A Sequencer typically load MidiEvent sequence standard MIDI file save file . Sequences also edit . The following page explain use Sequencer object , along related class interface , accomplish task . To develop intuitive understanding Sequencer , think analogy tape recorder , sequencer resemble many respect . Whereas tape recorder play audio , sequencer play MIDI data . A sequence multi-track , linear , time-ordered recording MIDI musical data , sequencer play various speed , rewind , shuttle particular point , record , copy file storage . Transmitting Receiving MIDI Messages explain device typically Receiver object , Transmitter object , . To play music , device generally receive MidiMessages Receiver , turn usually receive Transmitter belong Sequencer . The device Receiver might Synthesizer , generate audio directly , might MIDI output port , transmit MIDI data physical cable external piece equipment . Similarly , record music , series time-stamped MidiMessages generally send Receiver Sequencer , place Sequence object . Typically object send message Transmitter associate hardware input port , port relay MIDI data get external instrument . However , device responsible send message might instead Sequencer , device Transmitter . Furthermore , previously describe , program send message without use Transmitter . A Sequencer Receivers Transmitters . When 's record , actually obtain MidiMessages via Receivers . During playback , use Transmitters send MidiMessages store Sequence record ( load file ) . One way think role Sequencer Java Sound API aggregator `` de-aggregator '' MidiMessages . A series separate MidiMessages , independent , send Sequencer along time stamp mark timing musical event . These MidiMessages encapsulate MidiEvent object collect Sequence object action Sequencer.record method . A Sequence data structure contain aggregate MidiEvents , usually represent series musical note , often entire song composition . On playback , Sequencer extract MidiMessages MidiEvent object Sequence transmit one device either render sound , save , modify , pass device . Some sequencer might neither transmitter receiver . For example , might create MidiEvents scratch result keyboard mouse event , instead receive MidiMessages Receivers . Similarly , might play music communicate directly internal synthesizer ( could actually object sequencer ) instead send MidiMessages Receiver associate separate object . However , rest discussion assume normal case sequencer use Receivers Transmitters . When Use Sequencer It 's possible application program send MIDI message directly device , without use sequencer , describe Transmitting Receiving MIDI Messages . The program simply invoke Receiver.send method time want send message . This straightforward approach 's useful program create message real time . For example , consider program let user play note click onscreen piano keyboard . When program get mouse-down event , immediately send appropriate Note On message synthesizer . As previously mention , program include time stamp MIDI message send device 's receiver . However , time stamp use fine-tune timing , correct process latency . The caller ca n't generally set arbitrary time stamp ; time value pass Receiver.send must close present time , receiving device might able schedule message correctly . This mean application program want create queue MIDI message entire piece music ahead time ( instead create message response real-time event ) , would careful schedule invocation Receiver.send nearly right time . Fortunately , application program n't concern scheduling . Instead invoke Receiver.send , program use Sequencer object manage queue MIDI message . The sequencer take care scheduling send messagesâin word , play music correct timing . Generally , 's advantageous use sequencer whenever need convert non-real-time series MIDI message real-time series ( playback ) , vice versa ( record ) . Sequencers commonly use play data MIDI file record data MIDI input port . Understanding Sequence Data Before examine Sequencer API , help understand kind data 's store sequence . Sequences Tracks In Java Sound API , sequencer closely follow Standard MIDI Files specification way organize record MIDI data . As mention , Sequence aggregation MidiEvents , organize time . But structure Sequence linear series MidiEvents : Sequence actually contain global timing information plus collection Tracks , Tracks hold MidiEvent data . So data play sequencer consist three-level hierarchy object : Sequencer , Track , MidiEvent . In conventional use object , Sequence represent complete musical composition section composition , Track corresponding voice player ensemble . In model , data particular Track would also therefore encode particular MIDI channel reserve voice player . This way organize data convenient purpose edit sequence , note conventional way use Tracks . There nothing definition Track class keep contain mix MidiEvents different MIDI channel . For example , entire multi-channel MIDI composition mixed record onto one Track . Also , standard MIDI file Type 0 ( oppose Type 1 Type 2 ) contain definition one track ; Sequence 's read file necessarily single Track object . MidiEvents Ticks As discuss Overview MIDI Package , Java Sound API include MidiMessage object correspond raw two- three-byte sequence make standard MIDI message . A MidiEvent simply packaging MidiMessage along accompany timing value specify event occur . ( We might say sequence really consist four- five-level hierarchy data , rather three-level , ostensible low level , MidiEvent , actually contain lower-level MidiMessage , likewise MidiMessage object contain array byte comprise standard MIDI message . ) In Java Sound API , two different way MidiMessages associate timing value . One way mention `` When Use Sequencer . '' This technique describe detail Sending Message Receiver without Using Transmitter Understanding Time Stamps . There , saw send method Receiver take MidiMessage argument time-stamp argument . That kind time stamp express microsecond . The way MidiMessage timing specify encapsulate MidiEvent . In case , timing express slightly abstract unit call tick . What duration tick ? It vary sequence ( within sequence ) , value store header standard MIDI file . The size tick give one two type unit : Pulses ( tick ) per quarter note , abbreviate PPQ Ticks per frame , also know SMPTE time code ( standard adopt Society Motion Picture Television Engineers ) If unit PPQ , size tick express fraction quarter note , relative , absolute , time value . A quarter note musical duration value often correspond one beat music ( quarter measure 4/4 time ) . The duration quarter note dependent tempo , vary course music sequence contain tempo-change event . So sequence 's timing increment ( tick ) occur , say 96 time per quarter note , event 's timing value measure event 's position musical term , absolute time value . On hand , case SMPTE , unit measure absolute time , notion tempo inapplicable . There actually four different SMPTE convention available , refer number motion-picture frame per second . The number frame per second 24 , 25 , 29.97 , 30 . With SMPTE time code , size tick express fraction frame . In Java Sound API , invoke Sequence.getDivisionType learn type unitânamely , PPQ one SMPTE unitsâis use particular sequence . You calculate size tick invoke Sequence.getResolution . The latter method return number tick per quarter note division type PPQ , per SMPTE frame division type one SMPTE convention . You get size tick use formula case PPQ : ticksPerSecond = resolution * ( currentTempoInBeatsPerMinute / 60.0 ) ; tickSize = 1.0 / ticksPerSecond ; formula case SMPTE : framesPerSecond = ( divisionType == Sequence.SMPTE_24 ? 24 : ( divisionType == Sequence.SMPTE_25 ? 25 : ( divisionType == Sequence.SMPTE_30 ? 30 : ( divisionType == Sequence.SMPTE_30DROP ? 29.97 ) ) ) ) ; ticksPerSecond = resolution * framesPerSecond ; tickSize = 1.0 / ticksPerSecond ; The Java Sound API 's definition timing sequence mirror Standard MIDI Files specification . However , 's one important difference . The tick value contain MidiEvents measure cumulative time , rather delta time . In standard MIDI file , event 's timing information measure amount time elapse since onset previous event sequence . This call delta time . But Java Sound API , tick n't delta value ; 're previous event 's time value plus delta value . In word , Java Sound API timing value event always great previous event sequence ( equal , event suppose simultaneous ) . Each event 's timing value measure time elapse since beginning sequence . To summarize , Java Sound API express time information either MIDI tick microsecond . MidiEvents store time information term MIDI tick . The duration tick calculate Sequence 's global timing information , sequence use tempo-based timing , current musical tempo . The time stamp associate MidiMessage send Receiver , hand , always express microsecond . One goal design avoid conflict notion time . It 's job Sequencer interpret time unit MidiEvents , might PPQ unit , translate absolute time microsecond , take current tempo account . The sequencer must also express microsecond relative time device receive message open . Note sequencer multiple transmitter , deliver message different receiver might associate completely different device . You see , , sequencer able perform multiple translation time , make sure device receive time stamp appropriate notion time . To make matter complicated , different device might update notion time base different source ( operating system 's clock , clock maintain sound card ) . This mean timing drift relative sequencer 's . To keep synchronization sequencer , device permit `` slave '' sequencer 's notion time . Setting master slave discuss later MidiEvent .