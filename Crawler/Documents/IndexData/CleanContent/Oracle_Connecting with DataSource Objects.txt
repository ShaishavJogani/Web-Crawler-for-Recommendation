This section cover DataSource object , preferred mean get connection data source . In addition advantage , explain later , DataSource object provide connection pooling distributed transaction . This functionality essential enterprise database computing . In particular , integral Enterprise JavaBeans ( EJB ) technology . This section show get connection use DataSource interface use distributed transaction connection pooling . Both involve code change JDBC application . The work perform deploy class make operation possible , system administrator usually tool ( Apache Tomcat Oracle WebLogic Server ) , varies type DataSource object deploy . As result , section devote show system administrator set environment programmer use DataSource object get connection . The following topic cover : Using DataSource Objects Get Connections Deploying Basic DataSource Objects Deploying Other DataSource Implementations Getting Using Pooled Connections Deploying Distributed Transactions Using Connections Distributed Transactions Using DataSource Objects Get Connection In Establishing Connection , learn get connection use DriverManager class . This section show use DataSource object get connection data source , preferred way . Objects instantiate class implement DataSource represent particular DBMS data source , file . A DataSource object represent particular DBMS data source , file . If company use one data source , deploy separate DataSource object . The DataSource interface implement driver vendor . It implement three different way : A basic DataSource implementation produce standard Connection object pool use distributed transaction . A DataSource implementation support connection pool produce Connection object participate connection pooling , , connection recycle . A DataSource implementation support distribute transaction produce Connection object use distributed transaction , , transaction access two DBMS server . A JDBC driver include least basic DataSource implementation . For example , Java DB JDBC driver include implementation org.apache.derby.jdbc.ClientDataSource MySQL , com.mysql.jdbc.jdbc2.optional.MysqlDataSource . If client run Java 8 compact profile 2 , Java DB JDBC driver org.apache.derby.jdbc.BasicClientDataSource40 . The sample tutorial require compact profile 3 great . A DataSource class support distribute transaction typically also implement support connection pooling . For example , DataSource class provide EJB vendor almost always support connection pooling distributed transaction . Suppose owner thrive chain The Coffee Break shop , previous example , decide expand far sell coffee Internet . With large amount online business expect , owner definitely need connection pooling . Opening closing connection involve great deal overhead , owner anticipate online order system necessitate sizable number query update . With connection pooling , pool connection use , avoid expense create new connection every database access . In addition , owner second DBMS contain data recently acquire coffee roast company . This mean owner want able write distributed transaction use old DBMS server new one . The chain owner reconfigured computer system serve new , large customer base . The owner purchase recent JDBC driver EJB application server work able use distributed transaction get increased performance come connection pooling . Many JDBC driver available compatible recently purchase EJB server . The owner three-tier architecture , new EJB application server JDBC driver middle tier two DBMS server third tier . Client computer make request first tier . Deploying Basic DataSource Objects The system administrator need deploy DataSource object The Coffee Break 's program team start use . Deploying DataSource object consist three task : Creating instance DataSource class Setting property Registering naming service use Java Naming Directory Interface ( JNDI ) API First , consider basic case , use basic implementation DataSource interface , , one support connection pooling distribute transaction . In case one DataSource object need deploy . A basic implementation DataSource produce kind connection DriverManager class produce . Creating Instance DataSource Class Setting Properties Suppose company want basic implementation DataSource buy driver JDBC vendor DB Access , Inc . This driver include class com.dbaccess.BasicDataSource implement DataSource interface . The following code excerpt create instance class BasicDataSource set property . After instance BasicDataSource deploy , programmer call method DataSource.getConnection get connection company 's database , CUSTOMER_ACCOUNTS . First , system administrator create BasicDataSource object use default constructor . The system administrator set three property . Note following code typically execute deployment tool : com.dbaccess.BasicDataSource = new com.dbaccess.BasicDataSource ( ) ; ds.setServerName ( `` grinder '' ) ; ds.setDatabaseName ( `` CUSTOMER_ACCOUNTS '' ) ; ds.setDescription ( `` Customer account database billing '' ) ; The variable represent database CUSTOMER_ACCOUNTS instal server . Any connection produce BasicDataSource object connection database CUSTOMER_ACCOUNTS . Registering DataSource Object Naming Service That Uses JNDI API With property set , system administrator register BasicDataSource object JNDI ( Java Naming Directory Interface ) name service . The particular naming service use usually determine system property , show . The following code excerpt register BasicDataSource object bind logical name jdbc/billingDB : Context ctx = new InitialContext ( ) ; ctx.bind ( `` jdbc/billingDB '' , ) ; This code use JNDI API . The first line create InitialContext object , serve starting point name , similar root directory file system . The second line associate , bind , BasicDataSource object logical name jdbc/billingDB . In next code excerpt , give naming service logical name , return BasicDataSource object . The logical name string . In case , company decide use name billingDB logical name CUSTOMER_ACCOUNTS database . In previous example , jdbc subcontext initial context , directory root directory subdirectory . The name jdbc/billingDB like path name , last item path analogous file name . In case , billingDB logical name give BasicDataSource object . The subcontext jdbc reserve logical name bind DataSource object , jdbc always first part logical name data source . Using Deployed DataSource Object After basic DataSource implementation deploy system administrator , ready programmer use . This mean programmer give logical data source name bind instance DataSource class , JNDI naming service return instance DataSource class . The method getConnection call DataSource object get connection data source represent . For example , programmer might write following two line code get DataSource object produce connection database CUSTOMER_ACCOUNTS . Context ctx = new InitialContext ( ) ; DataSource = ( DataSource ) ctx.lookup ( `` jdbc/billingDB '' ) ; The first line code get initial context starting point retrieve DataSource object . When supply logical name jdbc/billingDB method lookup , method return DataSource object system administrator bound jdbc/billingDB deployment time . Because return value method lookup Java Object , must cast specific DataSource type assign variable . The variable instance class com.dbaccess.BasicDataSource implement DataSource interface . Calling method ds.getConnection produce connection CUSTOMER_ACCOUNTS database . Connection con = ds.getConnection ( `` fernanda '' , '' brew '' ) ; The getConnection method require user name password variable rest information necessary establish connection CUSTOMER_ACCOUNTS database , database name location , property . Advantages DataSource Objects Because property , DataSource object well alternative DriverManager class get connection . Programmers longer hard code driver name JDBC URL application , make portable . Also , DataSource property make maintain code much simpler . If change , system administrator update data source property concern change every application make connection data source . For example , data source move different server , system administrator would set serverName property new server name . Aside portability ease maintenance , use DataSource object get connection offer advantage . When DataSource interface implement work ConnectionPoolDataSource implementation , connection produce instance DataSource class automatically pool connection . Similarly , DataSource implementation implement work XADataSource class , connection produce automatically connection use distributed transaction . The next section show deploy type DataSource implementation . Deploying Other DataSource Implementations A system administrator another person work capacity deploy DataSource object connection produce pool connection . To , first deploy ConnectionPoolDataSource object deploy DataSource object implement work . The property ConnectionPoolDataSource object set represent data source connection produce . After ConnectionPoolDataSource object register JNDI naming service , DataSource object deploy . Generally two property must set DataSource object : description dataSourceName . The value give dataSourceName property logical name identify ConnectionPoolDataSource object previously deploy , object contain property need make connection . With ConnectionPoolDataSource DataSource object deploy , call method DataSource.getConnection DataSource object get pooled connection . This connection data source specify ConnectionPoolDataSource object 's property . The following example describe system administrator The Coffee Break would deploy DataSource object implement provide pooled connection . The system administrator would typically use deployment tool , code fragment show section code deployment tool would execute . To get good performance , The Coffee Break company buy JDBC driver DB Access , Inc. include class com.dbaccess.ConnectionPoolDS , implement ConnectionPoolDataSource interface . The system administrator create create instance class , set property , register JNDI naming service . The Coffee Break buy DataSource class , com.applogic.PooledDataSource , EJB server vendor , Application Logic , Inc . The class com.applogic.PooledDataSource implement connection pooling use underlying support provide ConnectionPoolDataSource class com.dbaccess.ConnectionPoolDS . The ConnectionPoolDataSource object must deploy first . The following code create instance com.dbaccess.ConnectionPoolDS set property : com.dbaccess.ConnectionPoolDS cpds = new com.dbaccess.ConnectionPoolDS ( ) ; cpds.setServerName ( `` creamer '' ) ; cpds.setDatabaseName ( `` COFFEEBREAK '' ) ; cpds.setPortNumber ( 9040 ) ; cpds.setDescription ( `` Connection pooling `` + `` COFFEEBREAK DBMS '' ) ; After ConnectionPoolDataSource object deploy , system administrator deploy DataSource object . The following code register com.dbaccess.ConnectionPoolDS object cpds JNDI naming service . Note logical name associate cpds variable subcontext pool add subcontext jdbc , similar add subdirectory another subdirectory hierarchical file system . The logical name instance class com.dbaccess.ConnectionPoolDS always begin jdbc/pool . Oracle recommend put ConnectionPoolDataSource object subcontext jdbc/pool : Context ctx = new InitialContext ( ) ; ctx.bind ( `` jdbc/pool/fastCoffeeDB '' , cpds ) ; Next , DataSource class implement interact cpds variable instance com.dbaccess.ConnectionPoolDS class deploy . The following code create instance class set property . Note two property set instance com.applogic.PooledDataSource . The description property set always require . The property set , dataSourceName , give logical JNDI name cpds , instance com.dbaccess.ConnectionPoolDS class . In word , cpds represent ConnectionPoolDataSource object implement connection pool DataSource object . The following code , would probably execute deployment tool , create PooledDataSource object , set property , bind logical name jdbc/fastCoffeeDB : com.applogic.PooledDataSource = new com.applogic.PooledDataSource ( ) ; ds.setDescription ( `` produce pooled connection COFFEEBREAK '' ) ; ds.setDataSourceName ( `` jdbc/pool/fastCoffeeDB '' ) ; Context ctx = new InitialContext ( ) ; ctx.bind ( `` jdbc/fastCoffeeDB '' , ) ; At point , DataSource object deploy application get pooled connection database COFFEEBREAK . Getting Using Pooled Connections A connection pool cache database connection object . The object represent physical database connection use application connect database . At run time , application request connection pool . If pool contain connection satisfy request , return connection application . If connection find , new connection create return application . The application use connection perform work database return object back pool . The connection available next connection request . Connection pool promote reuse connection object reduce number time connection object create . Connection pool significantly improve performance database-intensive application create connection object costly term time resource . Now DataSource ConnectionPoolDataSource object deploy , programmer use DataSource object get pooled connection . The code get pooled connection like code get nonpooled connection , show following two line : ctx = new InitialContext ( ) ; ds = ( DataSource ) ctx.lookup ( `` jdbc/fastCoffeeDB '' ) ; The variable represent DataSource object produce pooled connection database COFFEEBREAK . You need retrieve DataSource object use produce many pooled connection need . Calling method getConnection variable automatically produce pooled connection DataSource object variable represent configure produce pooled connection . Connection pooling generally transparent programmer . There two thing need use pooled connection : Use DataSource object rather DriverManager class get connection . In following line code , DataSource object implement deploy create pooled connection username password variable represent credential user access database : Connection con = ds.getConnection ( username , password ) ; Use finally statement close pooled connection . The follow finally block would appear try/catch block apply code pooled connection use : try { Connection con = ds.getConnection ( username , password ) ; // ... code use pooled // connection con } catch ( Exception ex { // ... code handle exception } finally { ( con ! = null ) con.close ( ) ; } Otherwise , application use pooled connection identical application use regular connection . The thing application programmer might notice connection pooling performance well . The following sample code get DataSource object produce connection database COFFEEBREAK use update price table COFFEES : import java.sql . * ; import javax.sql . * ; import javax.ejb . * ; import javax.naming . * ; public class ConnectionPoolingBean implement SessionBean { // ... public void ejbCreate ( ) throw CreateException { ctx = new InitialContext ( ) ; ds = ( DataSource ) ctx.lookup ( `` jdbc/fastCoffeeDB '' ) ; } public void updatePrice ( float price , String cofName , String username , String password ) throw SQLException { Connection con ; PreparedStatement pstmt ; try { con = ds.getConnection ( username , password ) ; con.setAutoCommit ( false ) ; pstmt = con.prepareStatement ( `` UPDATE COFFEES `` + `` SET PRICE = ? `` + `` WHERE COF_NAME = ? `` ) ; pstmt.setFloat ( 1 , price ) ; pstmt.setString ( 2 , cofName ) ; pstmt.executeUpdate ( ) ; con.commit ( ) ; pstmt.close ( ) ; } finally { ( con ! = null ) con.close ( ) ; } } private DataSource = null ; private Context ctx = null ; } The connection code sample participates connection pooling following true : An instance class implement ConnectionPoolDataSource deploy . An instance class implement DataSource deploy , value set dataSourceName property logical name bind previously deploy ConnectionPoolDataSource object . Note although code similar code see , different following way : It import javax.sql , javax.ejb , javax.naming package addition java.sql . The DataSource ConnectionPoolDataSource interface javax.sql package , JNDI constructor InitialContext method Context.lookup part javax.naming package . This particular example code form EJB component use API javax.ejb package . The purpose example show use pooled connection way use nonpooled connection , need worry understand EJB API . It use DataSource object get connection instead use DriverManager facility . It use finally block ensure connection close . Getting use pooled connection similar get use regular connection . When someone act system administrator deploy ConnectionPoolDataSource object DataSource object properly , application use DataSource object get pooled connection . An application , however , use finally block close pooled connection . For simplicity , precede example use finally block catch block . If exception throw method try block , throw default , finally clause execute case . Deploying Distributed Transactions DataSource object deploy get connection use distributed transaction . As connection pooling , two different class instance must deploy : XADataSource object DataSource object implement work . Suppose EJB server The Coffee Break entrepreneur buy include DataSource class com.applogic.TransactionalDS , work XADataSource class com.dbaccess.XATransactionalDS . The fact work XADataSource class make EJB server portable across JDBC driver . When DataSource XADataSource object deploy , connection produce able participate distributed transaction . In case , class com.applogic.TransactionalDS implement connection produce also pooled connection , usually case DataSource class provide part EJB server implementation . The XADataSource object must deploy first . The following code create instance com.dbaccess.XATransactionalDS set property : com.dbaccess.XATransactionalDS xads = new com.dbaccess.XATransactionalDS ( ) ; xads.setServerName ( `` creamer '' ) ; xads.setDatabaseName ( `` COFFEEBREAK '' ) ; xads.setPortNumber ( 9040 ) ; xads.setDescription ( `` Distributed transaction COFFEEBREAK DBMS '' ) ; The following code register com.dbaccess.XATransactionalDS object xads JNDI naming service . Note logical name associate xads subcontext xa add jdbc . Oracle recommend logical name instance class com.dbaccess.XATransactionalDS always begin jdbc/xa . Context ctx = new InitialContext ( ) ; ctx.bind ( `` jdbc/xa/distCoffeeDB '' , xads ) ; Next , DataSource object implement interact xads XADataSource object deploy . Note DataSource class , com.applogic.TransactionalDS , work XADataSource class JDBC driver vendor . Deploying DataSource object involve create instance com.applogic.TransactionalDS class set property . The dataSourceName property set jdbc/xa/distCoffeeDB , logical name associate com.dbaccess.XATransactionalDS . This XADataSource class implement distributed transaction capability DataSource class . The following code deploy instance DataSource class : com.applogic.TransactionalDS = new com.applogic.TransactionalDS ( ) ; ds.setDescription ( `` Produces distributed transaction `` + `` connection COFFEEBREAK '' ) ; ds.setDataSourceName ( `` jdbc/xa/distCoffeeDB '' ) ; Context ctx = new InitialContext ( ) ; ctx.bind ( `` jdbc/distCoffeeDB '' , ) ; Now instance class com.applogic.TransactionalDS com.dbaccess.XATransactionalDS deploy , application call method getConnection instance TransactionalDS class get connection COFFEEBREAK database use distributed transaction . Using Connections Distributed Transactions To get connection use distributed transaction , must use DataSource object properly implement deploy , show section Deploying Distributed Transactions . With DataSource object , call method getConnection . After connection , use would use connection . Because jdbc/distCoffeesDB associate XADataSource object JNDI naming service , following code produce Connection object use distributed transaction : Context ctx = new InitialContext ( ) ; DataSource = ( DataSource ) ctx.lookup ( `` jdbc/distCoffeesDB '' ) ; Connection con = ds.getConnection ( ) ; There minor important restriction connection use part distributed transaction . A transaction manager control distributed transaction begin commit roll back ; therefore , application code never call method Connection.commit Connection.rollback . An application likewise never call Connection.setAutoCommit ( true ) , enable auto-commit mode , would also interfere transaction manager 's control transaction boundary . This explain new connection create scope distributed transaction auto-commit mode disable default . Note restriction apply connection participate distributed transaction ; restriction connection part distributed transaction . For following example , suppose order coffee ship , trigger update two table reside different DBMS server . The first table new INVENTORY table , second COFFEES table . Because table different DBMS server , transaction involve distributed transaction . The code following example , obtain connection , update COFFEES table , close connection , second part distributed transaction . Note code explicitly commit roll back update scope distributed transaction control middle tier server 's underlying system infrastructure . Also , assume connection use distributed transaction pooled connection , application use finally block close connection . This guarantee valid connection close even exception throw , thereby ensure connection return connection pool recycle . The following code sample illustrate enterprise Bean , class implement method call client computer . The purpose example demonstrate application code distributed transaction different code except call Connection method commit , rollback , setAutoCommit ( true ) . Therefore , need worry understand EJB API use . import java.sql . * ; import javax.sql . * ; import javax.ejb . * ; import javax.naming . * ; public class DistributedTransactionBean implement SessionBean { // ... public void ejbCreate ( ) throw CreateException { ctx = new InitialContext ( ) ; ds = ( DataSource ) ctx.lookup ( `` jdbc/distCoffeesDB '' ) ; } public void updateTotal ( int incr , String cofName , String username , String password ) throw SQLException { Connection con ; PreparedStatement pstmt ; try { con = ds.getConnection ( username , password ) ; pstmt = con.prepareStatement ( `` UPDATE COFFEES `` + `` SET TOTAL = TOTAL + ? `` + `` WHERE COF_NAME = ? `` ) ; pstmt.setInt ( 1 , incr ) ; pstmt.setString ( 2 , cofName ) ; pstmt.executeUpdate ( ) ; stmt.close ( ) ; } finally { ( con ! = null ) con.close ( ) ; } } private DataSource = null ; private Context ctx = null ; }