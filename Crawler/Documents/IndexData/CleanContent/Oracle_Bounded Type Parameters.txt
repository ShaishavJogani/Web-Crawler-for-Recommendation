There may time want restrict type use type argument parameterized type . For example , method operate number might want accept instance Number subclass . This bound type parameter . To declare bounded type parameter , list type parameter 's name , follow extends keyword , follow upper bound , example Number . Note , context , extend use general sense mean either `` extends '' ( class ) `` implement '' ( interface ) . public class Box < T > { private T ; public void set ( T ) { this.t = ; } public T get ( ) { return ; } public < U extend Number > void inspect ( U u ) { System.out.println ( `` T : `` + t.getClass ( ) .getName ( ) ) ; System.out.println ( `` U : `` + u.getClass ( ) .getName ( ) ) ; } public static void main ( String [ ] args ) { Box < Integer > integerBox = new Box < Integer > ( ) ; integerBox.set ( new Integer ( 10 ) ) ; integerBox.inspect ( `` text '' ) ; // error : still String ! } } By modify generic method include bounded type parameter , compilation fail , since invocation inspect still include String : Box.java:21 : < U > inspect ( U ) Box < java.lang.Integer > apply ( java.lang.String ) integerBox.inspect ( `` 10 '' ) ; ^ 1 error In addition limit type use instantiate generic type , bound type parameter allow invoke method define bound : public class NaturalNumber < T extend Integer > { private T n ; public NaturalNumber ( T n ) { this.n = n ; } public boolean isEven ( ) { return n.intValue ( ) % 2 == 0 ; } // ... } The isEven method invoke intValue method define Integer class n. Multiple Bounds The precede example illustrate use type parameter single bound , type parameter multiple bound : < T extend B1 & B2 & B3 > A type variable multiple bound subtype type list bound . If one bound class , must specify first . For example : Class A { /* ... */ } interface B { /* ... */ } interface C { /* ... */ } class D < T extend A & B & C > { /* ... */ } If bind A specify first , get compile-time error : class D < T extend B & A & C > { /* ... */ } // compile-time error