The Java platform store character value use Unicode convention . Character stream I/O automatically translate internal format local character set . In Western locale , local character set usually 8-bit superset ASCII . For application , I/O character stream complicated I/O byte stream . Input output stream class automatically translate local character set . A program use character stream place byte stream automatically adapt local character set ready internationalization â€” without extra effort programmer . If internationalization n't priority , simply use character stream class without pay much attention character set issue . Later , internationalization become priority , program adapt without extensive recoding . See Internationalization trail information . Using Character Streams All character stream class descend Reader Writer . As byte stream , character stream class specialize file I/O : FileReader FileWriter . The CopyCharacters example illustrate class . import java.io.FileReader ; import java.io.FileWriter ; import java.io.IOException ; public class CopyCharacters { public static void main ( String [ ] args ) throw IOException { FileReader inputStream = null ; FileWriter outputStream = null ; try { inputStream = new FileReader ( `` xanadu.txt '' ) ; outputStream = new FileWriter ( `` characteroutput.txt '' ) ; int c ; ( ( c = inputStream.read ( ) ) ! = -1 ) { outputStream.write ( c ) ; } } finally { ( inputStream ! = null ) { inputStream.close ( ) ; } ( outputStream ! = null ) { outputStream.close ( ) ; } } } } CopyCharacters similar CopyBytes . The important difference CopyCharacters use FileReader FileWriter input output place FileInputStream FileOutputStream . Notice CopyBytes CopyCharacters use int variable read write . However , CopyCharacters , int variable hold character value last 16 bit ; CopyBytes , int variable hold byte value last 8 bit . Character Streams Use Byte Streams Character stream often `` wrapper '' byte stream . The character stream use byte stream perform physical I/O , character stream handle translation character byte . FileReader , example , use FileInputStream , FileWriter use FileOutputStream . There two general-purpose byte-to-character `` bridge '' stream : InputStreamReader OutputStreamWriter . Use create character stream prepackaged character stream class meet need . The socket lesson networking trail show create character stream byte stream provide socket class . Line-Oriented I/O Character I/O usually occur big unit single character . One common unit line : string character line terminator end . A line terminator carriage-return/line-feed sequence ( `` \r\n '' ) , single carriage-return ( `` \r '' ) , single line-feed ( `` \n '' ) . Supporting possible line terminator allow program read text file create widely use operate system . Let 's modify CopyCharacters example use line-oriented I/O . To , use two class n't see , BufferedReader PrintWriter . We 'll explore class great depth Buffered I/O Formatting . Right , 're interested support line-oriented I/O . The CopyLines example invokes BufferedReader.readLine PrintWriter.println input output one line time . import java.io.FileReader ; import java.io.FileWriter ; import java.io.BufferedReader ; import java.io.PrintWriter ; import java.io.IOException ; public class CopyLines { public static void main ( String [ ] args ) throw IOException { BufferedReader inputStream = null ; PrintWriter outputStream = null ; try { inputStream = new BufferedReader ( new FileReader ( `` xanadu.txt '' ) ) ; outputStream = new PrintWriter ( new FileWriter ( `` characteroutput.txt '' ) ) ; String l ; ( ( l = inputStream.readLine ( ) ) ! = null ) { outputStream.println ( l ) ; } } finally { ( inputStream ! = null ) { inputStream.close ( ) ; } ( outputStream ! = null ) { outputStream.close ( ) ; } } } } Invoking readLine return line text line . CopyLines output line use println , append line terminator current operating system . This might line terminator use input file . There many way structure text input output beyond character line . For information , see Scanning Formatting .