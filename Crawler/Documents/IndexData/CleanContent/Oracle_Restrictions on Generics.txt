To use Java generic effectively , must consider following restriction : Can Instantiate Generic Types Primitive Types Can Create Instances Type Parameters Can Declare Static Fields Whose Types Type Parameters Can Use Casts instanceof With Parameterized Types Can Create Arrays Parameterized Types Can Create , Catch , Throw Objects Parameterized Types Can Overload Method Where Formal Parameter Types Each Overload Erase Same Raw Type Can Instantiate Generic Types Primitive Types Consider follow parameterized type : class Pair < K , V > { private K key ; private V value ; public Pair ( K key , V value ) { this.key = key ; this.value = value ; } // ... } When create Pair object , substitute primitive type type parameter K V : Pair < int , char > p = new Pair < > ( 8 , 'a ' ) ; // compile-time error You substitute non-primitive type type parameter K V : Pair < Integer , Character > p = new Pair < > ( 8 , 'a ' ) ; Note Java compiler autoboxes 8 Integer.valueOf ( 8 ) 'a ' Character ( 'a ' ) : Pair < Integer , Character > p = new Pair < > ( Integer.valueOf ( 8 ) , new Character ( 'a ' ) ) ; For information autoboxing , see Autoboxing Unboxing Numbers Strings lesson . Can Create Instances Type Parameters You create instance type parameter . For example , following code cause compile-time error : public static < E > void append ( List < E > list ) { E elem = new E ( ) ; // compile-time error list.add ( elem ) ; } As workaround , create object type parameter reflection : public static < E > void append ( List < E > list , Class < E > cl ) throw Exception { E elem = cls.newInstance ( ) ; // OK list.add ( elem ) ; } You invoke append method follow : List < String > ls = new ArrayList < > ( ) ; append ( ls , String.class ) ; Can Declare Static Fields Whose Types Type Parameters A class 's static field class-level variable share non-static object class . Hence , static field type parameter allow . Consider following class : public class MobileDevice < T > { private static T ; // ... } If static field type parameter allow , following code would confuse : MobileDevice < Smartphone > phone = new MobileDevice < > ( ) ; MobileDevice < Pager > pager = new MobileDevice < > ( ) ; MobileDevice < TabletPC > pc = new MobileDevice < > ( ) ; Because static field share phone , pager , pc , actual type ? It Smartphone , Pager , TabletPC time . You , therefore , create static field type parameter . Can Use Casts instanceof Parameterized Types Because Java compiler erase type parameter generic code , verify parameterized type generic type use runtime : public static < E > void rtti ( List < E > list ) { ( list instanceof ArrayList < Integer > ) { // compile-time error // ... } } The set parameterized type pass rtti method : S = { ArrayList < Integer > , ArrayList < String > LinkedList < Character > , ... } The runtime keep track type parameter , tell difference ArrayList < Integer > ArrayList < String > . The use unbounded wildcard verify list ArrayList : public static void rtti ( List < ? > list ) { ( list instanceof ArrayList < ? > ) { // OK ; instanceof require reifiable type // ... } } Typically , cast parameterized type unless parameterized unbounded wildcards . For example : List < Integer > li = new ArrayList < > ( ) ; List < Number > ln = ( List < Number > ) li ; // compile-time error However , case compiler know type parameter always valid allow cast . For example : List < String > l1 = ... ; ArrayList < String > l2 = ( ArrayList < String > ) l1 ; // OK Can Create Arrays Parameterized Types You create array parameterized type . For example , following code compile : List < Integer > [ ] arrayOfLists = new List < Integer > [ 2 ] ; // compile-time error The following code illustrate happen different type insert array : Object [ ] string = new String [ 2 ] ; string [ 0 ] = `` hi '' ; // OK string [ 1 ] = 100 ; // An ArrayStoreException throw . If try thing generic list , would problem : Object [ ] stringLists = new List < String > [ ] ; // compiler error , pretend 's allow stringLists [ 0 ] = new ArrayList < String > ( ) ; // OK stringLists [ 1 ] = new ArrayList < Integer > ( ) ; // An ArrayStoreException throw , // runtime ca n't detect . If array parameterized list allow , previous code would fail throw desired ArrayStoreException . Can Create , Catch , Throw Objects Parameterized Types A generic class extend Throwable class directly indirectly . For example , following class compile : // Extends Throwable indirectly class MathException < T > extend Exception { /* ... */ } // compile-time error // Extends Throwable directly class QueueFullException < T > extend Throwable { /* ... */ // compile-time error A method catch instance type parameter : public static < T extend Exception , J > void execute ( List < J > job ) { try { ( J job : job ) // ... } catch ( T e ) { // compile-time error // ... } } You , however , use type parameter throws clause : class Parser < T extend Exception > { public void parse ( File file ) throw T { // OK // ... } } Can Overload Method Where Formal Parameter Types Each Overload Erase Same Raw Type A class two overload method signature type erasure . public class Example { public void print ( Set < String > strSet ) { } public void print ( Set < Integer > intSet ) { } } The overload would share classfile representation generate compile-time error .