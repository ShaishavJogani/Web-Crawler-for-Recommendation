Note : MySQL currently support user-defined type . MySQL Java DB currently support structured type , DISTINCT SQL data type . No JDBC tutorial example available demonstrate feature describe section . With business booming , owner The Coffee Break regularly add new store make change database . The owner decide use custom mapping structured type ADDRESS . This enable owner make change Java class map ADDRESS type . The Java class field attribute ADDRESS . The name class name field valid Java identifier . The following topic cover : Implementing SQLData Using Connection 's Type Map Using Your Own Type Map Implementing SQLData The first thing require custom mapping create class implement interface SQLData . The SQL definition structured type ADDRESS look like : CREATE TYPE ADDRESS ( NUM INTEGER , STREET VARCHAR ( 40 ) , CITY VARCHAR ( 40 ) , STATE CHAR ( 2 ) , ZIP CHAR ( 5 ) ) ; A class implement SQLData interface custom mapping ADDRESS type might look like : public class Address implement SQLData { public int num ; public String street ; public String city ; public String state ; public String zip ; private String sql_type ; public String getSQLTypeName ( ) { return sql_type ; } public void readSQL ( SQLInput stream , String type ) throw SQLException { sql_type = type ; num = stream.readInt ( ) ; street = stream.readString ( ) ; city = stream.readString ( ) ; state = stream.readString ( ) ; zip = stream.readString ( ) ; } public void writeSQL ( SQLOutput stream ) throw SQLException { stream.writeInt ( num ) ; stream.writeString ( street ) ; stream.writeString ( city ) ; stream.writeString ( state ) ; stream.writeString ( zip ) ; } } Using Connection 's Type Map After write class implement interface SQLData , thing set custom mapping make entry type map . For example , mean enter fully qualified SQL name ADDRESS type Class object class Address . A type map , instance java.util.Map interface , associate every new connection create , use one . Assuming con active connection , following code fragment add entry UDT ADDRESS type map associate con . java.util.Map map = con.getTypeMap ( ) ; map.put ( `` SchemaName.ADDRESS '' , Class.forName ( `` Address '' ) ) ; con.setTypeMap ( map ) ; Whenever call getObject method retrieve instance ADDRESS type , driver check type map associate connection see entry ADDRESS . The driver note Class object Address class , create instance , many thing background map ADDRESS Address . You anything generate class mapping make entry type map let driver know custom mapping . The driver rest . The situation similar store structured type custom mapping . When call method setObject , driver check see value set instance class implement interface SQLData . If ( mean custom mapping ) , driver use custom mapping convert value SQL counterpart return database . Again , driver custom mapping behind scene ; need supply method setObject parameter custom mapping . You see example later section . Look difference work standard mapping , Struct object , custom mapping , class Java programming language . The following code fragment show standard mapping Struct object , map driver use entry connection 's type map . ResultSet r = stmt.executeQuery ( `` SELECT LOCATION `` + `` WHERE STORE_NO = 100003 '' ) ; rs.next ( ) ; Struct address = ( Struct ) rs.getObject ( `` LOCATION '' ) ; The variable address contain following attribute value : 4344 , `` First_Street '' , `` Verona '' , `` CA '' , `` 94545 '' . The following code fragment show happen entry structured type ADDRESS connection 's type map . Remember column LOCATION store value type ADDRESS . ResultSet r = stmt.executeQuery ( `` SELECT LOCATION `` + `` WHERE STORE_NO = 100003 '' ) ; rs.next ( ) ; Address store_3 = ( Address ) rs.getObject ( `` LOCATION '' ) ; The variable store_3 instance class Address , attribute value current value one field Address . Note must remember convert object retrieve getObject method Address object assign store_3 . Note also store_3 must Address object . Compare work Struct object work instance Address class . Suppose store move good location neighboring town therefore must update database . With custom mapping , reset field store_3 , following code fragment : ResultSet r = stmt.executeQuery ( `` SELECT LOCATION `` + `` WHERE STORE_NO = 100003 '' ) ; rs.next ( ) ; Address store_3 = ( Address ) rs.getObject ( `` LOCATION '' ) ; store_3.num = 1800 ; store_3.street = `` Artsy_Alley '' ; store_3.city = `` Arden '' ; store_3.state = `` CA '' ; store_3.zip = `` 94546 '' ; PreparedStatement pstmt = con.prepareStatement ( `` UPDATE STORES `` + `` SET LOCATION = ? `` + `` WHERE STORE_NO = 100003 '' ) ; pstmt.setObject ( 1 , store_3 ) ; pstmt.executeUpdate ( ) ; Values column LOCATION instance ADDRESS type . The driver check connection 's type map see entry link ADDRESS class Address consequently use custom mapping indicate Address . When code call method setObject variable store_3 second parameter , driver check see store_3 represent instance class Address , implement interface SQLData structured type ADDRESS , automatically use custom mapping . Without custom mapping ADDRESS , update would look like : PreparedStatement pstmt = con.prepareStatement ( `` UPDATE STORES `` + `` SET LOCATION.NUM = 1800 , `` + `` LOCATION.STREET = 'Artsy_Alley ' , `` + `` LOCATION.CITY = 'Arden ' , `` + `` LOCATION.STATE = 'CA ' , `` + `` LOCATION.ZIP = '94546 ' `` + `` WHERE STORE_NO = 100003 '' ) ; pstmt.executeUpdate ; Using Your Own Type Map Up point , use type map associate connection custom mapping . Ordinarily , type map programmer use . However , also possible create type map pas certain method driver use type map instead one associate connection . This allow two different mapping user-defined type ( UDT ) . In fact , possible multiple custom mapping UDT , long mapping set class implement SQLData interface entry type map . If pass type map method accept one , driver default use type map associate connection . There situation call use type map one associate connection . It could necessary supply method type map , instance , several programmer work JDBC application bring component together use connection . If two programmer create custom mapping SQL UDT , would need supply type map , thus override connection 's type map .