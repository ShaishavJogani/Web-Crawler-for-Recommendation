Do need create application recursively visit file file tree ? Perhaps need delete every .class file tree , find every file n't access last year . You FileVisitor interface . This section cover following : The FileVisitor Interface Kickstarting Process Considerations When Creating FileVisitor Controlling Flow Examples The FileVisitor Interface To walk file tree , first need implement FileVisitor . A FileVisitor specify required behavior key point traversal process : file visit , directory access , directory access , failure occur . The interface four method correspond situation : preVisitDirectory – Invoked directory 's entry visit . postVisitDirectory – Invoked entry directory visit . If error encounter , specific exception pass method . visitFile – Invoked file visit . The file 's BasicFileAttributes pass method , use file attribute package read specific set attribute . For example , choose read file 's DosFileAttributeView determine file `` hidden '' bit set . visitFileFailed – Invoked file access . The specific exception pass method . You choose whether throw exception , print console log file , . If n't need implement four FileVisitor method , instead implement FileVisitor interface , extend SimpleFileVisitor class . This class , implement FileVisitor interface , visit file tree throw IOError error encounter . You extend class override method require . Here example extend SimpleFileVisitor print entry file tree . It print entry whether entry regular file , symbolic link , directory , `` unspecified '' type file . It also print size , byte , file . Any exception encounter print console . The FileVisitor method show bold : import static java.nio.file.FileVisitResult . * ; public static class PrintFiles extend SimpleFileVisitor < Path > { // Print information // type file . @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attr ) { ( attr.isSymbolicLink ( ) ) { System.out.format ( `` Symbolic link : % `` , file ) ; } else ( attr.isRegularFile ( ) ) { System.out.format ( `` Regular file : % `` , file ) ; } else { System.out.format ( `` Other : % `` , file ) ; } System.out.println ( `` ( `` + attr.size ( ) + `` byte ) '' ) ; return CONTINUE ; } // Print directory visit . @ Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) { System.out.format ( `` Directory : % % n '' , dir ) ; return CONTINUE ; } // If error access // file , let user know . // If n't override method // error occur , IOException // throw . @ Override public FileVisitResult visitFileFailed ( Path file , IOException exc ) { System.err.println ( exc ) ; return CONTINUE ; } } Kickstarting Process Once implement FileVisitor , initiate file walk ? There two walkFileTree method Files class . walkFileTree ( Path , FileVisitor ) walkFileTree ( Path , Set < FileVisitOption > , int , FileVisitor ) The first method require starting point instance FileVisitor . You invoke PrintFiles file visitor follow : Path startingDir = ... ; PrintFiles pf = new PrintFiles ( ) ; Files.walkFileTree ( startingDir , pf ) ; The second walkFileTree method enable additionally specify limit number level visit set FileVisitOption enums . If want ensure method walk entire file tree , specify Integer.MAX_VALUE maximum depth argument . You specify FileVisitOption enum , FOLLOW_LINKS , indicate symbolic link follow . This code snippet show four-argument method invoke : import static java.nio.file.FileVisitResult . * ; Path startingDir = ... ; EnumSet < FileVisitOption > opt = EnumSet.of ( FOLLOW_LINKS ) ; Finder finder = new Finder ( pattern ) ; Files.walkFileTree ( startingDir , opts , Integer.MAX_VALUE , finder ) ; Considerations When Creating FileVisitor A file tree walk depth first , make assumption iteration order subdirectory visit . If program change file system , need carefully consider implement FileVisitor . For example , write recursive delete , first delete file directory delete directory . In case , delete directory postVisitDirectory . If write recursive copy , create new directory preVisitDirectory attempt copy file ( visitFiles ) . If want preserve attribute source directory ( similar UNIX cp -p command ) , need file copy , postVisitDirectory . The Copy example show . If write file search , perform comparison visitFile method . This method find file match criterion , find directory . If want find file directory , must also perform comparison either preVisitDirectory postVisitDirectory method . The Find example show . You need decide whether want symbolic link follow . If delete file , example , follow symbolic link might advisable . If copy file tree , might want allow . By default , walkFileTree follow symbolic link . The visitFile method invoke file . If specify FOLLOW_LINKS option file tree circular link parent directory , loop directory report visitFileFailed method FileSystemLoopException . The following code snippet show catch circular link Copy example : @ Override public FileVisitResult visitFileFailed ( Path file , IOException exc ) { ( exc instanceof FileSystemLoopException ) { System.err.println ( `` cycle detect : `` + file ) ; } else { System.err.format ( `` Unable copy : '' + `` % : % % n '' , file , exc ) ; } return CONTINUE ; } This case occur program follow symbolic link . Controlling Flow Perhaps want walk file tree look particular directory , find , want process terminate . Perhaps want skip specific directory . The FileVisitor method return FileVisitResult value . You abort file walk process control whether directory visit value return FileVisitor method : CONTINUE – Indicates file walking continue . If preVisitDirectory method return CONTINUE , directory visit . TERMINATE – Immediately abort file walking . No file walk method invoke value return . SKIP_SUBTREE – When preVisitDirectory return value , specified directory subdirectory skip . This branch `` prune '' tree . SKIP_SIBLINGS – When preVisitDirectory return value , specified directory visit , postVisitDirectory invoke , far unvisited sibling visit . If return postVisitDirectory method , sibling visit . Essentially , nothing happen specified directory . In code snippet , directory name SCCS skip : import static java.nio.file.FileVisitResult . * ; public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { ( ( dir.getFileName ( ) .toString ( ) .equals ( `` SCCS '' ) ) { return SKIP_SUBTREE ; } return CONTINUE ; } In code snippet , soon particular file locate , file name print standard output , file walk terminates : import static java.nio.file.FileVisitResult . * ; // The file look . Path lookingFor = ... ; public FileVisitResult visitFile ( Path file , BasicFileAttributes attr ) { ( file.getFileName ( ) .equals ( lookingFor ) ) { System.out.println ( `` Located file : `` + file ) ; return TERMINATE ; } return CONTINUE ; } Examples The following example demonstrate file walk mechanism : Find – Recurses file tree look file directory match particular glob pattern . This example discuss Finding Files . Chmod – Recursively change permission file tree ( POSIX system ) . Copy – Recursively copy file tree . WatchDir – Demonstrates mechanism watch directory file create , delete modify . Calling program -r option watch entire tree change . For information file notification service , see Watching Directory Changes .