The section Type Erasure discuss process compiler remove information relate type parameter type argument . Type erasure consequence relate variable argument ( also know varargs ) method whose varargs formal parameter non-reifiable type . See section Arbitrary Number Arguments Passing Information Method Constructor information varargs method . This page cover following topic : Non-Reifiable Types Heap Pollution Potential Vulnerabilities Varargs Methods Non-Reifiable Formal Parameters Preventing Warnings Varargs Methods Non-Reifiable Formal Parameters Non-Reifiable Types A reifiable type type whose type information fully available runtime . This include primitive , non-generic type , raw type , invocation unbound wildcards . Non-reifiable type type information remove compile-time type erasure â€” invocation generic type define unbounded wildcards . A non-reifiable type information available runtime . Examples non-reifiable type List < String > List < Number > ; JVM tell difference type runtime . As show Restrictions Generics , certain situation non-reifiable type use : instanceof expression , example , element array . Heap Pollution Heap pollution occur variable parameterized type refers object parameterized type . This situation occur program perform operation give rise unchecked warning compile-time . An unchecked warning generate , either compile-time ( within limit compile-time type checking rule ) runtime , correctness operation involve parameterized type ( example , cast method call ) verify . For example , heap pollution occur mix raw type parameterized type , perform unchecked cast . In normal situation , code compile time , compiler issue unchecked warning draw attention potential heap pollution . If compile section code separately , difficult detect potential risk heap pollution . If ensure code compiles without warning , heap pollution occur . Potential Vulnerabilities Varargs Methods Non-Reifiable Formal Parameters Generic method include vararg input parameter cause heap pollution . Consider following ArrayBuilder class : public class ArrayBuilder { public static < T > void addToList ( List < T > listArg , T ... element ) { ( T x : element ) { listArg.add ( x ) ; } } public static void faultyMethod ( List < String > ... l ) { Object [ ] objectArray = l ; // Valid objectArray [ 0 ] = Arrays.asList ( 42 ) ; String = l [ 0 ] .get ( 0 ) ; // ClassCastException thrown } } The following example , HeapPollutionExample use ArrayBuiler class : public class HeapPollutionExample { public static void main ( String [ ] args ) { List < String > stringListA = new ArrayList < String > ( ) ; List < String > stringListB = new ArrayList < String > ( ) ; ArrayBuilder.addToList ( stringListA , `` Seven '' , `` Eight '' , `` Nine '' ) ; ArrayBuilder.addToList ( stringListB , `` Ten '' , `` Eleven '' , `` Twelve '' ) ; List < List < String > > listOfStringLists = new ArrayList < List < String > > ( ) ; ArrayBuilder.addToList ( listOfStringLists , stringListA , stringListB ) ; ArrayBuilder.faultyMethod ( Arrays.asList ( `` Hello ! `` ) , Arrays.asList ( `` World ! `` ) ) ; } } When compile , following warning produce definition ArrayBuilder.addToList method : warning : [ varargs ] Possible heap pollution parameterized vararg type T When compiler encounter varargs method , translate varargs formal parameter array . However , Java programming language permit creation array parameterized type . In method ArrayBuilder.addToList , compiler translate varargs formal parameter T ... elements formal parameter T [ ] element , array . However , type erasure , compiler convert varargs formal parameter Object [ ] element . Consequently , possibility heap pollution . The following statement assigns varargs formal parameter l Object array objectArgs : Object [ ] objectArray = l ; This statement potentially introduce heap pollution . A value match parameterized type varargs formal parameter l assign variable objectArray , thus assign l. However , compiler generate unchecked warning statement . The compiler already generate warning translate varargs formal parameter List < String > ... l formal parameter List [ ] l. This statement valid ; variable l type List [ ] , subtype Object [ ] . Consequently , compiler issue warning error assign List object type array component objectArray array show statement : objectArray [ 0 ] = Arrays.asList ( 42 ) ; This statement assign first array component objectArray array List object contain one object type Integer . Suppose invoke ArrayBuilder.faultyMethod following statement : ArrayBuilder.faultyMethod ( Arrays.asList ( `` Hello ! `` ) , Arrays.asList ( `` World ! `` ) ) ; At runtime , JVM throw ClassCastException following statement : // ClassCastException thrown String = l [ 0 ] .get ( 0 ) ; The object store first array component variable l type List < Integer > , statement expect object type List < String > . Prevent Warnings Varargs Methods Non-Reifiable Formal Parameters If declare varargs method parameter parameterized type , ensure body method throw ClassCastException similar exception due improper handling varargs formal parameter , prevent warning compiler generate kind varargs method add following annotation static non-constructor method declaration : @ SafeVarargs The @ SafeVarargs annotation documented part method 's contract ; annotation assert implementation method improperly handle varargs formal parameter . It also possible , though less desirable , suppress warning add follow method declaration : @ SuppressWarnings ( { `` unchecked '' , `` varargs '' } ) However , approach suppress warning generate method 's call site . If unfamiliar @ SuppressWarnings syntax , see Annotations .