The GenSig VerSig program lesson illustrate use JDK Security API generate digital signature data verify signature authentic . However , actual scenario depict program , sender use JDK Security API generate new public/private key pair , sender store encode public key bytes file , receiver read key byte , necessarily realistic , potential major flaw . In many case key need generate ; already exist , either encoded key file entry keystore . The potential major flaw nothing guarantee authenticity public key receiver receive , VerSig program correctly verify authenticity signature public key supply authentic ! Working Encoded Key Bytes Sometimes encode key byte already exist file key pair use signing verification . If 's case GenSig program import encoded private key byte convert PrivateKey need signing , via following , assume name file contain private key byte privkeyfile String byte represent DSA key encode use PKCS # 8 standard . FileInputStream keyfis = new FileInputStream ( privkeyfile ) ; byte [ ] encKey = new byte [ keyfis.available ( ) ] ; keyfis.read ( encKey ) ; keyfis.close ( ) ; PKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec ( encKey ) ; KeyFactory keyFactory = KeyFactory.getInstance ( `` DSA '' ) ; PrivateKey privKey = keyFactory.generatePrivate ( privKeySpec ) ; GenSig longer need save public key byte file , 're already one . In case sender send receiver already exist file contain encoded public key byte ( unless receiver already ) data file signature file export GenSig . The VerSig program remain unchanged , already expect encoded public key byte file . But potential problem malicious user intercept file replace way switch detect ? In case issue , people already exchange public key face face via trusted third party face-to-face exchange . After , multiple subsequent file signature exchange may remotely ( , two people different location ) , public key may use verify authenticity . If malicious user try change data signature , detect VerSig . If face-to-face key exchange possible , try method increase likelihood proper receipt . For example , could send public key via secure method possible prior subsequent exchange data signature file , perhaps use less secure medium . In general , send data signature separately public key greatly reduce likelihood attack . Unless three file change , certain manner discuss next paragraph , VerSig detect tampering . If three file ( data document , public key , signature ) intercept malicious user , person could replace document something else , sign private key , forward replaced document , new signature , public key correspond private key use generate new signature . Then VerSig would report successful verification , 'd think document come original sender . Thus take step ensure least public key receive intact ( VerSig detect tampering file ) , use certificate facilitate authentication public key , describe next section . Working Certificates It common cryptography exchange certificate contain public key rather key . One benefit certificate sign one entity ( issuer ) verify enclosed public key actual public key another entity ( subject owner ) . Typically trusted third-party certification authority ( CA ) verify identity subject vouches owner public key sign certificate . Another benefit use certificate check ensure validity certificate receive verify digital signature , use issuer 's ( signer 's ) public key , may store certificate whose signature verify use public key certificate issuer ; public key may store certificate , , reach public key already trust . If establish trust chain ( perhaps required issuer certificate available ) , certificate fingerprint ( ) calculate . Each fingerprint relatively short number uniquely reliably identify certificate . ( Technically 's hash value certificate information , use message digest , also know one-way hash function . ) You call certificate owner compare fingerprint certificate receive one send . If 're , certificate . It would secure GenSig create certificate contain public key VerSig import certificate extract public key . However , JDK public certificate APIs would allow create certificate public key , GenSig program create certificate public key generate . ( There public APIs extract public key certificate , though . ) If want , use various security tool , APIs , sign important document ( ) work certificate keystore , Exchanging Files lesson . Alternatively use API modify program work already exist private key correspond public key ( certificate ) keystore . To start , modify GenSig program extract private key keystore rather generate new key . First , let 's assume following : The keystore name String ksName The keystore type `` JKS '' , proprietary type Oracle . The keystore password char array spass The alias keystore entry contain private key , public key certificate String alias The private key password char array kpass Then extract private key keystore via following . KeyStore k = KeyStore.getInstance ( `` JKS '' ) ; FileInputStream ksfis = new FileInputStream ( ksName ) ; BufferedInputStream ksbufin = new BufferedInputStream ( ksfis ) ; ks.load ( ksbufin , spa ) ; PrivateKey priv = ( PrivateKey ) ks.getKey ( alias , kpass ) ; You extract public key certificate keystore save encoded byte file name suecert , via following . java.security.cert.Certificate cert = ks.getCertificate ( alias ) ; byte [ ] encodedCert = cert.getEncoded ( ) ; // Save certificate file name `` suecert '' FileOutputStream certfos = new FileOutputStream ( `` suecert '' ) ; certfos.write ( encodedCert ) ; certfos.close ( ) ; Then send data file , signature , certificate receiver . The receiver verifes authenticity certificate first get certificate 's fingerprint , via keytool -printcert command . keytool -printcert -file suecert Owner : CN=Susan Jones , OU=Purchasing , O=ABC , L=Cupertino , ST=CA , C=US Issuer : CN=Susan Jones , OU=Purchasing , O=ABC , L=Cupertino , ST=CA , C=US Serial number : 35aaed17 Valid : Mon Jul 13 22:31:03 PDT 1998 : Sun Oct 11 22:31:03 PDT 1998 Certificate fingerprint : MD5 : 1E : B8:04:59:86:7A:78:6B:40 : AC:64:89:2C:0F : DD:13 SHA1 : 1C:79 : BD:26 : A1:34 : C0:0A:30:63:11:6A : F2 : B9:67 : DF : E5:8D:7B:5E Then receiver verify fingerprint , perhaps call sender compare sender 's certificate look public repository . The receiver 's verification program ( modify VerSig ) import certificate extract public key via following , assume certificate file name ( example , suecert ) String certName . FileInputStream certfis = new FileInputStream ( certName ) ; java.security.cert.CertificateFactory cf = java.security.cert.CertificateFactory.getInstance ( `` X.509 '' ) ; java.security.cert.Certificate cert = cf.generateCertificate ( certfis ) ; PublicKey pub = cert.getPublicKey ( ) ; Ensuring Data Confidentiality Suppose want keep content data confidential people accidentally maliciously try view transit ( machine disk ) . To keep data confidential , encrypt store send encryption result ( refer ciphertext ) . The receiver decrypt ciphertext obtain copy original data .