A List l may sort follow . Collections.sort ( l ) ; If List consist String element , sort alphabetical order . If consist Date element , sort chronological order . How happen ? String Date implement Comparable interface . Comparable implementation provide natural ordering class , allow object class sort automatically . The follow table summarize important Java platform class implement Comparable . Classes Implementing Comparable Class Natural Ordering Byte Signed numerical Character Unsigned numerical Long Signed numerical Integer Signed numerical Short Signed numerical Double Signed numerical Float Signed numerical BigInteger Signed numerical BigDecimal Signed numerical Boolean Boolean.FALSE < Boolean.TRUE File System-dependent lexicographic path name String Lexicographic Date Chronological CollationKey Locale-specific lexicographic If try sort list , element implement Comparable , Collections.sort ( list ) throw ClassCastException . Similarly , Collections.sort ( list , comparator ) throw ClassCastException try sort list whose element compare one another use comparator . Elements compare one another call mutually comparable . Although element different type may mutually comparable , none class list permit interclass comparison . This really need know Comparable interface want sort list comparable element create sorted collection . The next section interest want implement Comparable type . Writing Your Own Comparable Types The Comparable interface consist following method . public interface Comparable < T > { public int compareTo ( T ) ; } The compareTo method compare receive object specify object return negative integer , 0 , positive integer depend whether receiving object less , equal , great specified object . If specify object compare receiving object , method throw ClassCastException . The following class represent person 's name implement Comparable . import java.util . * ; public class Name implement Comparable < Name > { private final String firstName , lastName ; public Name ( String firstName , String lastName ) { ( firstName == null || lastName == null ) throw new NullPointerException ( ) ; this.firstName = firstName ; this.lastName = lastName ; } public String firstName ( ) { return firstName ; } public String lastName ( ) { return lastName ; } public boolean equal ( Object ) { ( ! ( instanceof Name ) ) return false ; Name n = ( Name ) ; return n.firstName.equals ( firstName ) & & n.lastName.equals ( lastName ) ; } public int hashCode ( ) { return 31*firstName.hashCode ( ) + lastName.hashCode ( ) ; } public String toString ( ) { return firstName + `` `` + lastName ; } public int compareTo ( Name n ) { int lastCmp = lastName.compareTo ( n.lastName ) ; return ( lastCmp ! = 0 ? lastCmp : firstName.compareTo ( n.firstName ) ) ; } } To keep precede example short , class somewhat limited : It n't support middle name , demand first last name , internationalize way . Nonetheless , illustrate following important point : Name object immutable . All thing equal , immutable type way go , especially object use element Sets key Maps . These collection break modify element key 're collection . The constructor check argument null . This ensure Name object well form none method ever throw NullPointerException . The hashCode method redefine . This essential class redefine equal method . ( Equal object must equal hash code . ) The equal method return false specified object null inappropriate type . The compareTo method throw runtime exception circumstance . Both behavior require general contract respective method . The toString method redefine print Name human-readable form . This always good idea , especially object go get put collection . The various collection type ' toString method depend toString method element , key , value . Since section element ordering , let 's talk bit Name 's compareTo method . It implement standard name-ordering algorithm , last name take precedence first name . This exactly want natural ordering . It would confusing indeed natural ordering unnatural ! Take look compareTo implement , 's quite typical . First , compare significant part object ( case , last name ) . Often , use natural ordering part 's type . In case , part String natural ( lexicographic ) ordering exactly 's call . If comparison result anything zero , represent equality , 're : You return result . If significant part equal , go compare next most-significant part . In case , two part — first name last name . If part , 'd proceed obvious fashion , compare part find two n't equal compare least-significant part , point 'd return result comparison . Just show work , 's program build list name sort . import java.util . * ; public class NameSort { public static void main ( String [ ] args ) { Name nameArray [ ] = { new Name ( `` John '' , `` Smith '' ) , new Name ( `` Karl '' , `` Ng '' ) , new Name ( `` Jeff '' , `` Smith '' ) , new Name ( `` Tom '' , `` Rich '' ) } ; List < Name > name = Arrays.asList ( nameArray ) ; Collections.sort ( name ) ; System.out.println ( name ) ; } } If run program , 's print . [ Karl Ng , Tom Rich , Jeff Smith , John Smith ] There four restriction behavior compareTo method , wo n't go 're fairly technical boring well leave API documentation . It 's really important class implement Comparable obey restriction , read documentation Comparable 're write class implement . Attempting sort list object violate restriction undefined behavior . Technically speak , restriction ensure natural ordering total order object class implement ; necessary ensure sorting well define . Comparators What want sort object order natural ordering ? Or want sort object n't implement Comparable ? To either thing , 'll need provide Comparator — object encapsulate ordering . Like Comparable interface , Comparator interface consist single method . public interface Comparator < T > { int compare ( T o1 , T o2 ) ; } The compare method compare two argument , return negative integer , 0 , positive integer depend whether first argument less , equal , great second . If either argument inappropriate type Comparator , compare method throw ClassCastException . Much say Comparable applies Comparator well . Writing compare method nearly identical write compareTo method , except former get object pass argument . The compare method obey four technical restriction Comparable 's compareTo method reason — Comparator must induce total order object compare . Suppose class call Employee , follow . public class Employee implement Comparable < Employee > { public Name name ( ) { ... } public int number ( ) { ... } public Date hireDate ( ) { ... } ... } Let 's assume natural ordering Employee instance Name order ( define previous example ) employee name . Unfortunately , bos ask list employee order seniority . This mean work , much . The following program produce required list . import java.util . * ; public class EmpSort { static final Comparator < Employee > SENIORITY_ORDER = new Comparator < Employee > ( ) { public int compare ( Employee e1 , Employee e2 ) { return e2.hireDate ( ) .compareTo ( e1.hireDate ( ) ) ; } } ; // Employee database static final Collection < Employee > employee = ... ; public static void main ( String [ ] args ) { List < Employee > e = new ArrayList < Employee > ( employee ) ; Collections.sort ( e , SENIORITY_ORDER ) ; System.out.println ( e ) ; } } The Comparator program reasonably straightforward . It rely natural ordering Date apply value return hireDate accessor method . Note Comparator pass hire date second argument first rather vice versa . The reason employee hire recently least senior ; sort order hire date would put list reverse seniority order . Another technique people sometimes use achieve effect maintain argument order negate result comparison . // Do n't ! ! return -r1.hireDate ( ) .compareTo ( r2.hireDate ( ) ) ; You always use former technique favor latter latter guarantee work . The reason compareTo method return negative int argument less object invoke . There one negative int remain negative negate , strange may seem . -Integer.MIN_VALUE == Integer.MIN_VALUE The Comparator precede program work fine sort List , one deficiency : It use order sort collection , TreeSet , generate ordering compatible equal . This mean Comparator equate object equal method . In particular , two employee hire date compare equal . When 're sort List , n't matter ; 're use Comparator order sort collection , 's fatal . If use Comparator insert multiple employee hire date TreeSet , first one add set ; second see duplicate element ignore . To fix problem , simply tweak Comparator produce ordering compatible equal . In word , tweak element see equal use compare also see equal compare use equal . The way perform two-part comparison ( Name ) , first part one 're interested — case , hire date — second part attribute uniquely identify object . Here employee number obvious attribute . This Comparator result . static final Comparator < Employee > SENIORITY_ORDER = new Comparator < Employee > ( ) { public int compare ( Employee e1 , Employee e2 ) { int dateCmp = e2.hireDate ( ) .compareTo ( e1.hireDate ( ) ) ; ( dateCmp ! = 0 ) return dateCmp ; return ( e1.number ( ) < e2.number ( ) ? -1 : ( e1.number ( ) == e2.number ( ) ? 0 : 1 ) ) ; } } ; One last note : You might tempt replace final return statement Comparator simpler : return e1.number ( ) - e2.number ( ) ; Do n't unless 're absolutely sure one ever negative employee number ! This trick work general signed integer type big enough represent difference two arbitrary sign integer . If large positive integer j large negative integer , - j overflow return negative integer . The result comparator violate one four technical restriction keep talk ( transitivity ) produce horrible , subtle bug . This purely theoretical concern ; people get burn .