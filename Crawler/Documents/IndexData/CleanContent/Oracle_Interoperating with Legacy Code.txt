Until , example assume idealized world , everyone use late version Java programming language , support generic . Alas , reality n't case . Millions line code write early version language , wo n't convert overnight . Later , Converting Legacy Code Use Generics section , tackle problem convert old code use generic . In section , 'll focus simpler problem : legacy code generic code interoperate ? This question two part : use legacy code within generic code use generic code within legacy code . Using Legacy Code Generic Code How use old code , still enjoy benefit generic code ? As example , assume want use package com.Example.widgets . The folk Example.com market system inventory control , highlight show : package com.Example.widgets ; public interface Part { ... } public class Inventory { /** * Adds new Assembly inventory database . * The assembly give name name , * consist set part specify part . * All element collection part * must support Part interface . **/ public static void addAssembly ( String name , Collection part ) { ... } public static Assembly getAssembly ( String name ) { ... } } public interface Assembly { // Returns collection Parts Collection getParts ( ) ; } Now , 'd like add new code use API . It would nice ensure always call addAssembly ( ) proper argument - , collection pass indeed Collection Part . Of course , generic tailor make : package com.mycompany.inventory ; import com.Example.widgets . * ; public class Blade implement Part { ... } public class Guillotine implement Part { } public class Main { public static void main ( String [ ] args ) { Collection < Part > c = new ArrayList < Part > ( ) ; c.add ( new Guillotine ( ) ) ; c.add ( new Blade ( ) ) ; Inventory.addAssembly ( `` thingee '' , c ) ; Collection < Part > k = Inventory.getAssembly ( `` thingee '' ) .getParts ( ) ; } } When call addAssembly , expect second parameter type Collection . The actual argument type Collection < Part > . This work , ? After , collection n't contain Part object , general , compiler way know kind collection type Collection refers . In proper generic code , Collection would always accompany type parameter . When generic type like Collection use without type parameter , 's call raw type . Most people 's first instinct Collection really mean Collection < Object > . However , saw earlier , n't safe pass Collection < Part > place Collection < Object > require . It 's accurate say type Collection denote collection unknown type , like Collection < ? > . But wait , ca n't right either ! Consider call getParts ( ) , return Collection . This assign k , Collection < Part > . If result call Collection < ? > , assignment would error . In reality , assignment legal , generate unchecked warning . The warning need , fact compiler ca n't guarantee correctness . We way check legacy code getAssembly ( ) ensure indeed collection return collection Parts . The type use code Collection , one could legally insert kind object collection . So , n't error ? Theoretically speak , yes ; practically speaking , generic code go call legacy code , allow . It 's , programmer , satisfy case , assignment safe contract getAssembly ( ) say return collection Parts , even though type signature n't show . So raw type much like wildcard type , typechecked stringently . This deliberate design decision , allow generic interoperate pre-existing legacy code . Calling legacy code generic code inherently dangerous ; mix generic code non-generic legacy code , safety guarantee generic type system usually provide void . However , still good without use generic . At least know code end consistent . At moment 's lot non-generic code generic code , inevitably situation mix . If find must intermix legacy generic code , pay close attention unchecked warning . Think carefully justify safety code give rise warning . What happen still make mistake , code cause warning indeed type safe ? Let 's take look situation . In process , 'll get insight working compiler . Erasure Translation public String loophole ( Integer x ) { List < String > = new LinkedList < String > ( ) ; List x = ; xs.add ( x ) ; // Compile-time unchecked warning return ys.iterator ( ) .next ( ) ; } Here , 've aliased list string plain old list . We insert Integer list , attempt extract String . This clearly wrong . If ignore warning try execute code , fail exactly point try use wrong type . At run time , code behave like : public String loophole ( Integer x ) { List = new LinkedList ; List x = ; xs.add ( x ) ; return ( String ) ys.iterator ( ) .next ( ) ; // run time error } When extract element list , attempt treat string cast String , get ClassCastException . The exact thing happen generic version loophole ( ) . The reason , generic implement Java compiler front-end conversion call erasure . You ( almost ) think source-to-source translation , whereby generic version loophole ( ) convert non-generic version . As result , type safety integrity Java virtual machine never risk , even presence unchecked warning . Basically , erasure get rid ( erase ) generic type information . All type information betweeen angle bracket throw , , example , parameterized type like List < String > convert List . All remain us type variable replace upper bound type variable ( usually Object ) . And , whenever result code n't type-correct , cast appropriate type insert , last line loophole . The full detail erasure beyond scope tutorial , simple description give n't far truth . It 's good know bit , especially want sophisticated thing like convert exist APIs use generic ( see Converting Legacy Code Use Generics section ) , want understand thing way . Using Generic Code Legacy Code Now let 's consider inverse case . Imagine Example.com choose convert API use generic , client n't yet . So code look like : package com.Example.widgets ; public interface Part { ... } public class Inventory { /** * Adds new Assembly inventory database . * The assembly give name name , * consist set part specify part . * All element collection part * must support Part interface . **/ public static void addAssembly ( String name , Collection < Part > part ) { ... } public static Assembly getAssembly ( String name ) { ... } } public interface Assembly { // Returns collection Parts Collection < Part > getParts ( ) ; } client code look like : package com.mycompany.inventory ; import com.Example.widgets . * ; public class Blade implement Part { ... } public class Guillotine implement Part { } public class Main { public static void main ( String [ ] args ) { Collection c = new ArrayList ( ) ; c.add ( new Guillotine ( ) ) ; c.add ( new Blade ( ) ) ; // 1 : unchecked warning Inventory.addAssembly ( `` thingee '' , c ) ; Collection k = Inventory.getAssembly ( `` thingee '' ) .getParts ( ) ; } } The client code write generic introduce , use package com.Example.widgets collection library , use generic type . All us generic type declaration client code raw type . Line 1 generates unchecked warning , raw Collection pass Collection Parts expect , compiler ensure raw Collection really Collection Parts . As alternative , compile client code use source 1.4 flag , ensure warning generate . However , case wo n't able use new language feature introduce JDK 5.0 .