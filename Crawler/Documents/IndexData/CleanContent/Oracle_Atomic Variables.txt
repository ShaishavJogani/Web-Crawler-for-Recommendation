The java.util.concurrent.atomic package defines class support atomic operation single variable . All class get set method work like read writes volatile variable . That , set happens-before relationship subsequent get variable . The atomic compareAndSet method also memory consistency feature , simple atomic arithmetic method apply integer atomic variable . To see package might use , let 's return Counter class originally use demonstrate thread interference : class Counter { private int c = 0 ; public void increment ( ) { c++ ; } public void decrement ( ) { c -- ; } public int value ( ) { return c ; } } One way make Counter safe thread interference make method synchronize , SynchronizedCounter : class SynchronizedCounter { private int c = 0 ; public synchronize void increment ( ) { c++ ; } public synchronize void decrement ( ) { c -- ; } public synchronize int value ( ) { return c ; } } For simple class , synchronization acceptable solution . But complicated class , might want avoid liveness impact unnecessary synchronization . Replacing int field AtomicInteger allow u prevent thread interference without resort synchronization , AtomicCounter : import java.util.concurrent.atomic.AtomicInteger ; class AtomicCounter { private AtomicInteger c = new AtomicInteger ( 0 ) ; public void increment ( ) { c.incrementAndGet ( ) ; } public void decrement ( ) { c.decrementAndGet ( ) ; } public int value ( ) { return c.get ( ) ; } }