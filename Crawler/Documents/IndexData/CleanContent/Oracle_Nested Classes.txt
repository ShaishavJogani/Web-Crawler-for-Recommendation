The Java programming language allow define class within another class . Such class call nested class illustrate : class OuterClass { ... class NestedClass { ... } } Terminology : Nested class divide two category : static non-static . Nested class declare static call static nested class . Non-static nested class call inner class . class OuterClass { ... static class StaticNestedClass { ... } class InnerClass { ... } } A nested class member enclose class . Non-static nested class ( inner class ) access member enclose class , even declared private . Static nested class access member enclose class . As member OuterClass , nested class declare private , public , protect , package private . ( Recall outer class declare public package private . ) Why Use Nested Classes ? Compelling reason use nested class include following : It way logically group class use one place : If class useful one class , logical embed class keep two together . Nesting `` helper class '' make package streamlined . It increase encapsulation : Consider two top-level class , A B , B need access member A would otherwise declare private . By hide class B within class A , A 's member declare private B access . In addition , B hide outside world . It lead readable maintainable code : Nesting small class within top-level class place code closer use . Static Nested Classes As class method variable , static nested class associate outer class . And like static class method , static nested class refer directly instance variable method define enclose class : use object reference . Note : A static nested class interacts instance member outer class ( class ) like top-level class . In effect , static nested class behaviorally top-level class nest another top-level class package convenience . Static nest class access use enclose class name : OuterClass.StaticNestedClass For example , create object static nested class , use syntax : OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass ( ) ; Inner Classes As instance method variable , inner class associate instance enclose class direct access object 's method field . Also , inner class associate instance , define static member . Objects instance inner class exist within instance outer class . Consider following class : class OuterClass { ... class InnerClass { ... } } An instance InnerClass exist within instance OuterClass direct access method field enclose instance . To instantiate inner class , must first instantiate outer class . Then , create inner object within outer object syntax : OuterClass.InnerClass innerObject = outerObject.new InnerClass ( ) ; There two special kind inner class : local class anonymous class . Shadowing If declaration type ( member variable parameter name ) particular scope ( inner class method definition ) name another declaration enclose scope , declaration shadow declaration enclose scope . You refer shadow declaration name alone . The following example , ShadowTest , demonstrate : public class ShadowTest { public int x = 0 ; class FirstLevel { public int x = 1 ; void methodInFirstLevel ( int x ) { System.out.println ( `` x = `` + x ) ; System.out.println ( `` this.x = `` + this.x ) ; System.out.println ( `` ShadowTest.this.x = `` + ShadowTest.this.x ) ; } } public static void main ( String ... args ) { ShadowTest st = new ShadowTest ( ) ; ShadowTest.FirstLevel fl = st.new FirstLevel ( ) ; fl.methodInFirstLevel ( 23 ) ; } } The following output example : x = 23 this.x = 1 ShadowTest.this.x = 0 This example define three variable name x : member variable class ShadowTest , member variable inner class FirstLevel , parameter method methodInFirstLevel . The variable x define parameter method methodInFirstLevel shadow variable inner class FirstLevel . Consequently , use variable x method methodInFirstLevel , refer method parameter . To refer member variable inner class FirstLevel , use keyword represent enclose scope : System.out.println ( `` this.x = `` + this.x ) ; Refer member variable enclose large scope class name belong . For example , following statement access member variable class ShadowTest method methodInFirstLevel : System.out.println ( `` ShadowTest.this.x = `` + ShadowTest.this.x ) ; Serialization Serialization inner class , include local anonymous class , strongly discourage . When Java compiler compiles certain construct , inner class , create synthetic construct ; class , method , field , construct corresponding construct source code . Synthetic construct enable Java compiler implement new Java language feature without change JVM . However , synthetic construct vary among different Java compiler implementation , mean .class file vary among different implementation well . Consequently , may compatibility issue serialize inner class deserialize different JRE implementation . See section Implicit Synthetic Parameters section Obtaining Names Method Parameters information synthetic construct generate inner class compile .