One change JDK 5.0 class java.lang.Class generic . It 's interesting example use genericity something container class . Now Class type parameter T , might well ask , T stand ? It stand type Class object represent . For example , type String.class Class < String > , type Serializable.class Class < Serializable > . This use improve type safety reflection code . In particular , since newInstance ( ) method Class return T , get precise type create object reflectively . For example , suppose need write utility method perform database query , give string SQL , return collection object database match query . One way pass factory object explicitly , write code like : interface Factory < T > { T make ( ) ; } public < T > Collection < T > select ( Factory < T > factory , String statement ) { Collection < T > result = new ArrayList < T > ( ) ; /* Run sql query use jdbc */ ( /* Iterate jdbc result . */ ) { T item = factory.make ( ) ; /* Use reflection set item 's * field sql result . */ result.add ( item ) ; } return result ; } You call either select ( new Factory < EmpInfo > ( ) { public EmpInfo make ( ) { return new EmpInfo ( ) ; } } , `` selection string '' ) ; declare class EmpInfoFactory support Factory interface class EmpInfoFactory implement Factory < EmpInfo > { ... public EmpInfo make ( ) { return new EmpInfo ( ) ; } } call select ( getMyEmpInfoFactory ( ) , `` selection string '' ) ; The downside solution require either : use verbose anonymous factory class call site , declare factory class every type use pass factory instance call site , somewhat unnatural . It natural use class literal factory object , use reflection . Today ( without generic ) code might write : Collection emps = sqlUtility.select ( EmpInfo.class , `` select * emps '' ) ; ... public static Collection select ( Class c , String sqlStatement ) { Collection result = new ArrayList ( ) ; /* Run sql query use jdbc . */ ( /* Iterate jdbc result . */ ) { Object item = c.newInstance ( ) ; /* Use reflection set item's * field sql result . */ result.add ( item ) ; } return result ; } However , would give u collection precise type desire . Now Class generic , instead write following : Collection < EmpInfo > emps = sqlUtility.select ( EmpInfo.class , `` select * emps '' ) ; ... public static < T > Collection < T > select ( Class < T > c , String sqlStatement ) { Collection < T > result = new ArrayList < T > ( ) ; /* Run sql query use jdbc . */ ( /* Iterate jdbc result . */ ) { T item = c.newInstance ( ) ; /* Use reflection set item's * field sql result . */ result.add ( item ) ; } return result ; } The code give u precise type collection type safe way . This technique use class literal run time type token useful trick know . It 's idiom 's use extensively new APIs manipulate annotation , example .