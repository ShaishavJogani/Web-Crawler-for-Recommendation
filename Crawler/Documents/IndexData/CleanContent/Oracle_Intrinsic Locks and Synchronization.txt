Synchronization build around internal entity know intrinsic lock monitor lock . ( The API specification often refer entity simply `` monitor . '' ) Intrinsic lock play role aspect synchronization : enforcing exclusive access object 's state establish happens-before relationship essential visibility . Every object intrinsic lock associate . By convention , thread need exclusive consistent access object 's field acquire object 's intrinsic lock access , release intrinsic lock 's . A thread say intrinsic lock time acquire lock release lock . As long thread intrinsic lock , thread acquire lock . The thread block attempt acquire lock . When thread release intrinsic lock , happens-before relationship establish action subsequent acquisition lock . Locks In Synchronized Methods When thread invoke synchronized method , automatically acquire intrinsic lock method 's object release method return . The lock release occur even return cause uncaught exception . You might wonder happen static synchronized method invoke , since static method associate class , object . In case , thread acquire intrinsic lock Class object associate class . Thus access class 's static field control lock 's distinct lock instance class . Synchronized Statements Another way create synchronized code synchronized statement . Unlike synchronize method , synchronized statement must specify object provide intrinsic lock : public void addName ( String name ) { synchronize ( ) { lastName = name ; nameCount++ ; } nameList.add ( name ) ; } In example , addName method need synchronize change lastName nameCount , also need avoid synchronize invocation object ' method . ( Invoking object ' method synchronize code create problem describe section Liveness . ) Without synchronized statement , would separate , unsynchronized method sole purpose invoke nameList.add . Synchronized statement also useful improve concurrency fine-grained synchronization . Suppose , example , class MsLunch two instance field , c1 c2 , never use together . All update field must synchronize , 's reason prevent update c1 interleave update c2 â€” reduces concurrency create unnecessary blocking . Instead use synchronize method otherwise use lock associate , create two object solely provide lock . public class MsLunch { private long c1 = 0 ; private long c2 = 0 ; private Object lock1 = new Object ( ) ; private Object lock2 = new Object ( ) ; public void inc1 ( ) { synchronize ( lock1 ) { c1++ ; } } public void inc2 ( ) { synchronize ( lock2 ) { c2++ ; } } } Use idiom extreme care . You must absolutely sure really safe interleave access affected field . Reentrant Synchronization Recall thread acquire lock another thread . But thread acquire lock already . Allowing thread acquire lock enables reentrant synchronization . This describe situation synchronize code , directly indirectly , invoke method also contain synchronized code , set code use lock . Without reentrant synchronization , synchronize code would take many additional precaution avoid thread cause block .