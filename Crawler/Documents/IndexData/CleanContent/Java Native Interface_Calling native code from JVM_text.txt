In JNI framework , native function implement separate .c .cpp file . C++ provide slightly simple interface JNI . When JVM invoke function , pass aJNIEnvpointer , ajobjectpointer , Java argument declare Java method . A JNI function may look like : JNIEXPORTvoidJNICALLJava_ClassName_MethodName ( JNIEnv*env , jobjectobj ) { /*Implement Native Method Here*/ } Theenvpointer structure contain interface JVM . It include function necessary interact JVM work Java object . Example JNI function convert native array to/from Java array , convert native string to/from Java string , instantiate object , throw exception , etc . Basically , anything Java code usingJNIEnv , albeit considerably less ease . On Linux Solaris platform , native code register signal handler , could intercept signal intend JVM . Signal chaining use allow native code good interoperate JVM . On Windows platform , Structured Exception Handling ( SEH ) may employ wrap native code SEH try/catch block capture machine ( CPU/FPU ) generate software interrupt ( NULL pointer access violation divide-by-zero operation ) , handle situation interrupt propagate back JVM ( i.e . Java side code ) , likelihood result unhandled exception . C++ code [ edit ] For example , following convert Java string native string : extern '' C '' JNIEXPORTvoidJNICALLJava_ClassName_MethodName ( JNIEnv*env , jobjectobj , jstringjavaString ) { //Get native string javaStringconstchar*nativeString=env- > GetStringUTFChars ( javaString,0 ) ; //Do something nativeString//DO N'T FORGET THIS LINE ! ! ! env- > ReleaseStringUTFChars ( javaString , nativeString ) ; } The JNI framework provide automatic garbage collection non-JVM memory resource allocate code execute native side . Consequently , native side code ( C , C++ , assembly language ) must assume responsibility explicitly release memory resource acquire . C code [ edit ] JNIEXPORTvoidJNICALLJava_ClassName_MethodName ( JNIEnv*env , jobjectobj , jstringjavaString ) { /*Get native string javaString*/constchar*nativeString= ( *env ) - > GetStringUTFChars ( env , javaString,0 ) ; /*Do something nativeString*//*DO N'T FORGET THIS LINE ! ! ! */ ( *env ) - > ReleaseStringUTFChars ( env , javaString , nativeString ) ; } Note C++ JNI code syntactically slightly clean C JNI code like Java , C++ use object method invocation semantics . That mean C , theenvparameter dereferenced use ( *env ) - > andenvhas explicitly pass toJNIEnvmethods . In C++ , theenvparameter dereferenced usingenv- > theenvparameter implicitly pass part object method invocation semantics . Objective-C code [ edit ] JNIEXPORTvoidJNICALLJava_ClassName_MethodName ( JNIEnv*env , jobjectobj , jstringjavaString ) { /*DO N'T FORGET THIS LINE ! ! ! */JNF_COCOA_ENTER ( env ) ; /*Get native string javaString*/NSString*nativeString=JNFJavaToNSString ( env , javaString ) ; /*Do something nativeString*//*DO N'T FORGET THIS LINE ! ! ! */JNF_COCOA_EXIT ( env ) ; } JNI also allow direct access assembly code , without even go C bridge . Mapping type [ edit ] Native data type map to/from Java data type . For compound type object , array string native code must explicitly convert data call method theJNIEnv . The follow table show mapping type Java ( JNI ) native code . Native TypeJNI TypeDescriptionType signatureunsigned charjbooleanunsigned 8 bitsZsigned charjbytesigned 8 bitsBunsigned shortjcharunsigned 16 bitsCshortjshortsigned 16 bitsSlongjintsigned 32 bitsIlong long__int64jlongsigned 64 bitsJfloatjfloat32 bitsFdoublejdouble64 bitsD In addition , signature '' L fully-qualified-class ; '' would mean class uniquely specify name ; e.g. , signature '' Ljava/lang/String ; '' refers classjava.lang.String . Also , prefix [ signature make array type ; example , [ Imeans int array type . Finally , avoidsignature use theVcode . Here , type interchangeable . You usejintwhere normally use anint , vice-versa , without typecasting require . However , map Java Strings array native string array different . If use ajstringin achar *would , code could crash JVM . JNIEXPORTvoidJNICALLJava_ClassName_MethodName ( JNIEnv*env , jobjectobj , jstringjavaString ) { // printf ( `` % '' , javaString ) ; // INCORRECT : Could crash VM ! // Correct way : Create release native string Java stringconstchar*nativeString= ( *env ) - > GetStringUTFChars ( env , javaString,0 ) ; printf ( `` % '' , nativeString ) ; ( *env ) - > ReleaseStringUTFChars ( env , javaString , nativeString ) ; } The encode use theNewStringUTF , GetStringUTFLength , GetStringUTFChars , ReleaseStringUTFChars , GetStringUTFRegionfunctions standard UTF-8 , modify UTF-8 . The null character ( U+0000 ) codepoints great equal U+10000 encode differently modify UTF-8 . Many program actually use function incorrectly treat UTF-8 string return pass function standard UTF-8 string instead modify UTF-8 string . Programs use theNewString , GetStringLength , GetStringChars , ReleaseStringChars , GetStringRegion , GetStringCritical , andReleaseStringCriticalfunctions , use UTF-16LE encoding little-endian architecture UTF-16BE big-endian architecture , use UTF-16 standard UTF-8 conversion routine . The code similar Java array , illustrate example take sum element array . JNIEXPORTjintJNICALLJava_IntArray_sumArray ( JNIEnv*env , jobjectobj , jintArrayarr ) { jintbuf [ 10 ] ; jinti , sum=0 ; // This line necessary , since Java array guaranteed// continuous memory layout like C arrays.env- > GetIntArrayRegion ( arr,0,10 , buf ) ; ( i=0 ; < 10 ; i++ ) { sum+=buf [ ] ; } returnsum ; } Of course , much . JNIEnv* [ edit ] A JNI environment pointer ( JNIEnv* ) pass argument native function map Java method , allow interaction JNI environment within native method . This JNI interface pointer store , remain valid current thread . Other thread must first callAttachCurrentThread ( ) attach VM obtain JNI interface pointer . Once attach , native thread work like regular Java thread run within native method . The native thread remain attach VM callsDetachCurrentThread ( ) detach . To attach current thread get JNI interface pointer : JNIEnv *env ; ( *g_vm ) - > AttachCurrentThread ( g_vm , ( void ** ) & env , NULL ) ; To detach current thread : ( *g_vm ) - > DetachCurrentThread ( g_vm ) ;