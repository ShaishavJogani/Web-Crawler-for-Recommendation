If ever use shell script , likely used pattern match locate file . In fact , probably use extensively . If n't use , pattern match us special character create pattern file name compare pattern . For example , shell script , asterisk , * , match number character . For example , following command list file current directory end .html : % l *.html The java.nio.file package provide programmatic support useful feature . Each file system implementation provide PathMatcher . You retrieve file system 's PathMatcher use getPathMatcher ( String ) method FileSystem class . The following code snippet fetch path matcher default file system : String pattern = ... ; PathMatcher matcher = FileSystems.getDefault ( ) .getPathMatcher ( `` glob : '' + pattern ) ; The string argument pass getPathMatcher specifies syntax flavor pattern match . This example specify glob syntax . If unfamiliar glob syntax , see What Glob . Glob syntax easy use flexible , prefer , also use regular expression , regex , syntax . For information regex , see Regular Expressions lesson . Some file system implementation might support syntax . If want use form string-based pattern matching , create PathMatcher class . The example page use glob syntax . Once create PathMatcher instance , ready match file . The PathMatcher interface single method , match , take Path argument return boolean : It either match pattern , . The following code snippet look file end .java .class print file standard output : PathMatcher matcher = FileSystems.getDefault ( ) .getPathMatcher ( `` glob : * . { java , class } '' ) ; Path filename = ... ; ( matcher.matches ( filename ) ) { System.out.println ( filename ) ; } Recursive Pattern Matching Searching file match particular pattern go hand-in-hand walk file tree . How many time know file somewhere file system , ? Or perhaps need find file file tree particular file extension . The Find example precisely . Find similar UNIX find utility , par functionally . You extend example include functionality . For example , find utility support -prune flag exclude entire subtree search . You could implement functionality return SKIP_SUBTREE preVisitDirectory method . To implement -L option , follow symbolic link , could use four-argument walkFileTree method pas FOLLOW_LINKS enum ( make sure test circular link visitFile method ) . To run Find application , use following format : % java Find < path > -name `` < glob_pattern > '' The pattern place inside quotation mark wildcards interpret shell . For example : % java Find . -name `` *.html '' Here source code Find example : /** * Sample code find file match specified glob pattern . * For information constitute glob pattern , see * http : //docs.oracle.com/javase/tutorial/essential/io/fileOps.html # glob * * The file directory match pattern print * standard . The number match also print . * * When execute application , must put glob pattern * quote , shell expand wild card : * java Find . -name `` *.java '' */ import java.io . * ; import java.nio.file . * ; import java.nio.file.attribute . * ; import static java.nio.file.FileVisitResult . * ; import static java.nio.file.FileVisitOption . * ; import java.util . * ; public class Find { public static class Finder extend SimpleFileVisitor < Path > { private final PathMatcher matcher ; private int numMatches = 0 ; Finder ( String pattern ) { matcher = FileSystems.getDefault ( ) .getPathMatcher ( `` glob : '' + pattern ) ; } // Compares glob pattern // file directory name . void find ( Path file ) { Path name = file.getFileName ( ) ; ( name ! = null & & matcher.matches ( name ) ) { numMatches++ ; System.out.println ( file ) ; } } // Prints total number // match standard . void ( ) { System.out.println ( `` Matched : `` + numMatches ) ; } // Invoke pattern match // method file . @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) { find ( file ) ; return CONTINUE ; } // Invoke pattern match // method directory . @ Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { find ( dir ) ; return CONTINUE ; } @ Override public FileVisitResult visitFileFailed ( Path file , IOException exc ) { System.err.println ( exc ) ; return CONTINUE ; } } static void usage ( ) { System.err.println ( `` java Find < path > '' + `` -name \ '' < glob_pattern > \ '' '' ) ; System.exit ( -1 ) ; } public static void main ( String [ ] args ) throw IOException { ( args.length < 3 || ! args [ 1 ] .equals ( `` -name '' ) ) usage ( ) ; Path startingDir = Paths.get ( args [ 0 ] ) ; String pattern = args [ 2 ] ; Finder finder = new Finder ( pattern ) ; Files.walkFileTree ( startingDir , finder ) ; finder.done ( ) ; } } Recursively walk file tree cover Walking File Tree .