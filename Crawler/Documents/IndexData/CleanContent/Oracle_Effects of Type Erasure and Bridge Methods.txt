Sometimes type erasure cause situation may anticipate . The following example show occur . The example ( describe Bridge Methods ) show compiler sometimes create synthetic method , call bridge method , part type erasure process . Given follow two class : public class Node < T > { public T data ; public Node ( T data ) { this.data = data ; } public void setData ( T data ) { System.out.println ( `` Node.setData '' ) ; this.data = data ; } } public class MyNode extend Node < Integer > { public MyNode ( Integer data ) { super ( data ) ; } public void setData ( Integer data ) { System.out.println ( `` MyNode.setData '' ) ; super.setData ( data ) ; } } Consider following code : MyNode mn = new MyNode ( 5 ) ; Node n = mn ; // A raw type - compiler throw unchecked warning n.setData ( `` Hello '' ) ; Integer x = mn.data ; // Causes ClassCastException throw . After type erasure , code become : MyNode mn = new MyNode ( 5 ) ; Node n = ( MyNode ) mn ; // A raw type - compiler throw unchecked warning n.setData ( `` Hello '' ) ; Integer x = ( String ) mn.data ; // Causes ClassCastException throw . Here happen code execute : n.setData ( `` Hello '' ) ; cause method setData ( Object ) execute object class MyNode . ( The MyNode class inherit setData ( Object ) Node . ) In body setData ( Object ) , data field object reference n assign String . The data field object , reference via mn , access expect integer ( since mn MyNode Node < Integer > . Trying assign String Integer cause ClassCastException cast insert assignment Java compiler . Bridge Methods When compile class interface extend parameterized class implement parameterized interface , compiler may need create synthetic method , call bridge method , part type erasure process . You normally n't need worry bridge method , might puzzle one appear stack trace . After type erasure , Node MyNode class become : public class Node { public Object data ; public Node ( Object data ) { this.data = data ; } public void setData ( Object data ) { System.out.println ( `` Node.setData '' ) ; this.data = data ; } } public class MyNode extend Node { public MyNode ( Integer data ) { super ( data ) ; } public void setData ( Integer data ) { System.out.println ( `` MyNode.setData '' ) ; super.setData ( data ) ; } } After type erasure , method signature match . The Node method become setData ( Object ) MyNode method become setData ( Integer ) . Therefore , MyNode setData method override Node setData method . To solve problem preserve polymorphism generic type type erasure , Java compiler generate bridge method ensure subtyping work expect . For MyNode class , compiler generate following bridge method setData : class MyNode extend Node { // Bridge method generate compiler // public void setData ( Object data ) { setData ( ( Integer ) data ) ; } public void setData ( Integer data ) { System.out.println ( `` MyNode.setData '' ) ; super.setData ( data ) ; } // ... } As see , bridge method , method signature Node class 's setData method type erasure , delegate original setData method .