Consider write method take array object collection put object array collection . Here 's first attempt : static void fromArrayToCollection ( Object [ ] , Collection < ? > c ) { ( Object : ) { c.add ( ) ; // compile-time error } } By , learn avoid beginner 's mistake try use Collection < Object > type collection parameter . You may may recognize use Collection < ? > n't go work either . Recall shove object collection unknown type . The way deal problem use generic method . Just like type declaration , method declaration generic—that , parameterized one type parameter . static < T > void fromArrayToCollection ( T [ ] , Collection < T > c ) { ( T : ) { c.add ( ) ; // Correct } } We call method kind collection whose element type supertype element type array . Object [ ] oa = new Object [ 100 ] ; Collection < Object > co = new ArrayList < Object > ( ) ; // T infer Object fromArrayToCollection ( oa , co ) ; String [ ] sa = new String [ 100 ] ; Collection < String > cs = new ArrayList < String > ( ) ; // T infer String fromArrayToCollection ( sa , c ) ; // T infer Object fromArrayToCollection ( sa , co ) ; Integer [ ] ia = new Integer [ 100 ] ; Float [ ] fa = new Float [ 100 ] ; Number [ ] na = new Number [ 100 ] ; Collection < Number > cn = new ArrayList < Number > ( ) ; // T infer Number fromArrayToCollection ( ia , cn ) ; // T infer Number fromArrayToCollection ( fa , cn ) ; // T infer Number fromArrayToCollection ( na , cn ) ; // T infer Object fromArrayToCollection ( na , co ) ; // compile-time error fromArrayToCollection ( na , c ) ; Notice n't pass actual type argument generic method . The compiler infer type argument u , base type actual argument . It generally infer specific type argument make call type-correct . One question arise : I use generic method , I use wildcard type ? To understand answer , let 's examine method Collection library . interface Collection < E > { public boolean containsAll ( Collection < ? > c ) ; public boolean addAll ( Collection < ? extends E > c ) ; } We could use generic method instead : interface Collection < E > { public < T > boolean containsAll ( Collection < T > c ) ; public < T extend E > boolean addAll ( Collection < T > c ) ; // Hey , type variable bound ! } However , containsAll addAll , type parameter T use . The return type n't depend type parameter , argument method ( case , simply one argument ) . This tell u type argument use polymorphism ; effect allow variety actual argument type use different invocation site . If case , one use wildcards . Wildcards design support flexible subtyping , 're try express . Generic method allow type parameter use express dependency among type one argument method and/or return type . If n't dependency , generic method use . It possible use generic method wildcards tandem . Here method Collections.copy ( ) : class Collections { public static < T > void copy ( List < T > , List < ? extends T > src ) { ... } Note dependency type two parameter . Any object copy source list , src , must assignable element type T destination list , dst . So element type src subtype T—we n't care . The signature copy express dependency use type parameter , use wildcard element type second parameter . We could write signature method another way , without use wildcards : class Collections { public static < T , S extend T > void copy ( List < T > , List < S > src ) { ... } This fine , first type parameter use type dst bound second type parameter , S , S used , type src—nothing else depend . This sign replace S wildcard . Using wildcards clear concise declare explicit type parameter , therefore prefer whenever possible . Wildcards also advantage use outside method signature , type field , local variable array . Here example . Returning shape draw problem , suppose want keep history draw request . We maintain history static variable inside class Shape , drawAll ( ) store incoming argument history field . static List < List < ? extends Shape > > history = new ArrayList < List < ? extends Shape > > ( ) ; public void drawAll ( List < ? extends Shape > shape ) { history.addLast ( shape ) ; ( Shape : shape ) { s.draw ( ) ; } } Finally , let 's take note naming convention use type parameter . We use T type , whenever n't anything specific type distinguish . This often case generic method . If multiple type parameter , might use letter neighbor T alphabet , S. If generic method appear inside generic class , 's good idea avoid use name type parameter method class , avoid confusion . The applies nest generic class .