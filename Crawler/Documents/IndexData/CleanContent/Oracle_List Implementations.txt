List implementation group general-purpose special-purpose implementation . General-Purpose List Implementations There two general-purpose List implementation — ArrayList LinkedList . Most time , 'll probably use ArrayList , offer constant-time positional access plain fast . It allocate node object element List , take advantage System.arraycopy move multiple element time . Think ArrayList Vector without synchronization overhead . If frequently add element beginning List iterate List delete element interior , consider use LinkedList . These operation require constant-time LinkedList linear-time ArrayList . But pay big price performance . Positional access require linear-time LinkedList constant-time ArrayList . Furthermore , constant factor LinkedList much bad . If think want use LinkedList , measure performance application LinkedList ArrayList make choice ; ArrayList usually faster . ArrayList one tuning parameter — initial capacity , refer number element ArrayList hold grow . LinkedList tune parameter seven optional operation , one clone . The six addFirst , getFirst , removeFirst , addLast , getLast , removeLast . LinkedList also implement Queue interface . Special-Purpose List Implementations CopyOnWriteArrayList List implementation back copy-on-write array . This implementation similar nature CopyOnWriteArraySet . No synchronization necessary , even iteration , iterators guarantee never throw ConcurrentModificationException . This implementation well suit maintain event-handler list , change infrequent , traversal frequent potentially time-consuming . If need synchronization , Vector slightly fast ArrayList synchronize Collections.synchronizedList . But Vector load legacy operation , careful always manipulate Vector List interface else wo n't able replace implementation late time . If List fix size — , 'll never use remove , add , bulk operation containsAll — third option 's definitely worth consider . See Arrays.asList Convenience Implementations section information .