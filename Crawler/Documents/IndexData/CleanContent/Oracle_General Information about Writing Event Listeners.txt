This section discuss several design consideration keep mind implement event handler application . We introduce event object small object describe event . In particular , talk EventObject , superclass AWT Swing event . Next , introduce concept low-level event semantic event , recommend prefer semantic event possible . The remainder section discuss implementation technique might use event listener see event listener create people GUI builder . Design Considerations Getting Event Information : Event Objects Concepts : Low-Level Events Semantic Events Event Adapters Inner Classes Anonymous Inner Classes The EventHandler Class Design Considerations The important rule keep mind event listener execute quickly . Because drawing event-listening method execute thread , slow event-listener method make program seem unresponsive slow repaint . If need perform lengthy operation result event , start another thread ( somehow send request another thread ) perform operation . For help use thread , see Concurrency Swing . You many choice implement event listener . We recommend specific approach one solution would suit situation . However , give hint show technique might see , even use solution program . For example , might choose implement separate class different kind event listener . This easy architecture maintain , many class also mean reduced performance . When design program , might want implement event listener class public , somewhere hidden . A private implementation secure implementation . If specific kind simple event listener , might able avoid create class use EventHandler class . Getting Event Information : Event Objects Every event-listener method single argument object inherit EventObject class . Although argument always descend EventObject , type generally specify precisely . For example , argument method handle mouse event instance MouseEvent , MouseEvent indirect subclass EventObject . The EventObject class define one useful method : Object getSource ( ) Returns object fire event . Note getSource method return Object . Event class sometimes define method similar getSource , restricted return type . For example , ComponentEvent class define getComponent method like getSource return object fire event . The difference getComponent always return Component . Each how-to page event listener mention whether use getSource another method get event source . Often , event class define method return information event . For example , query MouseEvent object information event occur , many click user make , modifier key press , . Concepts : Low-Level Events Semantic Events Events divide two group : low-level event semantic event . Low-level event represent window-system occurrence low-level input . Everything else semantic event . Examples low-level event include mouse key event result directly user input . Examples semantic event include action item event . A semantic event might trigger user input ; example , button customarily fire action event user click , text field fire action event user press Enter . However , semantic event trigger low-level event , . For example , table-model event might fire table model receive new data database . Whenever possible , listen semantic event rather low-level event . That way , make code robust portable possible . For example , listen action event button , rather mouse event , mean button react appropriately user try activate button use keyboard alternative look-and-feel-specific gesture . When deal compound component combo box , imperative stick semantic event , since reliable way register listener look-and-feel-specific component might use form compound component . Event Adapters Some listener interface contain one method . For example , MouseListener interface contain five method : mousePressed , mouseReleased , mouseEntered , mouseExited , mouseClicked . Even care mouse click , class directly implement MouseListener , must implement five MouseListener method . Methods event care empty body . Here example : //An example implement listener interface directly . public class MyClass implement MouseListener { ... someObject.addMouseListener ( ) ; ... /* Empty method definition . */ public void mousePressed ( MouseEvent e ) { } /* Empty method definition . */ public void mouseReleased ( MouseEvent e ) { } /* Empty method definition . */ public void mouseEntered ( MouseEvent e ) { } /* Empty method definition . */ public void mouseExited ( MouseEvent e ) { } public void mouseClicked ( MouseEvent e ) { ... //Event listener implementation go ... } } The result collection empty method body make code harder read maintain . To help avoid implement empty method body , API generally include adapter class listener interface one method . ( The Listener API Table list listener adapter . ) For example , MouseAdapter class implement MouseListener interface . An adapter class implement empty version interface 's method . To use adapter , create subclass override method interest , rather directly implement method listener interface . Here example modify precede code extend MouseAdapter . By extend MouseAdapter , inherit empty definition five method MouseListener contain . /* * An example extend adapter class instead * directly implement listener interface . */ public class MyClass extend MouseAdapter { ... someObject.addMouseListener ( ) ; ... public void mouseClicked ( MouseEvent e ) { ... //Event listener implementation go ... } } Inner Classes Anonymous Inner Classes What want use adapter class , want public class inherit adapter class ? For example , suppose write applet , want Applet subclass contain code handle mouse event . Since Java language permit multiple inheritance , class extend Applet MouseAdapter class . A solution define inner class class inside Applet subclass extend MouseAdapter class . Inner class also useful event listener implement one interface directly . //An example use inner class . public class MyClass extend Applet { ... someObject.addMouseListener ( new MyAdapter ( ) ) ; ... class MyAdapter extend MouseAdapter { public void mouseClicked ( MouseEvent e ) { ... //Event listener implementation go ... } } } Performance note : When consider whether use inner class , keep mind application startup time memory footprint typically directly proportional number class load . The class create , long program take start memory take . As application developer balance design constraint may . We suggest turn application single monolithic class hope cut startup time memory footprint would lead unnecessary headache maintenance burden . You create inner class without specify name know anonymous inner class . While might look strange first glance , anonymous inner class make code easy read class define reference . However , need weigh convenience possible performance implication increase number class . Here example use anonymous inner class : //An example use anonymous inner class . public class MyClass extend Applet { ... someObject.addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent e ) { ... //Event listener implementation go ... } } ) ; ... } } Note : One drawback anonymous inner class see long-term persistence mechanism . For information see API documentation JavaBeansâ„¢ package Bean Persistence lesson JavaBeans trail . Inner class work even event listener need access private instance variable enclose class . As long declare inner class static , inner class refer instance variable method code containing class . To make local variable available inner class , save copy variable final local variable . To refer enclose instance , use EnclosingClass.this . For information inner class , see Nested Classes . The EventHandler Class An EventHandler class support dynamic generation simple , one-statement event listener . Although EventHandler useful certain type extremely simple event listener , worth mention two reason . It useful : Making event listener persistence see yet clog class event listener interface method . Not add number class define application help performance . Creating EventHandler hand difficult . An EventHandler must carefully construct . If make mistake , would notify compile time throw obscure exception runtime . For reason , EventHandlers best create GUI builder . EventHandlers carefully document . Otherwise run risk produce hard-to-read code . The EventHandler class intend use interactive tool , application builder , allow developer make connection bean . Typically connection make user interface bean ( event source ) application logic bean ( target ) . The effective connection kind isolate application logic user interface . For example , EventHandler connection JCheckBox method accept boolean value deal extract state check box pass directly method method isolate user interface layer . Inner class another , general way handle event user interface . The EventHandler class handle subset possible use inner class . However , EventHandler work well long-term persistence scheme inner class . Also , use EventHandler large application interface implement many time reduce disk memory footprint application . Examples Using EventHandler The simple use EventHandler install listener call method target object argument . In following example create ActionListener invoke toFront method instance javax.swing.JFrame . myButton.addActionListener ( ( ActionListener ) EventHandler.create ( ActionListener.class , frame , `` toFront '' ) ) ; When myButton press , statement frame.toFront ( ) execute . One could get effect , additional compile-time type safety , define new implementation ActionListener interface add instance button : //Equivalent code use inner class instead EventHandler . myButton.addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { frame.toFront ( ) ; } } ) ; The next simplest use EventHandler extract property value first argument method listener interface ( typically event object ) use set value property target object . In following example create ActionListener set nextFocusableComponent property target ( myButton ) object value `` source '' property event . EventHandler.create ( ActionListener.class , myButton , `` nextFocusableComponent '' , `` source '' ) This would correspond following inner class implementation : //Equivalent code use inner class instead EventHandler . new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { myButton.setNextFocusableComponent ( ( Component ) e.getSource ( ) ) ; } } It also possible create EventHandler pass incoming event object target 's action . If fourth EventHandler.create argument empty string , event pass along : EventHandler.create ( ActionListener.class , target , `` doActionEvent '' , `` '' ) This would correspond following inner class implementation : //Equivalent code use inner class instead EventHandler . new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { target.doActionEvent ( e ) ; } } Probably common use EventHandler extract property value source event object set value value property target object . In following example create ActionListener set `` label '' property target object value `` text '' property source ( value `` source '' property ) event . EventHandler.create ( ActionListener.class , myButton , `` label '' , `` source.text '' ) This would correspond following inner class implementation : //Equivalent code use inner class instead EventHandler . new ActionListener { public void actionPerformed ( ActionEvent e ) { myButton.setLabel ( ( ( JTextField ) e.getSource ( ) ) .getText ( ) ) ; } }