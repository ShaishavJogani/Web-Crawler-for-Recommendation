The Sequencer interface provide method several category : Methods load sequence data MIDI file Sequence object , save currently load sequence data MIDI file . Methods analogous transport function tape recorder , stop start playback recording , enable disable record specific track , shuttle current playback record position Sequence . Advanced method query set synchronization time parameter object . A Sequencer may play different tempo , Tracks mute , various synchronization state object . Advanced method register `` listener '' object notify Sequencer process certain kind MIDI event . Regardless Sequencer method 'll invoke , first step obtain Sequencer device system reserve program 's use . Obtaining Sequencer An application program n't instantiate Sequencer ; , Sequencer interface . Instead , like device Java Sound API 's MIDI package , Sequencer access static MidiSystem object . As previously mention Accessing MIDI System Resources , following MidiSystem method use obtain default Sequencer : static Sequencer getSequencer ( ) The following code fragment obtain default Sequencer , acquire system resource need , make operational : Sequencer sequencer ; // Get default sequencer . sequencer = MidiSystem.getSequencer ( ) ; ( sequencer == null ) { // Error -- sequencer device support . // Inform user return ... } else { // Acquire resource make operational . sequencer.open ( ) ; } The invocation open reserve sequencer device program 's use . It n't make much sense imagine share sequencer , play one sequence time . When 're use sequencer , make available program invoke close . Non-default sequencer obtain describe Accessing MIDI System Resources . Loading Sequence Having obtain sequencer system reserve , need load data sequencer play . There three typical way accomplish : Reading sequence data MIDI file Recording real time receive MIDI message another device , MIDI input port Building programmatically `` scratch '' add track empty sequence add MidiEvent object track We 'll look first way get sequence data . ( The two way describe Recording Saving Sequences Editing Sequence , respectively . ) This first way actually encompass two slightly different approach . One approach fee MIDI file data InputStream read directly sequencer mean Sequencer.setSequence ( InputStream ) . With approach , n't explicitly create Sequence object . In fact , Sequencer implementation might even create Sequence behind scene , sequencer built-in mechanism handle data directly file . The approach create Sequence explicitly . You 'll need use approach 're go edit sequence data play . With approach , invoke MidiSystem 's overloaded method getSequence . The method able get sequence InputStream , File , URL . The method return Sequence object load Sequencer playback . Expanding previous code excerpt , 's example obtain Sequence object File load sequencer : try { File myMidiFile = new File ( `` seq1.mid '' ) ; // Construct Sequence object , // load sequencer . Sequence mySeq = MidiSystem.getSequence ( myMidiFile ) ; sequencer.setSequence ( mySeq ) ; } catch ( Exception e ) { // Handle error and/or return } Like MidiSystem 's getSequence method , setSequence may throw InvalidMidiDataExceptionâand , case InputStream variant , IOExceptionâif run trouble . Playing Sequence Starting stop Sequencer accomplish use following method : void start ( ) void stop ( ) The Sequencer.start method begin playback sequence . Note playback start current position sequence . Loading exist sequence use setSequence method , describe , initialize sequencer 's current position beginning sequence . The stop method stop sequencer , automatically rewind current Sequence . Starting stopped Sequence without reset position simply resume playback sequence current position . In case , stop method serve pause operation . However , various Sequencer method set current sequence position arbitrary value playback start . ( We 'll discuss method . ) As mention earlier , Sequencer typically one Transmitter object , send MidiMessages Receiver . It Transmitters Sequencer play Sequence , emit appropriately time MidiMessages correspond MidiEvents contain current Sequence . Therefore , part setup procedure play back Sequence invoke setReceiver method Sequencer 's Transmitter object , effect wire output device make use played-back data . For detail Transmitters Receivers , refer back Transmitting Receiving MIDI Messages . Recording Saving Sequences To capture MIDI data Sequence , subsequently file , need perform additional step beyond describe . The following outline show step necessary set record Track Sequence : Use MidiSystem.getSequencer get new sequencer use recording , . Set `` wiring '' MIDI connection . The object transmit MIDI data record configure , setReceiver method , send data Receiver associate record Sequencer . Create new Sequence object , store record data . When create Sequence object , must specify global timing information sequence . For example : Sequence mySeq ; try { mySeq = new Sequence ( Sequence.PPQ , 10 ) ; } catch ( Exception ex ) { ex.printStackTrace ( ) ; } The constructor Sequence take argument divisionType timing resolution . The divisionType argument specify unit resolution argument . In case , 've specify timing resolution Sequence 're create 10 pulse per quarter note . An additional optional argument Sequence constructor number track argument , would cause initial sequence begin specified number ( initially empty ) Tracks . Otherwise Sequence create initial Tracks ; add later need . Create empty Track Sequence , Sequence.createTrack . This step unnecessary Sequence create initial Tracks . Using Sequencer.setSequence , select new Sequence receive recording . The setSequence method tie together exist Sequence Sequencer , somewhat analogous load tape onto tape recorder . Invoke Sequencer.recordEnable Track record . If necessary , get reference available Tracks Sequence invoke Sequence.getTracks . Invoke startRecording Sequencer . When recording , invoke Sequencer.stop Sequencer.stopRecording . Save recorded Sequence MIDI file MidiSystem.write . The write method MidiSystem take Sequence one argument , write Sequence stream file . Editing Sequence Many application program allow sequence create load file , quite also allow sequence create capture live MIDI input ( , record ) . Some program , however , need create MIDI sequence scratch , whether programmatically response user input . Full-featured sequencer program permit user manually construct new sequence , well edit exist one . These data-editing operation achieve Java Sound API Sequencer method , method data object : Sequence , Track , MidiEvent . You create empty sequence use one Sequence constructor , add track invoke following Sequence method : Track createTrack ( ) If program allow user edit sequence , 'll need Sequence method remove track : boolean deleteTrack ( Track track ) Once sequence contain track , modify content track invoke method Track class . The MidiEvents contain Track store java.util.Vector Track object , Track provide set method access , add , remove event list . The method add remove fairly self-explanatory , add remove specified MidiEvent Track . A get method provide , take index Track 's event list return MidiEvent store . In addition , size tick method , respectively return number MidiEvents track , track 's duration , express total number Ticks . To create new event add track , 'll course use MidiEvent constructor . To specify modify MIDI message embed event , invoke setMessage method appropriate MidiMessage subclass ( ShortMessage , SysexMessage , MetaMessage ) . To modify time event occur , invoke MidiEvent.setTick . In combination , low-level method provide basis edit functionality need full-featured sequencer program .