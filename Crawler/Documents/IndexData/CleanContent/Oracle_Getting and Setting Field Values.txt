Given instance class , possible use reflection set value field class . This typically special circumstance set value usual way possible . Because access usually violate design intention class , use utmost discretion . The Book class illustrate set value long , array , enum field type . Methods get set primitive type describe Field . import java.lang.reflect.Field ; import java.util.Arrays ; import static java.lang.System.out ; enum Tweedle { DEE , DUM } public class Book { public long chapter = 0 ; public String [ ] character = { `` Alice '' , `` White Rabbit '' } ; public Tweedle twin = Tweedle.DEE ; public static void main ( String ... args ) { Book book = new Book ( ) ; String fmt = `` % 6S : % -12s = % % n '' ; try { Class < ? > c = book.getClass ( ) ; Field chap = c.getDeclaredField ( `` chapter '' ) ; out.format ( fmt , `` '' , `` chapter '' , book.chapters ) ; chap.setLong ( book , 12 ) ; out.format ( fmt , `` '' , `` chapter '' , chap.getLong ( book ) ) ; Field char = c.getDeclaredField ( `` character '' ) ; out.format ( fmt , `` '' , `` character '' , Arrays.asList ( book.characters ) ) ; String [ ] newChars = { `` Queen '' , `` King '' } ; chars.set ( book , newChars ) ; out.format ( fmt , `` '' , `` character '' , Arrays.asList ( book.characters ) ) ; Field = c.getDeclaredField ( `` twin '' ) ; out.format ( fmt , `` '' , `` twin '' , book.twin ) ; t.set ( book , Tweedle.DUM ) ; out.format ( fmt , `` '' , `` twin '' , t.get ( book ) ) ; // production code handle exception gracefully } catch ( NoSuchFieldException x ) { x.printStackTrace ( ) ; } catch ( IllegalAccessException x ) { x.printStackTrace ( ) ; } } } This corresponding output : $ java Book BEFORE : chapter = 0 AFTER : chapter = 12 BEFORE : character = [ Alice , White Rabbit ] AFTER : character = [ Queen , King ] BEFORE : twin = DEE AFTER : twin = DUM Note : Setting field 's value via reflection certain amount performance overhead various operation must occur validate access permission . From runtime 's point view , effect , operation atomic value change class code directly . Use reflection cause runtime optimization lose . For example , following code highly likely optimize Java virtual machine : int x = 1 ; x = 2 ; x = 3 ; Equivalent code use Field.set* ( ) may .