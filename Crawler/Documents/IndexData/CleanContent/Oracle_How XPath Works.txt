The XPath specification foundation variety specification , include XSLT linking/addressing specification XPointer . So understanding XPath fundamental lot advanced XML usage . This section provide introduction XPath context XSLT . XPath Expressions In general , XPath expression specify pattern select set XML node . XSLT template use pattern apply transformation . ( XPointer , hand , add mechanism define point range XPath expression use address ) . The node XPath expression refer element . They also refer text attribute , among thing . In fact , XPath specification define abstract document model define seven kind node : Root Element Text Attribute Comment Processing instruction Namespace The root element XML data model element node . The XPath root node contain document 's root element well information relate document . XSLT/XPath Data Model Like Document Object Model ( DOM ) , XSLT/XPath data model consist tree contain variety node . Under give element node , text node , attribute node , element node , comment node , process instruction node . In abstract model , syntactic distinction disappear , leave normalized view data . In text node , example , make difference whether text define CDATA section whether include entity reference . The text node consist normalized data , exist parsing complete . So text contain < character , whether entity reference < CDATA section use include . ( Similarly , text contain & character , whether deliver use & CDATA section ) . In section , deal mostly element node text node . For address mechanism , see XPath specification . Templates Contexts An XSLT template set format instruction apply node select XPath expression . In stylesheet , XSLT template would look something like : < xsl : template match= '' //LIST '' > ... < /xsl : template > The expression //LIST select set LIST node input stream . Additional instruction within template tell system . The set node select expression define context expression template evaluate . That context consider whole set - example , determine number node contain . The context also consider single member set , member process one one . For example , inside LIST-processing template , expression @ type refers type attribute current LIST node . ( Similarly , expression @ * refers attribute current LIST element ) . Basic XPath Addressing An XML document tree-structured ( hierarchical ) collection node . As hierarchical directory structure , useful specify path point particular node hierarchy ( hence name specification : XPath ) . In fact , much notation directory path carry intact : The forward slash ( / ) use path separator . An absolute path root document start / . A relative path give location start anything else . A double period ( .. ) indicate parent current node . A single period ( . ) indicate current node . For example , Extensible HTML ( XHTML ) document ( XML document look like HTML well form accord XML rule ) , path /h1/h2/ would indicate h2 element h1 . ( Recall XML , element name case-sensitive , kind specification work much well XHTML would plain HTML , HTML case-insensitive ) . In pattern-matching specification XPath , specification /h1/h2 select h2 element lie h1 element . To select specific h2 element , use square bracket [ ] index ( like use array ) . The path /h1 [ 4 ] /h2 [ 5 ] would therefore select fifth h2 element fourth h1 element . Note - In XHTML , element name lowercase . That fairly common convention XML document . However , uppercase name easy read tutorial like one . So remainder XSLT lesson , XML element name uppercase . ( Attribute names , hand , remain lowercase ) . A name specify XPath expression refers element . For example , h1 /h1/h2 refers h1 element . To refer attribute , prefix attribute name @ sign . For example , @ type refers type attribute element . Assuming XML document LIST element , example , expression LIST/ @ type select type attribute LIST element . Note - Because expression begin / , reference specify list node relative current context-whatever position document happen . Basic XPath Expressions The full range XPath expression take advantage wild card , operator , function XPath defines . You learn shortly . Here , look couple common XPath expression simply introduce . The expression @ type= '' unordered '' specifies attribute name type whose value unordered . An expression LIST/ @ type specify type attribute LIST element . You combine two notation get something interesting . In XPath , square-bracket notation ( [ ] ) normally associate indexing extend specify selection criterion . So expression LIST [ @ type= '' unordered '' ] select LIST element whose type value unordered . Similar expression exist element . Each element associate string-value , form concatenate text segment lie element . ( A detailed explanation process work present String-Value Element ) . Suppose model go organization use XML structure consist PROJECT element ACTIVITY element text string project name , multiple PERSON element list people involve , optionally , STATUS element record project status . Here example use extended square-bracket notation : /PROJECT [ .= '' MyProject '' ] : Selects PROJECT name `` MyProject '' . /PROJECT [ STATUS ] : Selects project STATUS child element . /PROJECT [ STATUS= '' Critical '' ] : Selects project STATUS child element string-value Critical . Combining Index Addresses The XPath specification define quite addressing mechanism , combine many different way . As result , XPath delivers lot expressive power relatively simple specification . This section illustrate interesting combination : LIST [ @ type= '' order '' ] [ 3 ] : Selects LIST element type order , return third . LIST [ 3 ] [ @ type= '' order '' ] : Selects third LIST element , type order . Note - Many combination address operator list section 2.5 XPath specification . This arguably useful section specification define XSLT transform . Wild Cards By definition , unqualified XPath expression select set XML node match specified pattern . For example , /HEAD match top-level HEAD entry , whereas /HEAD [ 1 ] match first . Table 4-1 list wild card use XPath expression broaden scope pattern matching . Table 4-1 XPath Wild Cards Wild card Meaning * Matches element node ( attribute text ) . node ( ) Matches node kind : element node , text node , attribute node , process instruction node , namespace node , comment node . @ * Matches attribute node . In project database example , /*/PERSON [ .= '' Fred '' ] match PROJECT ACTIVITY element name Fred . Extended-Path Addressing So far , pattern see specify exact number level hierarchy . For example , /HEAD specify HEAD element first level hierarchy , whereas /*/* specify element second level hierarchy . To specify indeterminate level hierarchy , use double forward slash ( // ) . For example , XPath expression //PARA select paragraph element document , wherever may find . The // pattern also use within path . So expression /HEAD/LIST//PARA indicate paragraph element subtree begin /HEAD/LIST . XPath Data Types Operators XPath expression yield either set node , string , Boolean ( true/false value ) , number . Table 4-2 list operator use Xpath expression : Table 4-2 XPath Operators Operator Meaning | Alternative . For example , PARA|LIST select PARA LIST element . , Returns or/and two Boolean value . = , ! = Equal equal , Booleans , string , number . < , > , < = , > = Less , great , less equal , great equal , number . + , - , * , div , mod Add , subtract , multiply , floating-point divide , modulus ( remainder ) operation ( e.g. , 6 mod 4 = 2 ) . Expressions group parenthesis , worry operator precedence . Note - Operator precedence term answer question , `` If specify + b * c , mean ( a+b ) * c + ( b*c ) ? '' ( The operator precedence roughly show table ) . String-Value Element The string-value element concatenation descendent text node , matter deep . Consider mixed-content XML data : < PARA > This paragraph contain < b > bold < /b > word < /PARA > The string-value < PARA > element This paragraph contain bold word . In particular , note < B > child < PARA > text bold child < B > . The point text child node join concatenation form string-value . Also , worth understand text abstract data model define XPath fully normalize . So whether XML structure contain entity reference & lt ; < CDATA section , element 's string-value contain < character . Therefore , generate HTML XML XSLT stylesheet , must convert occurrence < & lt ; enclose CDATA section . Similarly , occurrence & must convert & amp ; . XPath Functions This section end overview XPath function . You use XPath function select collection node way would use element specification already see . Other function return string , number , Boolean value . For example , expression /PROJECT/text ( ) get string-value PROJECT node . Many function depend current context . In preceding example , context invocation text ( ) function PROJECT node currently select . There many XPath function - many describe detail . This section provide brief listing show available XPath function , along summary . For information function , see section 4 XPath specification . Node-Set Functions Many XPath expression select set node . In essence , return node-set . One function , . The id ( ... ) function return node specify ID . ( Elements ID document DTD , specify attribute ID type ) . Positional Functions These function return positionally base numeric value . last ( ) : Returns index last element . For example , /HEAD [ last ( ) ] select last HEAD element . position ( ) : Returns index position . For example , /HEAD [ position ( ) < = 5 ] select first five HEAD element . count ( ... ) : Returns count element . For example , /HEAD [ count ( HEAD ) =0 ] selects HEAD element subhead . String Functions These function operate return string . concat ( string , string , ... ) : Concatenates string value . starts-with ( string1 , string2 ) : Returns true string1 start string2 . contains ( string1 , string2 ) : Returns true string1 contains string2 . substring-before ( string1 , string2 ) : Returns start string1 string2 occurs . substring-after ( string1 , string2 ) : Returns remainder string1 string2 occurs . substring ( string , idx ) : Returns substring index position end , index first char = 1. substring ( string , idx , len ) : Returns substring specified length index position . string-length ( ) : Returns size context node 's string-value ; context node currently select node-the node select XPath expression function string-length ( ) apply . string-length ( string ) : Returns size specified string . normalize-space ( ) : Returns normalized string-value current node ( lead trail white space , sequence white space character convert single space ) . normalize-space ( string ) : Returns normalized string-value specified string . translate ( string1 , string2 , string3 ) : Converts string1 , replace occurrence character string2 corresponding character string3 . Note - XPath defines three way get text element : text ( ) , string ( object ) , string-value imply element name expression like : /PROJECT [ PERSON= '' Fred '' ] . Boolean Functions These function operate return Boolean value . ( ... ) : Negates specified Boolean value . true ( ) : Returns true . false ( ) : Returns false . lang ( string ) : Returns true language context node ( specify xml : Lang attribute ) ( sub-language ) specified language ; example , Lang ( `` en '' ) true < PARA_xml : Lang= '' en '' > ... < /PARA > . Numeric Functions These function operate return numeric value . sum ( ... ) : Returns sum numeric value node specified node-set . floor ( N ) : Returns large integer great N. ceiling ( N ) : Returns small integer less N. round ( N ) : Returns integer closest N. Conversion Functions These function convert one data type another . string ( ... ) : Returns string value number , Boolean , node-set . boolean ( ... ) : Returns Boolean value number , string , node-set ( non-zero number , non-empty node-set , non-empty string true ) . number ( ... ) : Returns numeric value Boolean , string , node-set ( true 1 , false 0 , string contain number become number , string-value node-set convert number ) . Namespace Functions These function let determine namespace characteristic node . local-name ( ) : Returns name current node , minus namespace prefix . local-name ( ... ) : Returns name first node specified node set , minus namespace prefix . namespace-uri ( ) : Returns namespace URI current node . namespace-uri ( ... ) : Returns namespace URI first node specified node-set . name ( ) : Returns expand name ( URI plus local name ) current node . name ( ... ) : Returns expand name ( URI plus local name ) first node specified node-set . Summary XPath operator , function , wild card , node-addressing mechanism combine wide variety way . The introduction far give good head start specify pattern need particular purpose .