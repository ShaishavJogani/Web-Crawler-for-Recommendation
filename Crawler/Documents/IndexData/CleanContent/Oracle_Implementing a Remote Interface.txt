This section discuss task implement class compute engine . In general , class implement remote interface least following : Declare remote interface implement Define constructor remote object Provide implementation remote method remote interface An RMI server program need create initial remote object export RMI runtime , make available receive incoming remote invocation . This setup procedure either encapsulate method remote object implementation class include another class entirely . The setup procedure following : Create install security manager Create export one remote object Register least one remote object RMI registry ( another name service , service accessible Java Naming Directory Interface ) bootstrapping purpose The complete implementation compute engine follow . The engine.ComputeEngine class implement remote interface Compute also include main method set compute engine . Here source code ComputeEngine class : package engine ; import java.rmi.RemoteException ; import java.rmi.registry.LocateRegistry ; import java.rmi.registry.Registry ; import java.rmi.server.UnicastRemoteObject ; import compute.Compute ; import compute.Task ; public class ComputeEngine implement Compute { public ComputeEngine ( ) { super ( ) ; } public < T > T executeTask ( Task < T > ) { return t.execute ( ) ; } public static void main ( String [ ] args ) { ( System.getSecurityManager ( ) == null ) { System.setSecurityManager ( new SecurityManager ( ) ) ; } try { String name = `` Compute '' ; Compute engine = new ComputeEngine ( ) ; Compute stub = ( Compute ) UnicastRemoteObject.exportObject ( engine , 0 ) ; Registry registry = LocateRegistry.getRegistry ( ) ; registry.rebind ( name , stub ) ; System.out.println ( `` ComputeEngine bound '' ) ; } catch ( Exception e ) { System.err.println ( `` ComputeEngine exception : '' ) ; e.printStackTrace ( ) ; } } } The following section discuss component compute engine implementation . Declaring Remote Interfaces Being Implemented The implementation class compute engine declare follow : public class ComputeEngine implement Compute This declaration state class implement Compute remote interface therefore use remote object . The ComputeEngine class define remote object implementation class implement single remote interface interface . The ComputeEngine class also contain two executable program element invoke locally . The first element constructor ComputeEngine instance . The second element main method use create ComputeEngine instance make available client . Defining Constructor Remote Object The ComputeEngine class single constructor take argument . The code constructor follow : public ComputeEngine ( ) { super ( ) ; } This constructor invoke superclass constructor , no-argument constructor Object class . Although superclass constructor get invoke even omit ComputeEngine constructor , include clarity . Providing Implementations Each Remote Method The class remote object provide implementation remote method specify remote interface . The Compute interface contain single remote method , executeTask , implement follow : public < T > T executeTask ( Task < T > ) { return t.execute ( ) ; } This method implement protocol ComputeEngine remote object client . Each client provide ComputeEngine Task object particular implementation Task interface 's execute method . The ComputeEngine execute client 's task return result task 's execute method directly client . Passing Objects RMI Arguments return value remote method almost type , include local object , remote object , primitive data type . More precisely , entity type pass remote method long entity instance type primitive data type , remote object , serializable object , mean implement interface java.io.Serializable . Some object type meet criterion thus pass return remote method . Most object , thread file descriptor , encapsulate information make sense within single address space . Many core class , include class package java.lang java.util , implement Serializable interface . The rule govern argument return value pass follow : Remote object essentially pass reference . A remote object reference stub , client-side proxy implement complete set remote interface remote object implement . Local object pass copy , use object serialization . By default , field copy except field mark static transient . Default serialization behavior override class-by-class basis . Passing remote object reference mean change make state object remote method invocation reflect original remote object . When remote object pass , interface remote interface available receiver . Any method define implementation class define non-remote interface implement class available receiver . For example , pass reference instance ComputeEngine class , receiver would access compute engine 's executeTask method . That receiver would see ComputeEngine constructor , main method , implementation method java.lang.Object . In parameter return value remote method invocation , object remote object pass value . Thus , copy object create receiving Java virtual machine . Any change object 's state receiver reflect receiver 's copy , sender 's original instance . Any change object 's state sender reflect sender 's original instance , receiver 's copy . Implementing Server 's main Method The complex method ComputeEngine implementation main method . The main method use start ComputeEngine therefore need necessary initialization housekeeping prepare server accept call client . This method remote method , mean invoke different Java virtual machine . Because main method declare static , method associate object rather class ComputeEngine . Creating Installing Security Manager The main method 's first task create install security manager , protect access system resource untrusted downloaded code run within Java virtual machine . A security manager determine whether download code access local file system perform privileged operation . If RMI program install security manager , RMI download class ( local class path ) object receive argument return value remote method invocation . This restriction ensure operation perform downloaded code subject security policy . Here 's code create install security manager : ( System.getSecurityManager ( ) == null ) { System.setSecurityManager ( new SecurityManager ( ) ) ; } Making Remote Object Available Clients Next , main method create instance ComputeEngine export RMI runtime following statement : Compute engine = new ComputeEngine ( ) ; Compute stub = ( Compute ) UnicastRemoteObject.exportObject ( engine , 0 ) ; The static UnicastRemoteObject.exportObject method export supplied remote object receive invocation remote method remote client . The second argument , int , specifies TCP port use listen incoming remote invocation request object . It common use value zero , specify use anonymous port . The actual port choose runtime RMI underlie operating system . However , non-zero value also use specify specific port use listening . Once exportObject invocation return successfully , ComputeEngine remote object ready process incoming remote invocation . The exportObject method return stub exported remote object . Note type variable stub must Compute , ComputeEngine , stub remote object implement remote interface exported remote object implement . The exportObject method declare throw RemoteException , checked exception type . The main method handle exception try/catch block . If exception handle way , RemoteException would declare throw clause main method . An attempt export remote object throw RemoteException necessary communication resource available , request port bind purpose . Before client invoke method remote object , must first obtain reference remote object . Obtaining reference way object reference obtain program , get reference part return value method part data structure contain reference . The system provide particular type remote object , RMI registry , find reference remote object . The RMI registry simple remote object name service enable client obtain reference remote object name . The registry typically use locate first remote object RMI client need use . That first remote object might provide support find object . The java.rmi.registry.Registry remote interface API bind ( register ) look remote object registry . The java.rmi.registry.LocateRegistry class provide static method synthesize remote reference registry particular network address ( host port ) . These method create remote reference object contain specify network address without perform remote communication . LocateRegistry also provide static method create new registry current Java virtual machine , although example use method . Once remote object register RMI registry local host , client host look remote object name , obtain reference , invoke remote method object . The registry share server run host , individual server process create use registry . The ComputeEngine class create name object following statement : String name = `` Compute '' ; The code add name RMI registry run server . This step later following statement : Registry registry = LocateRegistry.getRegistry ( ) ; registry.rebind ( name , stub ) ; This rebind invocation make remote call RMI registry local host . Like remote call , call result RemoteException throw , handle catch block end main method . Note follow Registry.rebind invocation : The no-argument overload LocateRegistry.getRegistry synthesize reference registry local host default registry port , 1099 . You must use overload int parameter registry create port 1099 . When remote invocation registry make , stub remote object pass instead copy remote object . Remote implementation object , instance ComputeEngine , never leave Java virtual machine create . Thus , client perform lookup server 's remote object registry , copy stub return . Remote object case thus effectively pass ( remote ) reference rather value . For security reason , application bind , unbind , rebind remote object reference registry run host . This restriction prevent remote client remove overwrite entry server 's registry . A lookup , however , request host , local remote . Once server register local RMI registry , print message indicate ready start handle call . Then , main method completes . It necessary thread wait keep server alive . As long reference ComputeEngine object another Java virtual machine , local remote , ComputeEngine object shut garbage collect . Because program bind reference ComputeEngine registry , reachable remote client , registry . The RMI system keep ComputeEngine 's process running . The ComputeEngine available accept call wo n't reclaim binding remove registry remote client hold remote reference ComputeEngine object . The final piece code ComputeEngine.main method handle exception might arise . The checked exception type could throw code RemoteException , either UnicastRemoteObject.exportObject invocation registry rebind invocation . In either case , program much exit print error message . In distributed application , recover failure make remote invocation possible . For example , application could attempt retry operation choose another server continue operation .