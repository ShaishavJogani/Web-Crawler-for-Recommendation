Parallel compute involves divide problem subproblems , solve problem simultaneously ( parallel , subproblem run separate thread ) , combine result solution subproblems . Java SE provide fork/join framework , enable easily implement parallel compute application . However , framework , must specify problem subdivide ( partition ) . With aggregate operation , Java runtime performs partitioning combining solution . One difficulty implement parallelism application use collection collection thread-safe , mean multiple thread manipulate collection without introduce thread interference memory consistency error . The Collections Framework provide synchronization wrapper , add automatic synchronization arbitrary collection , make thread-safe . However , synchronization introduces thread contention . You want avoid thread contention prevent thread run parallel . Aggregate operation parallel stream enable implement parallelism non-thread-safe collection provide modify collection operate . Note parallelism automatically faster perform operation serially , although enough data processor core . While aggregate operation enable easily implement parallelism , still responsibility determine application suitable parallelism . This section cover following topic : Executing Streams Parallel Concurrent Reduction Ordering Side Effects Laziness Interference Stateful Lambda Expressions You find code excerpt describe section example ParallelismExamples . Executing Streams Parallel You execute stream serial parallel . When stream execute parallel , Java runtime partition stream multiple substreams . Aggregate operation iterate process substreams parallel combine result . When create stream , always serial stream unless otherwise specify . To create parallel stream , invoke operation Collection.parallelStream . Alternatively , invoke operation BaseStream.parallel . For example , following statement calculate average age male member parallel : double average = roster .parallelStream ( ) .filter ( p - > p.getGender ( ) == Person.Sex.MALE ) .mapToInt ( Person : :getAge ) .average ( ) .getAsDouble ( ) ; Concurrent Reduction Consider following example ( describe section Reduction ) group member gender . This example invoke collect operation , reduce collection roster Map : Map < Person.Sex , List < Person > > byGender = roster .stream ( ) .collect ( Collectors.groupingBy ( Person : :getGender ) ) ; The following parallel equivalent : ConcurrentMap < Person.Sex , List < Person > > byGender = roster .parallelStream ( ) .collect ( Collectors.groupingByConcurrent ( Person : :getGender ) ) ; This call concurrent reduction . The Java runtime perform concurrent reduction following true particular pipeline contain collect operation : The stream parallel . The parameter collect operation , collector , characteristic Collector.Characteristics.CONCURRENT . To determine characteristic collector , invoke Collector.characteristics method . Either stream unordered , collector characteristic Collector.Characteristics.UNORDERED . To ensure stream unordered , invoke BaseStream.unordered operation . Note : This example return instance ConcurrentMap instead Map invoke groupingByConcurrent operation instead groupingBy . ( See section Concurrent Collections information ConcurrentMap . ) Unlike operation groupingByConcurrent , operation groupingBy performs poorly parallel stream . ( This operate merge two map key , computationally expensive . ) Similarly , operation Collectors.toConcurrentMap perform well parallel stream operation Collectors.toMap . Ordering The order pipeline process element stream depend whether stream execute serial parallel , source stream , intermediate operation . For example , consider following example print element instance ArrayList forEach operation several time : Integer [ ] intArray = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; List < Integer > listOfIntegers = new ArrayList < > ( Arrays.asList ( intArray ) ) ; System.out.println ( `` listOfIntegers : '' ) ; listOfIntegers .stream ( ) .forEach ( e - > System.out.print ( e + `` `` ) ) ; System.out.println ( `` '' ) ; System.out.println ( `` listOfIntegers sort reverse order : '' ) ; Comparator < Integer > normal = Integer : :compare ; Comparator < Integer > reverse = normal.reversed ( ) ; Collections.sort ( listOfIntegers , reverse ) ; listOfIntegers .stream ( ) .forEach ( e - > System.out.print ( e + `` `` ) ) ; System.out.println ( `` '' ) ; System.out.println ( `` Parallel stream '' ) ; listOfIntegers .parallelStream ( ) .forEach ( e - > System.out.print ( e + `` `` ) ) ; System.out.println ( `` '' ) ; System.out.println ( `` Another parallel stream : '' ) ; listOfIntegers .parallelStream ( ) .forEach ( e - > System.out.print ( e + `` `` ) ) ; System.out.println ( `` '' ) ; System.out.println ( `` With forEachOrdered : '' ) ; listOfIntegers .parallelStream ( ) .forEachOrdered ( e - > System.out.print ( e + `` `` ) ) ; System.out.println ( `` '' ) ; This example consist five pipeline . It print output similar following : listOfIntegers : 1 2 3 4 5 6 7 8 listOfIntegers sort reverse order : 8 7 6 5 4 3 2 1 Parallel stream : 3 4 1 6 2 5 7 8 Another parallel stream : 6 3 1 5 7 8 4 2 With forEachOrdered : 8 7 6 5 4 3 2 1 This example following : The first pipeline print element list listOfIntegers order add list . The second pipeline print element listOfIntegers sort method Collections.sort . The third fourth pipeline print element list apparently random order . Remember stream operation use internal iteration process element stream . Consequently , execute stream parallel , Java compiler runtime determine order process stream 's element maximize benefit parallel compute unless otherwise specify stream operation . The fifth pipeline use method forEachOrdered , process element stream order specify source , regardless whether execute stream serial parallel . Note may lose benefit parallelism use operation like forEachOrdered parallel stream . Side Effects A method expression side effect , addition return produce value , also modify state computer . Examples include mutable reduction ( operation use collect operation ; see section Reduction information ) well invoke System.out.println method debug . The JDK handle certain side effect pipeline well . In particular , collect method design perform common stream operation side effect parallel-safe manner . Operations like forEach peek design side effect ; lambda expression return void , one invoke System.out.println , nothing side effect . Even , use forEach peek operation care ; use one operation parallel stream , Java runtime may invoke lambda expression specify parameter concurrently multiple thread . In addition , never pas parameter lambda expression side effect operation filter map . The following section discuss interference stateful lambda expression , source side effect return inconsistent unpredictable result , especially parallel stream . However , concept laziness discuss first , direct effect interference . Laziness All intermediate operation lazy . An expression , method , algorithm lazy value evaluate require . ( An algorithm eager evaluate process immediately . ) Intermediate operation lazy start process content stream terminal operation commences . Processing stream lazily enable Java compiler runtime optimize process stream . For example , pipeline filter-mapToInt-average example describe section Aggregate Operations , average operation could obtain first several integer stream create mapToInt operation , obtain element filter operation . The average operation would repeat process obtain required element stream , would calculate average . Interference Lambda expression stream operation interfere . Interference occur source stream modify pipeline process stream . For example , following code attempt concatenate string contain List listOfStrings . However , throw ConcurrentModificationException : try { List < String > listOfStrings = new ArrayList < > ( Arrays.asList ( `` one '' , `` two '' ) ) ; // This fail peek operation attempt add // string `` three '' source terminal operation // commence . String concatenatedString = listOfStrings .stream ( ) // Do n't ! Interference occur . .peek ( - > listOfStrings.add ( `` three '' ) ) .reduce ( ( , b ) - > + `` `` + b ) .get ( ) ; System.out.println ( `` Concatenated string : `` + concatenatedString ) ; } catch ( Exception e ) { System.out.println ( `` Exception caught : `` + e.toString ( ) ) ; } This example concatenate string contain listOfStrings Optional < String > value reduce operation , terminal operation . However , pipeline invoke intermediate operation peek , attempt add new element listOfStrings . Remember , intermediate operation lazy . This mean pipeline example begin execution operation get invoke , end execution get operation completes . The argument peek operation attempt modify stream source execution pipeline , cause Java runtime throw ConcurrentModificationException . Stateful Lambda Expressions Avoid use stateful lambda expression parameter stream operation . A stateful lambda expression one whose result depend state might change execution pipeline . The following example add element List listOfIntegers new List instance map intermediate operation . It twice , first serial stream parallel stream : List < Integer > serialStorage = new ArrayList < > ( ) ; System.out.println ( `` Serial stream : '' ) ; listOfIntegers .stream ( ) // Do n't ! It use stateful lambda expression . .map ( e - > { serialStorage.add ( e ) ; return e ; } ) .forEachOrdered ( e - > System.out.print ( e + `` `` ) ) ; System.out.println ( `` '' ) ; serialStorage .stream ( ) .forEachOrdered ( e - > System.out.print ( e + `` `` ) ) ; System.out.println ( `` '' ) ; System.out.println ( `` Parallel stream : '' ) ; List < Integer > parallelStorage = Collections.synchronizedList ( new ArrayList < > ( ) ) ; listOfIntegers .parallelStream ( ) // Do n't ! It use stateful lambda expression . .map ( e - > { parallelStorage.add ( e ) ; return e ; } ) .forEachOrdered ( e - > System.out.print ( e + `` `` ) ) ; System.out.println ( `` '' ) ; parallelStorage .stream ( ) .forEachOrdered ( e - > System.out.print ( e + `` `` ) ) ; System.out.println ( `` '' ) ; The lambda expression e - > { parallelStorage.add ( e ) ; return e ; } stateful lambda expression . Its result vary every time code run . This example print following : Serial stream : 8 7 6 5 4 3 2 1 8 7 6 5 4 3 2 1 Parallel stream : 8 7 6 5 4 3 2 1 1 3 6 2 4 5 8 7 The operation forEachOrdered process element order specify stream , regardless whether stream execute serial parallel . However , stream execute parallel , map operation process element stream specify Java runtime compiler . Consequently , order lambda expression e - > { parallelStorage.add ( e ) ; return e ; } add element List parallelStorage vary every time code run . For deterministic predictable result , ensure lambda expression parameter stream operation stateful . Note : This example invoke method synchronizedList List parallelStorage thread-safe . Remember collection thread-safe . This mean multiple thread access particular collection time . Suppose invoke method synchronizedList create parallelStorage : List < Integer > parallelStorage = new ArrayList < > ( ) ; The example behave erratically multiple thread access modify parallelStorage without mechanism like synchronization schedule particular thread may access List instance . Consequently , example could print output similar following : Parallel stream : 8 7 6 5 4 3 2 1 null 3 5 4 7 8 1 2