One issue anonymous class implementation anonymous class simple , interface contain one method , syntax anonymous class may seem unwieldy unclear . In case , 're usually try pass functionality argument another method , action take someone click button . Lambda expression enable , treat functionality method argument , code data . The previous section , Anonymous Classes , show implement base class without give name . Although often concise named class , class one method , even anonymous class seem bit excessive cumbersome . Lambda expression let express instance single-method class compactly . This section cover following topic : Ideal Use Case Lambda Expressions Approach 1 : Create Methods That Search Members That Match One Characteristic Approach 2 : Create More Generalized Search Methods Approach 3 : Specify Search Criteria Code Local Class Approach 4 : Specify Search Criteria Code Anonymous Class Approach 5 : Specify Search Criteria Code Lambda Expression Approach 6 : Use Standard Functional Interfaces Lambda Expressions Approach 7 : Use Lambda Expressions Throughout Your Application Approach 8 : Use Generics More Extensively Approach 9 : Use Aggregate Operations That Accept Lambda Expressions Parameters Lambda Expressions GUI Applications Syntax Lambda Expressions Accessing Local Variables Enclosing Scope Target Typing Target Types Method Arguments Serialization Ideal Use Case Lambda Expressions Suppose create social networking application . You want create feature enable administrator perform kind action , send message , member social networking application satisfy certain criterion . The follow table describes use case detail : Field Description Name Perform action select member Primary Actor Administrator Preconditions Administrator log system . Postconditions Action perform member fit specified criterion . Main Success Scenario Administrator specify criterion member perform certain action . Administrator specify action perform select member . Administrator select Submit button . The system find member match specified criterion . The system perform specified action match member . Extensions 1a . Administrator option preview member match specified criterion specify action perform select Submit button . Frequency Occurrence Many time day . Suppose member social networking application represent follow Person class : public class Person { public enum Sex { MALE , FEMALE } String name ; LocalDate birthday ; Sex gender ; String emailAddress ; public int getAge ( ) { // ... } public void printPerson ( ) { // ... } } Suppose member social networking application store List < Person > instance . This section begin naive approach use case . It improve upon approach local anonymous class , finish efficient concise approach use lambda expression . Find code excerpt describe section example RosterTest . Approach 1 : Create Methods That Search Members That Match One Characteristic One simplistic approach create several method ; method search member match one characteristic , gender age . The following method print member old specified age : public static void printPersonsOlderThan ( List < Person > roster , int age ) { ( Person p : roster ) { ( p.getAge ( ) > = age ) { p.printPerson ( ) ; } } } Note : A List ordered Collection . A collection object group multiple element single unit . Collections use store , retrieve , manipulate , communicate aggregate data . For information collection , see Collections trail . This approach potentially make application brittle , likelihood application work introduction update ( new data type ) . Suppose upgrade application change structure Person class contain different member variable ; perhaps class record measure age different data type algorithm . You would rewrite lot API accommodate change . In addition , approach unnecessarily restrictive ; want print member young certain age , example ? Approach 2 : Create More Generalized Search Methods The following method generic printPersonsOlderThan ; print member within specified range age : public static void printPersonsWithinAgeRange ( List < Person > roster , int low , int high ) { ( Person p : roster ) { ( low < = p.getAge ( ) & & p.getAge ( ) < high ) { p.printPerson ( ) ; } } } What want print member specified sex , combination specify gender age range ? What decide change Person class add attribute relationship status geographical location ? Although method generic printPersonsOlderThan , try create separate method possible search query still lead brittle code . You instead separate code specify criterion want search different class . Approach 3 : Specify Search Criteria Code Local Class The following method print member match search criterion specify : public static void printPersons ( List < Person > roster , CheckPerson tester ) { ( Person p : roster ) { ( tester.test ( p ) ) { p.printPerson ( ) ; } } } This method check Person instance contain List parameter roster whether satisfy search criterion specify CheckPerson parameter tester invoke method tester.test . If method tester.test return true value , method printPersons invoke Person instance . To specify search criterion , implement CheckPerson interface : interface CheckPerson { boolean test ( Person p ) ; } The following class implement CheckPerson interface specify implementation method test . This method filter member eligible Selective Service United States : return true value Person parameter male age 18 25 : class CheckPersonEligibleForSelectiveService implement CheckPerson { public boolean test ( Person p ) { return p.gender == Person.Sex.MALE & & p.getAge ( ) > = 18 & & p.getAge ( ) < = 25 ; } } To use class , create new instance invoke printPersons method : printPersons ( roster , new CheckPersonEligibleForSelectiveService ( ) ) ; Although approach less brittle—you n't rewrite method change structure Person—you still additional code : new interface local class search plan perform application . Because CheckPersonEligibleForSelectiveService implement interface , use anonymous class instead local class bypass need declare new class search . Approach 4 : Specify Search Criteria Code Anonymous Class One argument following invocation method printPersons anonymous class filter member eligible Selective Service United States : male age 18 25 : printPersons ( roster , new CheckPerson ( ) { public boolean test ( Person p ) { return p.getGender ( ) == Person.Sex.MALE & & p.getAge ( ) > = 18 & & p.getAge ( ) < = 25 ; } } ) ; This approach reduce amount code require n't create new class search want perform . However , syntax anonymous class bulky consider CheckPerson interface contain one method . In case , use lambda expression instead anonymous class , describe next section . Approach 5 : Specify Search Criteria Code Lambda Expression The CheckPerson interface functional interface . A functional interface interface contain one abstract method . ( A functional interface may contain one default method static method . ) Because functional interface contain one abstract method , omit name method implement . To , instead use anonymous class expression , use lambda expression , highlight following method invocation : printPersons ( roster , ( Person p ) - > p.getGender ( ) == Person.Sex.MALE & & p.getAge ( ) > = 18 & & p.getAge ( ) < = 25 ) ; See Syntax Lambda Expressions information define lambda expression . You use standard functional interface place interface CheckPerson , reduce even far amount code require . Approach 6 : Use Standard Functional Interfaces Lambda Expressions Reconsider CheckPerson interface : interface CheckPerson { boolean test ( Person p ) ; } This simple interface . It 's functional interface contain one abstract method . This method take one parameter return boolean value . The method simple might worth define one application . Consequently , JDK define several standard functional interface , find package java.util.function . For example , use Predicate < T > interface place CheckPerson . This interface contain method boolean test ( T ) : interface Predicate < T > { boolean test ( T ) ; } The interface Predicate < T > example generic interface . ( For information generic , see Generics ( Updated ) lesson . ) Generic type ( generic interface ) specify one type parameter within angle bracket ( < > ) . This interface contain one type parameter , T. When declare instantiate generic type actual type argument , parameterized type . For example , parameterized type Predicate < Person > following : interface Predicate < Person > { boolean test ( Person ) ; } This parameterized type contain method return type parameter CheckPerson.boolean test ( Person p ) . Consequently , use Predicate < T > place CheckPerson following method demonstrate : public static void printPersonsWithPredicate ( List < Person > roster , Predicate < Person > tester ) { ( Person p : roster ) { ( tester.test ( p ) ) { p.printPerson ( ) ; } } } As result , following method invocation invoke printPersons Approach 3 : Specify Search Criteria Code Local Class obtain member eligible Selective Service : printPersonsWithPredicate ( roster , p - > p.getGender ( ) == Person.Sex.MALE & & p.getAge ( ) > = 18 & & p.getAge ( ) < = 25 ) ; This possible place method use lambda expression . The following approach suggest way use lambda expression . Approach 7 : Use Lambda Expressions Throughout Your Application Reconsider method printPersonsWithPredicate see else could use lambda expression : public static void printPersonsWithPredicate ( List < Person > roster , Predicate < Person > tester ) { ( Person p : roster ) { ( tester.test ( p ) ) { p.printPerson ( ) ; } } } This method check Person instance contain List parameter roster whether satisfy criterion specify Predicate parameter tester . If Person instance satisfy criterion specify tester , method printPersron invoke Person instance . Instead invoke method printPerson , specify different action perform Person instance satisfy criterion specify tester . You specify action lambda expression . Suppose want lambda expression similar printPerson , one take one argument ( object type Person ) return void . Remember , use lambda expression , need implement functional interface . In case , need functional interface contain abstract method take one argument type Person return void . The Consumer < T > interface contain method void accept ( T ) , characteristic . The following method replace invocation p.printPerson ( ) instance Consumer < Person > invoke method accept : public static void processPersons ( List < Person > roster , Predicate < Person > tester , Consumer < Person > block ) { ( Person p : roster ) { ( tester.test ( p ) ) { block.accept ( p ) ; } } } As result , following method invocation invoke printPersons Approach 3 : Specify Search Criteria Code Local Class obtain member eligible Selective Service . The lambda expression use print member highlight : processPersons ( roster , p - > p.getGender ( ) == Person.Sex.MALE & & p.getAge ( ) > = 18 & & p.getAge ( ) < = 25 , p - > p.printPerson ( ) ) ; What want member ' profile print . Suppose want validate member ' profile retrieve contact information ? In case , need functional interface contain abstract method return value . The Function < T , R > interface contain method R apply ( T ) . The following method retrieve data specify parameter mapper , perform action specify parameter block : public static void processPersonsWithFunction ( List < Person > roster , Predicate < Person > tester , Function < Person , String > mapper , Consumer < String > block ) { ( Person p : roster ) { ( tester.test ( p ) ) { String data = mapper.apply ( p ) ; block.accept ( data ) ; } } } The following method retrieve email address member contain roster eligible Selective Service print : processPersonsWithFunction ( roster , p - > p.getGender ( ) == Person.Sex.MALE & & p.getAge ( ) > = 18 & & p.getAge ( ) < = 25 , p - > p.getEmailAddress ( ) , email - > System.out.println ( email ) ) ; Approach 8 : Use Generics More Extensively Reconsider method processPersonsWithFunction . The following generic version accept , parameter , collection contain element data type : public static < X , Y > void processElements ( Iterable < X > source , Predicate < X > tester , Function < X , Y > mapper , Consumer < Y > block ) { ( X p : source ) { ( tester.test ( p ) ) { Y data = mapper.apply ( p ) ; block.accept ( data ) ; } } } To print e-mail address member eligible Selective Service , invoke processElements method follow : processElements ( roster , p - > p.getGender ( ) == Person.Sex.MALE & & p.getAge ( ) > = 18 & & p.getAge ( ) < = 25 , p - > p.getEmailAddress ( ) , email - > System.out.println ( email ) ) ; This method invocation perform following action : Obtains source object collection source . In example , obtain source Person object collection roster . Notice collection roster , collection type List , also object type Iterable . Filters object match Predicate object tester . In example , Predicate object lambda expression specifies member would eligible Selective Service . Maps filter object value specify Function object mapper . In example , Function object lambda expression return e-mail address member . Performs action mapped object specify Consumer object block . In example , Consumer object lambda expression print string , e-mail address return Function object . You replace action aggregate operation . Approach 9 : Use Aggregate Operations That Accept Lambda Expressions Parameters The following example use aggregate operation print e-mail address member contain collection roster eligible Selective Service : roster .stream ( ) .filter ( p - > p.getGender ( ) == Person.Sex.MALE & & p.getAge ( ) > = 18 & & p.getAge ( ) < = 25 ) .map ( p - > p.getEmailAddress ( ) ) .forEach ( email - > System.out.println ( email ) ) ; The follow table map operation method processElements perform corresponding aggregate operation : processElements Action Aggregate Operation Obtain source object Stream < E > stream ( ) Filter object match Predicate object Stream < T > filter ( Predicate < ? super T > predicate ) Map object another value specify Function object < R > Stream < R > map ( Function < ? super T , ? extends R > mapper ) Perform action specify Consumer object void forEach ( Consumer < ? super T > action ) The operation filter , map , forEach aggregate operation . Aggregate operation process element stream , directly collection ( reason first method invoke example stream ) . A stream sequence element . Unlike collection , data structure store element . Instead , stream carry value source , collection , pipeline . A pipeline sequence stream operation , example filter- map-forEach . In addition , aggregate operation typically accept lambda expression parameter , enable customize behave . For thorough discussion aggregate operation , see Aggregate Operations lesson . Lambda Expressions GUI Applications To process event graphical user interface ( GUI ) application , keyboard action , mouse action , scroll action , typically create event handler , usually involve implement particular interface . Often , event handler interface functional interface ; tend one method . In JavaFX example HelloWorld.java ( discuss previous section Anonymous Classes ) , replace highlight anonymous class lambda expression statement : btn.setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( ActionEvent event ) { System.out.println ( `` Hello World ! `` ) ; } } ) ; The method invocation btn.setOnAction specify happen select button represent btn object . This method require object type EventHandler < ActionEvent > . The EventHandler < ActionEvent > interface contain one method , void handle ( T event ) . This interface functional interface , could use following highlight lambda expression replace : btn.setOnAction ( event - > System.out.println ( `` Hello World ! '' ) ) ; Syntax Lambda Expressions A lambda expression consist following : A comma-separated list formal parameter enclose parenthesis . The CheckPerson.test method contain one parameter , p , represent instance Person class . Note : You omit data type parameter lambda expression . In addition , omit parenthesis one parameter . For example , following lambda expression also valid : p - > p.getGender ( ) == Person.Sex.MALE & & p.getAge ( ) > = 18 & & p.getAge ( ) < = 25 The arrow token , - > A body , consist single expression statement block . This example use following expression : p.getGender ( ) == Person.Sex.MALE & & p.getAge ( ) > = 18 & & p.getAge ( ) < = 25 If specify single expression , Java runtime evaluate expression return value . Alternatively , use return statement : p - > { return p.getGender ( ) == Person.Sex.MALE & & p.getAge ( ) > = 18 & & p.getAge ( ) < = 25 ; } A return statement expression ; lambda expression , must enclose statement brace ( { } ) . However , enclose void method invocation brace . For example , following valid lambda expression : email - > System.out.println ( email ) Note lambda expression look lot like method declaration ; consider lambda expression anonymous methods—methods without name . The following example , Calculator , example lambda expression take one formal parameter : public class Calculator { interface IntegerMath { int operation ( int , int b ) ; } public int operateBinary ( int , int b , IntegerMath op ) { return op.operation ( , b ) ; } public static void main ( String ... args ) { Calculator myApp = new Calculator ( ) ; IntegerMath addition = ( , b ) - > + b ; IntegerMath subtraction = ( , b ) - > - b ; System.out.println ( `` 40 + 2 = `` + myApp.operateBinary ( 40 , 2 , addition ) ) ; System.out.println ( `` 20 - 10 = `` + myApp.operateBinary ( 20 , 10 , subtraction ) ) ; } } The method operateBinary performs mathematical operation two integer operand . The operation specify instance IntegerMath . The example define two operation lambda expression , addition subtraction . The example print following : 40 + 2 = 42 20 - 10 = 10 Accessing Local Variables Enclosing Scope Like local anonymous class , lambda expression capture variable ; access local variable enclose scope . However , unlike local anonymous class , lambda expression shadowing issue ( see Shadowing information ) . Lambda expression lexically scoped . This mean inherit name supertype introduce new level scoping . Declarations lambda expression interpret enclosing environment . The following example , LambdaScopeTest , demonstrate : import java.util.function.Consumer ; public class LambdaScopeTest { public int x = 0 ; class FirstLevel { public int x = 1 ; void methodInFirstLevel ( int x ) { // The following statement cause compiler generate // error `` local variable reference lambda expression // must final effectively final '' statement A : // // x = 99 ; Consumer < Integer > myConsumer = ( ) - > { System.out.println ( `` x = `` + x ) ; // Statement A System.out.println ( `` = `` + ) ; System.out.println ( `` this.x = `` + this.x ) ; System.out.println ( `` LambdaScopeTest.this.x = `` + LambdaScopeTest.this.x ) ; } ; myConsumer.accept ( x ) ; } } public static void main ( String ... args ) { LambdaScopeTest st = new LambdaScopeTest ( ) ; LambdaScopeTest.FirstLevel fl = st.new FirstLevel ( ) ; fl.methodInFirstLevel ( 23 ) ; } } This example generate following output : x = 23 = 23 this.x = 1 LambdaScopeTest.this.x = 0 If substitute parameter x place declaration lambda expression myConsumer , compiler generate error : Consumer < Integer > myConsumer = ( x ) - > { // ... } The compiler generate error `` variable x already define method methodInFirstLevel ( int ) '' lambda expression introduce new level scoping . Consequently , directly access field , method , local variable enclose scope . For example , lambda expression directly access parameter x method methodInFirstLevel . To access variable enclosing class , use keyword . In example , this.x refers member variable FirstLevel.x . However , like local anonymous class , lambda expression access local variable parameter enclose block final effectively final . For example , suppose add following assignment statement immediately methodInFirstLevel definition statement : void methodInFirstLevel ( int x ) { x = 99 ; // ... } Because assignment statement , variable FirstLevel.x effectively final anymore . As result , Java compiler generate error message similar '' local variable reference lambda expression must final effectively final '' lambda expression myConsumer try access FirstLevel.x variable : System.out.println ( `` x = `` + x ) ; Target Typing How determine type lambda expression ? Recall lambda expression select member male age 18 25 year : p - > p.getGender ( ) == Person.Sex.MALE & & p.getAge ( ) > = 18 & & p.getAge ( ) < = 25 This lambda expression use following two method : public static void printPersons ( List < Person > roster , CheckPerson tester ) Approach 3 : Specify Search Criteria Code Local Class public void printPersonsWithPredicate ( List < Person > roster , Predicate < Person > tester ) Approach 6 : Use Standard Functional Interfaces Lambda Expressions When Java runtime invoke method printPersons , 's expect data type CheckPerson , lambda expression type . However , Java runtime invoke method printPersonsWithPredicate , 's expect data type Predicate < Person > , lambda expression type . The data type method expect call target type . To determine type lambda expression , Java compiler use target type context situation lambda expression find . It follow use lambda expression situation Java compiler determine target type : Variable declaration Assignments Return statement Array initializers Method constructor argument Lambda expression body Conditional expression , ? : Cast expression Target Types Method Arguments For method argument , Java compiler determine target type two language feature : overload resolution type argument inference . Consider follow two functional interface ( java.lang.Runnable java.util.concurrent.Callable < V > ) : public interface Runnable { void run ( ) ; } public interface Callable < V > { V call ( ) ; } The method Runnable.run return value , whereas Callable < V > .call . Suppose overload method invoke follow ( see Defining Methods information overload method ) : void invoke ( Runnable r ) { r.run ( ) ; } < T > T invoke ( Callable < T > c ) { return c.call ( ) ; } Which method invoke following statement ? String = invoke ( ( ) - > `` '' ) ; The method invoke ( Callable < T > ) invoke method return value ; method invoke ( Runnable ) . In case , type lambda expression ( ) - > `` '' Callable < T > . Serialization You serialize lambda expression target type captured argument serializable . However , like inner class , serialization lambda expression strongly discourage .