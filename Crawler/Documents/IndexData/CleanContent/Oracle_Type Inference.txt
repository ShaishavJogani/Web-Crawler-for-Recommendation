Type inference Java compiler 's ability look method invocation correspond declaration determine type argument ( argument ) make invocation applicable . The inference algorithm determine type argument , available , type result assign , return . Finally , inference algorithm try find specific type work argument . To illustrate last point , following example , inference determines second argument pass pick method type Serializable : static < T > T pick ( T a1 , T a2 ) { return a2 ; } Serializable = pick ( `` '' , new ArrayList < String > ( ) ) ; Type Inference Generic Methods Generic Methods introduce type inference , enable invoke generic method would ordinary method , without specify type angle bracket . Consider following example , BoxDemo , require Box class : public class BoxDemo { public static < U > void addBox ( U u , java.util.List < Box < U > > box ) { Box < U > box = new Box < > ( ) ; box.set ( u ) ; boxes.add ( box ) ; } public static < U > void outputBoxes ( java.util.List < Box < U > > box ) { int counter = 0 ; ( Box < U > box : box ) { U boxContents = box.get ( ) ; System.out.println ( `` Box # '' + counter + `` contains [ `` + boxContents.toString ( ) + `` ] '' ) ; counter++ ; } } public static void main ( String [ ] args ) { java.util.ArrayList < Box < Integer > > listOfIntegerBoxes = new java.util.ArrayList < > ( ) ; BoxDemo. < Integer > addBox ( Integer.valueOf ( 10 ) , listOfIntegerBoxes ) ; BoxDemo.addBox ( Integer.valueOf ( 20 ) , listOfIntegerBoxes ) ; BoxDemo.addBox ( Integer.valueOf ( 30 ) , listOfIntegerBoxes ) ; BoxDemo.outputBoxes ( listOfIntegerBoxes ) ; } } The following output example : Box # 0 contains [ 10 ] Box # 1 contains [ 20 ] Box # 2 contains [ 30 ] The generic method addBox define one type parameter name U . Generally , Java compiler infer type parameter generic method call . Consequently , case , specify . For example , invoke generic method addBox , specify type parameter type witness follow : BoxDemo. < Integer > addBox ( Integer.valueOf ( 10 ) , listOfIntegerBoxes ) ; Alternatively , omit type witness , Java compiler automatically infers ( method 's argument ) type parameter Integer : BoxDemo.addBox ( Integer.valueOf ( 20 ) , listOfIntegerBoxes ) ; Type Inference Instantiation Generic Classes You replace type argument require invoke constructor generic class empty set type parameter ( < > ) long compiler infer type argument context . This pair angle bracket informally call diamond . For example , consider follow variable declaration : Map < String , List < String > > myMap = new HashMap < String , List < String > > ( ) ; You substitute parameterized type constructor empty set type parameter ( < > ) : Map < String , List < String > > myMap = new HashMap < > ( ) ; Note take advantage type inference generic class instantiation , must use diamond . In following example , compiler generate unchecked conversion warning HashMap ( ) constructor refers HashMap raw type , Map < String , List < String > > type : Map < String , List < String > > myMap = new HashMap ( ) ; // unchecked conversion warn Type Inference Generic Constructors Generic Non-Generic Classes Note constructor generic ( word , declare formal type parameter ) generic non-generic class . Consider following example : class MyClass < X > { < T > MyClass ( T ) { // ... } } Consider following instantiation class MyClass : new MyClass < Integer > ( `` '' ) This statement create instance parameterized type MyClass < Integer > ; statement explicitly specify type Integer formal type parameter , X , generic class MyClass < X > . Note constructor generic class contain formal type parameter , T. The compiler infer type String formal type parameter , T , constructor generic class ( actual parameter constructor String object ) . Compilers release prior Java SE 7 able infer actual type parameter generic constructor , similar generic method . However , compiler Java SE 7 later infer actual type parameter generic class instantiate use diamond ( < > ) . Consider following example : MyClass < Integer > myObject = new MyClass < > ( `` '' ) ; In example , compiler infer type Integer formal type parameter , X , generic class MyClass < X > . It infer type String formal type parameter , T , constructor generic class . Note : It important note inference algorithm use invocation argument , target type , possibly obvious expect return type infer type . The inference algorithm use result later program . Target Types The Java compiler take advantage target type infer type parameter generic method invocation . The target type expression data type Java compiler expect depend expression appear . Consider method Collections.emptyList , declare follow : static < T > List < T > emptyList ( ) ; Consider following assignment statement : List < String > listOne = Collections.emptyList ( ) ; This statement expect instance List < String > ; data type target type . Because method emptyList return value type List < T > , compiler infers type argument T must value String . This work Java SE 7 8 . Alternatively , could use type witness specify value T follow : List < String > listOne = Collections. < String > emptyList ( ) ; However , necessary context . It necessary context , though . Consider following method : void processStringList ( List < String > stringList ) { // process stringList } Suppose want invoke method processStringList empty list . In Java SE 7 , following statement compile : processStringList ( Collections.emptyList ( ) ) ; The Java SE 7 compiler generates error message similar following : List < Object > convert List < String > The compiler require value type argument T start value Object . Consequently , invocation Collections.emptyList return value type List < Object > , incompatible method processStringList . Thus , Java SE 7 , must specify value value type argument follow : processStringList ( Collections. < String > emptyList ( ) ) ; This longer necessary Java SE 8 . The notion target type expand include method argument , argument method processStringList . In case , processStringList require argument type List < String > . The method Collections.emptyList return value List < T > , use target type List < String > , compiler infers type argument T value String . Thus , Java SE 8 , following statement compiles : processStringList ( Collections.emptyList ( ) ) ; See Target Typing Lambda Expressions information .