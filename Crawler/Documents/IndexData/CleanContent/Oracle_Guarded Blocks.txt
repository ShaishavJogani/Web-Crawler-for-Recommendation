Threads often coordinate action . The common coordination idiom guarded block . Such block begin poll condition must true block proceed . There number step follow order correctly . Suppose , example guardedJoy method must proceed share variable joy set another thread . Such method could , theory , simply loop condition satisfied , loop wasteful , since execute continuously wait . public void guardedJoy ( ) { // Simple loop guard . Wastes // processor time . Do n't ! ( ! joy ) { } System.out.println ( `` Joy achieve ! `` ) ; } A efficient guard invokes Object.wait suspend current thread . The invocation wait return another thread issue notification special event may occur — though necessarily event thread wait : public synchronize void guardedJoy ( ) { // This guard loop special event , may // event 're wait . ( ! joy ) { try { wait ( ) ; } catch ( InterruptedException e ) { } } System.out.println ( `` Joy efficiency achieve ! `` ) ; } Note : Always invoke wait inside loop test condition wait . Do n't assume interrupt particular condition wait , condition still true . Like many method suspend execution , wait throw InterruptedException . In example , ignore exception — care value joy . Why version guardedJoy synchronize ? Suppose object 're use invoke wait . When thread invoke d.wait , must intrinsic lock — otherwise error throw . Invoking wait inside synchronized method simple way acquire intrinsic lock . When wait invoke , thread release lock suspend execution . At future time , another thread acquire lock invoke Object.notifyAll , inform thread wait lock something important happen : public synchronize notifyJoy ( ) { joy = true ; notifyAll ( ) ; } Some time second thread release lock , first thread reacquires lock resume return invocation wait . Note : There second notification method , notify , wake single thread . Because notify n't allow specify thread wake , useful massively parallel application — , program large number thread , similar chore . In application , n't care thread get wake . Let 's use guard block create Producer-Consumer application . This kind application share data two thread : producer , create data , consumer , something . The two thread communicate use share object . Coordination essential : consumer thread must attempt retrieve data producer thread deliver , producer thread must attempt deliver new data consumer n't retrieve old data . In example , data series text message , share object type Drop : public class Drop { // Message send producer // consumer . private String message ; // True consumer wait // producer send message , // false producer wait // consumer retrieve message . private boolean empty = true ; public synchronize String take ( ) { // Wait message // available . ( empty ) { try { wait ( ) ; } catch ( InterruptedException e ) { } } // Toggle status . empty = true ; // Notify producer // status change . notifyAll ( ) ; return message ; } public synchronize void put ( String message ) { // Wait message // retrieve . ( ! empty ) { try { wait ( ) ; } catch ( InterruptedException e ) { } } // Toggle status . empty = false ; // Store message . this.message = message ; // Notify consumer status // change . notifyAll ( ) ; } } The producer thread , define Producer , send series familiar message . The string `` DONE '' indicate message send . To simulate unpredictable nature real-world application , producer thread pause random interval message . import java.util.Random ; public class Producer implement Runnable { private Drop drop ; public Producer ( Drop drop ) { this.drop = drop ; } public void run ( ) { String importantInfo [ ] = { `` Mares eat oat '' , `` Does eat oat '' , `` Little lambs eat ivy '' , `` A kid eat ivy '' } ; Random random = new Random ( ) ; ( int = 0 ; < importantInfo.length ; i++ ) { drop.put ( importantInfo [ ] ) ; try { Thread.sleep ( random.nextInt ( 5000 ) ) ; } catch ( InterruptedException e ) { } } drop.put ( `` DONE '' ) ; } } The consumer thread , define Consumer , simply retrieve message print , retrieve `` DONE '' string . This thread also pause random interval . import java.util.Random ; public class Consumer implement Runnable { private Drop drop ; public Consumer ( Drop drop ) { this.drop = drop ; } public void run ( ) { Random random = new Random ( ) ; ( String message = drop.take ( ) ; ! message.equals ( `` DONE '' ) ; message = drop.take ( ) ) { System.out.format ( `` MESSAGE RECEIVED : % % n '' , message ) ; try { Thread.sleep ( random.nextInt ( 5000 ) ) ; } catch ( InterruptedException e ) { } } } } Finally , main thread , define ProducerConsumerExample , launch producer consumer thread . public class ProducerConsumerExample { public static void main ( String [ ] args ) { Drop drop = new Drop ( ) ; ( new Thread ( new Producer ( drop ) ) ) .start ( ) ; ( new Thread ( new Consumer ( drop ) ) ) .start ( ) ; } } Note : The Drop class write order demonstrate guarded block . To avoid re-inventing wheel , examine exist data structure Java Collections Framework try code data-sharing object . For information , refer Questions Exercises section .