You use lambda expression create anonymous method . Sometimes , however , lambda expression nothing call exist method . In case , 's often clear refer exist method name . Method reference enable ; compact , easy-to-read lambda expression method already name . Consider Person class discuss section Lambda Expressions : public class Person { public enum Sex { MALE , FEMALE } String name ; LocalDate birthday ; Sex gender ; String emailAddress ; public int getAge ( ) { // ... } public Calendar getBirthday ( ) { return birthday ; } public static int compareByAge ( Person , Person b ) { return a.birthday.compareTo ( b.birthday ) ; } } Suppose member social networking application contain array , want sort array age . You could use following code ( find code excerpt describe section example MethodReferencesTest ) : Person [ ] rosterAsArray = roster.toArray ( new Person [ roster.size ( ) ] ) ; class PersonAgeComparator implement Comparator < Person > { public int compare ( Person , Person b ) { return a.getBirthday ( ) .compareTo ( b.getBirthday ( ) ) ; } } Arrays.sort ( rosterAsArray , new PersonAgeComparator ( ) ) ; The method signature invocation sort following : static < T > void sort ( T [ ] , Comparator < ? super T > c ) Notice interface Comparator functional interface . Therefore , could use lambda expression instead define create new instance class implement Comparator : Arrays.sort ( rosterAsArray , ( Person , Person b ) - > { return a.getBirthday ( ) .compareTo ( b.getBirthday ( ) ) ; } ) ; However , method compare birth date two Person instance already exist Person.compareByAge . You invoke method instead body lambda expression : Arrays.sort ( rosterAsArray , ( , b ) - > Person.compareByAge ( , b ) ) ; Because lambda expression invoke exist method , use method reference instead lambda expression : Arrays.sort ( rosterAsArray , Person : :compareByAge ) ; The method reference Person : :compareByAge semantically lambda expression ( , b ) - > Person.compareByAge ( , b ) . Each following characteristic : Its formal parameter list copy Comparator < Person > .compare , ( Person , Person ) . Its body call method Person.compareByAge . Kinds Method References There four kind method reference : Kind Example Reference static method ContainingClass : :staticMethodName Reference instance method particular object containingObject : :instanceMethodName Reference instance method arbitrary object particular type ContainingType : :methodName Reference constructor ClassName : :new Reference Static Method The method reference Person : :compareByAge reference static method . Reference Instance Method Particular Object The following example reference instance method particular object : class ComparisonProvider { public int compareByName ( Person , Person b ) { return a.getName ( ) .compareTo ( b.getName ( ) ) ; } public int compareByAge ( Person , Person b ) { return a.getBirthday ( ) .compareTo ( b.getBirthday ( ) ) ; } } ComparisonProvider myComparisonProvider = new ComparisonProvider ( ) ; Arrays.sort ( rosterAsArray , myComparisonProvider : :compareByName ) ; The method reference myComparisonProvider : :compareByName invoke method compareByName part object myComparisonProvider . The JRE infer method type argument , case ( Person , Person ) . Reference Instance Method Arbitrary Object Particular Type The following example reference instance method arbitrary object particular type : String [ ] stringArray = { `` Barbara '' , `` James '' , `` Mary '' , `` John '' , `` Patricia '' , `` Robert '' , `` Michael '' , `` Linda '' } ; Arrays.sort ( stringArray , String : :compareToIgnoreCase ) ; The equivalent lambda expression method reference String : :compareToIgnoreCase would formal parameter list ( String , String b ) , b arbitrary name use good describe example . The method reference would invoke method a.compareToIgnoreCase ( b ) . Reference Constructor You reference constructor way static method use name new . The following method copy elements one collection another : public static < T , SOURCE extend Collection < T > , DEST extend Collection < T > > DEST transferElements ( SOURCE sourceCollection , Supplier < DEST > collectionFactory ) { DEST result = collectionFactory.get ( ) ; ( T : sourceCollection ) { result.add ( ) ; } return result ; } The functional interface Supplier contain one method get take argument return object . Consequently , invoke method transferElements lambda expression follow : Set < Person > rosterSetLambda = transferElements ( roster , ( ) - > { return new HashSet < > ( ) ; } ) ; You use constructor reference place lambda expression follow : Set < Person > rosterSet = transferElements ( roster , HashSet : :new ) ; The Java compiler infers want create HashSet collection contain element type Person . Alternatively , specify follow : Set < Person > rosterSet = transferElements ( roster , HashSet < Person > : :new ) ;