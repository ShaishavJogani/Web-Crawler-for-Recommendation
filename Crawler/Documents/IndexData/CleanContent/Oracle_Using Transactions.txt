There time want one statement take effect unless another one completes . For example , proprietor The Coffee Break update amount coffee sell week , proprietor also want update total amount sell date . However , amount sell per week total amount sell update time ; otherwise , data inconsistent . The way sure either action occur neither action occur use transaction . A transaction set one statement execute unit , either statement execute , none statement execute . This page cover following topic Disabling Auto-Commit Mode Committing Transactions Using Transactions Preserve Data Integrity Setting Rolling Back Savepoints Releasing Savepoints When Call Method rollback Disabling Auto-Commit Mode When connection create , auto-commit mode . This mean individual SQL statement treat transaction automatically commit right execute . ( To precise , default SQL statement commit complete , execute . A statement complete result set update count retrieve . In almost case , however , statement complete , therefore commit , right execute . ) The way allow two statement group transaction disable auto-commit mode . This demonstrate following code , con active connection : con.setAutoCommit ( false ) ; Committing Transactions After auto-commit mode disable , SQL statement commit call method commit explicitly . All statement execute previous call method commit include current transaction committed together unit . The following method , CoffeesTable.updateCoffeeSales , con active connection , illustrate transaction : public void updateCoffeeSales ( HashMap < String , Integer > salesForWeek ) throw SQLException { PreparedStatement updateSales = null ; PreparedStatement updateTotal = null ; String updateString = `` update `` + dbName + `` .COFFEES `` + `` set SALES = ? COF_NAME = ? `` ; String updateStatement = `` update `` + dbName + `` .COFFEES `` + `` set TOTAL = TOTAL + ? `` + `` COF_NAME = ? `` ; try { con.setAutoCommit ( false ) ; updateSales = con.prepareStatement ( updateString ) ; updateTotal = con.prepareStatement ( updateStatement ) ; ( Map.Entry < String , Integer > e : salesForWeek.entrySet ( ) ) { updateSales.setInt ( 1 , e.getValue ( ) .intValue ( ) ) ; updateSales.setString ( 2 , e.getKey ( ) ) ; updateSales.executeUpdate ( ) ; updateTotal.setInt ( 1 , e.getValue ( ) .intValue ( ) ) ; updateTotal.setString ( 2 , e.getKey ( ) ) ; updateTotal.executeUpdate ( ) ; con.commit ( ) ; } } catch ( SQLException e ) { JDBCTutorialUtilities.printSQLException ( e ) ; ( con ! = null ) { try { System.err.print ( `` Transaction roll back '' ) ; con.rollback ( ) ; } catch ( SQLException excep ) { JDBCTutorialUtilities.printSQLException ( excep ) ; } } } finally { ( updateSales ! = null ) { updateSales.close ( ) ; } ( updateTotal ! = null ) { updateTotal.close ( ) ; } con.setAutoCommit ( true ) ; } } In method , auto-commit mode disable connection con , mean two prepared statement updateSales updateTotal commit together method commit call . Whenever commit method call ( either automatically auto-commit mode enable explicitly disable ) , change result statement transaction make permanent . In case , mean SALES TOTAL column Colombian coffee change 50 ( TOTAL 0 previously ) retain value change another update statement . The statement con.setAutoCommit ( true ) ; enable auto-commit mode , mean statement commit automatically complete . Then , back default state call method commit . It advisable disable auto-commit mode transaction mode . This way , avoid hold database lock multiple statement , increase likelihood conflict user . Using Transactions Preserve Data Integrity In addition group statement together execution unit , transaction help preserve integrity data table . For instance , imagine employee suppose enter new coffee price table COFFEES delay day . In meantime , price rise , today owner process enter high price . The employee finally get around enter outdated price time owner try update table . After insert outdated price , employee realize longer valid call Connection method rollback undo effect . ( The method rollback abort transaction restore value attempted update . ) At time , owner execute SELECT statement print new price . In situation , possible owner print price roll back previous value , make printed price incorrect . This kind situation avoid use transaction , provide level protection conflict arise two user access data time . To avoid conflict transaction , DBMS use lock , mechanism block access others data access transaction . ( Note auto-commit mode , statement transaction , lock hold one statement . ) After lock set , remain force transaction commit roll back . For example , DBMS could lock row table update commit . The effect lock would prevent user get dirty read , , read value make permanent . ( Accessing updated value commit consider dirty read possible value roll back previous value . If read value later roll back , read invalid value . ) How lock set determine call transaction isolation level , range support transaction support transaction enforce strict access rule . One example transaction isolation level TRANSACTION_READ_COMMITTED , allow value access commit . In word , transaction isolation level set TRANSACTION_READ_COMMITTED , DBMS allow dirty read occur . The interface Connection include five value represent transaction isolation level use JDBC : Isolation Level Transactions Dirty Reads Non-Repeatable Reads Phantom Reads TRANSACTION_NONE Not support Not applicable Not applicable Not applicable TRANSACTION_READ_COMMITTED Supported Prevented Allowed Allowed TRANSACTION_READ_UNCOMMITTED Supported Allowed Allowed Allowed TRANSACTION_REPEATABLE_READ Supported Prevented Prevented Allowed TRANSACTION_SERIALIZABLE Supported Prevented Prevented Prevented A non-repeatable read occur transaction A retrieve row , transaction B subsequently update row , transaction A later retrieve row . Transaction A retrieve row twice see different data . A phantom read occur transaction A retrieve set row satisfy give condition , transaction B subsequently insert update row row meet condition transaction A , transaction A later repeat conditional retrieval . Transaction A see additional row . This row refer phantom . Usually , need anything transaction isolation level ; use default one DBMS . The default transaction isolation level depend DBMS . For example , Java DB , TRANSACTION_READ_COMMITTED . JDBC allow find transaction isolation level DBMS set ( use Connection method getTransactionIsolation ) also allow set another level ( use Connection method setTransactionIsolation ) . Note : A JDBC driver might support transaction isolation level . If driver support isolation level specify invocation setTransactionIsolation , driver substitute high , restrictive transaction isolation level . If driver substitute high transaction level , throw SQLException . Use method DatabaseMetaData.supportsTransactionIsolationLevel determine whether driver support give level . Setting Rolling Back Savepoints The method Connection.setSavepoint , set Savepoint object within current transaction . The Connection.rollback method overload take Savepoint argument . The following method , CoffeesTable.modifyPricesByPercentage , raise price particular coffee percentage , priceModifier . However , new price great specified price , maximumPrice , price revert original price : public void modifyPricesByPercentage ( String coffeeName , float priceModifier , float maximumPrice ) throw SQLException { con.setAutoCommit ( false ) ; Statement getPrice = null ; Statement updatePrice = null ; ResultSet rs = null ; String query = `` SELECT COF_NAME , PRICE FROM COFFEES `` + `` WHERE COF_NAME = ' '' + coffeeName + `` ' '' ; try { Savepoint save1 = con.setSavepoint ( ) ; getPrice = con.createStatement ( ResultSet.TYPE_SCROLL_INSENSITIVE , ResultSet.CONCUR_READ_ONLY ) ; updatePrice = con.createStatement ( ) ; ( ! getPrice.execute ( query ) ) { System.out.println ( `` Could find entry `` + `` coffee name `` + coffeeName ) ; } else { rs = getPrice.getResultSet ( ) ; rs.first ( ) ; float oldPrice = rs.getFloat ( `` PRICE '' ) ; float newPrice = oldPrice + ( oldPrice * priceModifier ) ; System.out.println ( `` Old price `` + coffeeName + `` `` + oldPrice ) ; System.out.println ( `` New price `` + coffeeName + `` `` + newPrice ) ; System.out.println ( `` Performing update ... '' ) ; updatePrice.executeUpdate ( `` UPDATE COFFEES SET PRICE = `` + newPrice + `` WHERE COF_NAME = ' '' + coffeeName + `` ' '' ) ; System.out.println ( `` \nCOFFEES table `` + `` update : '' ) ; CoffeesTable.viewTable ( con ) ; ( newPrice > maximumPrice ) { System.out.println ( `` \nThe new price , `` + newPrice + `` , great `` + `` maximum price , `` + maximumPrice + `` . Rolling back `` + `` transaction ... '' ) ; con.rollback ( save1 ) ; System.out.println ( `` \nCOFFEES table `` + `` rollback : '' ) ; CoffeesTable.viewTable ( con ) ; } con.commit ( ) ; } } catch ( SQLException e ) { JDBCTutorialUtilities.printSQLException ( e ) ; } finally { ( getPrice ! = null ) { getPrice.close ( ) ; } ( updatePrice ! = null ) { updatePrice.close ( ) ; } con.setAutoCommit ( true ) ; } } The following statement specifies cursor ResultSet object generate getPrice query close commit method call . Note DBMs support ResultSet.CLOSE_CURSORS_AT_COMMIT , constant ignore : getPrice = con.prepareStatement ( query , ResultSet.CLOSE_CURSORS_AT_COMMIT ) ; The method begin create Savepoint following statement : Savepoint save1 = con.setSavepoint ( ) ; The method check new price great maximumPrice value . If , method roll back transaction following statement : con.rollback ( save1 ) ; Consequently , method commit transaction call Connection.commit method , commit row whose associate Savepoint roll back ; commit updated row . Releasing Savepoints The method Connection.releaseSavepoint take Savepoint object parameter remove current transaction . After savepoint release , attempt reference rollback operation cause SQLException throw . Any savepoints create transaction automatically release become invalid transaction commit , entire transaction roll back . Rolling transaction back savepoint automatically release make invalid savepoints create savepoint question . When Call Method rollback As mention earlier , call method rollback terminate transaction return value modify previous value . If try execute one statement transaction get SQLException , call method rollback end transaction start transaction . That way know commit commit . Catching SQLException tell something wrong , tell commit . Because count fact nothing commit , call method rollback way certain . The method CoffeesTable.updateCoffeeSales demonstrate transaction include catch block invoke method rollback . If application continue use result transaction , call rollback method catch block prevent use possibly incorrect data .