What Are Services ? Services unit sound-handling functionality automatically available application program make use implementation Java Sound API . They consist object work reading , write , mix , processing , convert audio MIDI data . An implementation Java Sound API generally supply basic set service , mechanism also include API support development new sound service third-party developer ( vendor implementation ) . These new service `` plug '' exist installed implementation expand functionality without require new release . In Java Sound API architecture , third-party service integrate system way application program 's interface interface `` built-in '' service . In case , application developer use javax.sound.sampled javax.sound.midi package might even aware employ third-party service . Examples potential third-party , sampled-audio service include : Sound file reader writer Converters translate different audio data format New audio mixer input/output device , whether implement purely software , hardware software interface Third-party MIDI service might consist : MIDI file reader writer Readers various type soundbank file ( often specific particular synthesizer ) MIDI-controlled sound synthesizer , sequencer , I/O port , whether implement purely software , hardware software interface How Services Work The javax.sound.sampled javax.sound.midi package provide functionality application developer wish include sound service application program . These package consumer sound service , provide interface get information , control , access audio MIDI service . In addition , Java Sound API also supply two package define abstract class use provider sound service : javax.sound.sampled.spi javax.sound.midi.spi package . Developers new sound service implement concrete subclass appropriate class SPI package . These subclass , along additional class require support new service , place Java Archive ( JAR ) archive file description included service service . When JAR file instal user 's CLASSPATH , runtime system automatically make new service available , extend functionality Java platform 's runtime system . Once new service instal , access like previously instal service . Consumers service get information new service , obtain instance new service class , invoke method AudioSystem MidiSystem class ( javax.sound.sampled javax.sound.midi package , respectively ) return information new service , return instance new exist service class . Application program need notâand notâreference class SPI package ( subclass ) directly make use installed service . For example , suppose hypothetical service provider call Acme Software , Inc. interested supply package allow application program read new format sound file ( one whose audio data standard data format ) . The SPI class AudioFileReader subclassed class call , say , AcmeAudioFileReader . In new subclass , Acme would supply implementation method define AudioFileReader ; case two method ( argument variant ) , getAudioFileFormat getAudioInputStream . Then application program attempt read sound file happen Acme 's file format , would invoke method AudioSystem class javax.sound.sampled access file information . The method AudioSystem.getAudioInputStream AudioSystem.getAudioFileFormat provide standard API read audio stream ; AcmeAudioFileReader class instal , interface extend support new file type transparently . Application developer n't need direct access newly register SPI class : AudioSystem object method pass query instal AcmeAudioFileReader class . What 's point `` factory '' class ? Why permit application developer get access directly newly provide service ? That possible approach , management instantiation service pass gatekeeper system object shield application developer know anything identity installed service . Application developer use service value , perhaps without even realize . At time architecture permit service provider effectively manage available resource package . Often use new sound service transparent application program . For example , imagine situation application developer want read stream audio file . Assuming thePathName identify audio input file , program : File theInFile = new File ( thePathName ) ; AudioInputStream theInStream = AudioSystem.getAudioInputStream ( theInFile ) ; Behind scene , AudioSystem determine instal service read file ask supply audio data AudioInputStream object . The developer might know even care input audio file new file format ( Acme 's ) , support installed third-party service . The program 's first contact stream AudioSystem object , subsequent access stream property method AudioInputStream . Both standard object javax.sound.sampled API ; special handling new file format may require completely hidden . How Providers Prepare New Services Service provider supply new service specially format JAR file , instal directory user 's system Java runtime find . JAR file archive file , contain set file might organize hierarchical directory structure within archive . Details preparation class file go archive discuss next page , describe specific audio MIDI SPI package ; 'll give overview process JAR file creation . The JAR file new service service contain class file service support JAR file . Following Java platform 's convention , class file name newly define class , concrete subclass one abstract service provider class . The JAR file also must include supporting class require new service implementation . So new service service locate runtime system 's service provider mechanism , JAR file must also contain special file ( describe ) map SPI class name new subclass define . To continue example , say Acme Software , Inc. distribute package new sampled-audio service . Let 's suppose package consist two new service : The AcmeAudioFileReader class , mention , subclass AudioFileReader A subclass AudioFileWriter call AcmeAudioFileWriter , write sound file Acme 's new format Starting arbitrary directoryâlet 's call /develâwhere want build , create subdirectory put new class file , organize manner give desire pathname new class reference : com/acme/AcmeAudioFileReader.class com/acme/AcmeAudioFileWriter.class In addition , new SPI class subclassed , create mapping file specially name directory META-INF/services . The name file name SPI class subclassed , file contain name new subclass SPI abstract class . We create file META-INF/services/javax.sound.sampled.spi.AudioFileReader consist # Providers sound file-reading service # ( comment line begin pound sign ) com.acme.AcmeAudioFileReader also file META-INF/services/javax.sound.sampled.spi.AudioFileWriter consist # Providers sound file-writing service com.acme.AcmeAudioFileWriter Now run jar directory command line : jar cvf acme.jar -C /devel . The -C option cause jar switch /devel directory , instead use directory command execute . The final period argument instruct jar archive content directory ( namely , /devel ) , directory . This run create file acme.jar content : com/acme/AcmeAudioFileReader.class com/acme/AcmeAudioFileWriter.class META-INF/services/javax.sound.sampled.spi.AudioFileReader META-INF/services/javax.sound.sampled.spi.AudioFileWriter META-INF/Manifest.mf The file Manifest.mf , generate jar utility , list file contain archive . How Users Install New Services For end user ( system administrator ) wish get access new service application program , installation simple . They place provided JAR file directory CLASSPATH . Upon execution , Java runtime find referenced class need . It 's error install one provider service . For example , two different service provider might supply support read type sound file . In case , system arbitrarily choose one provider . Users care provider choose install desired one .