Playback sometimes refer presentation rendering . These general term applicable kind medium besides sound . The essential feature sequence data deliver somewhere eventual perception user . If data time-based , sound , must deliver correct rate . With sound even video , 's important rate data flow maintain , interruption sound playback often produce loud click irritate distortion . The Java Sound API design help application program play sound smoothly continuously , even long sound . Earlier saw obtain line audio system mixer . Here learn play sound line . As know , two kind line use play sound : Clip SourceDataLine . The primary difference two Clip specify sound data one time , playback , whereas SourceDataLine keep write new buffer data continuously playback . Although many situation could use either Clip SourceDataLine , follow criterion help identify kind line well suit particular situation : Use Clip non-real-time sound data preloaded memory . For example , might read short sound file clip . If want sound play back , Clip convenient SourceDataLine , especially want playback loop ( cycle repeatedly part sound ) . If need start playback arbitrary position sound , Clip interface provide method easily . Finally , playback Clip generally less latency buffer playback SourceDataLine . In word , sound preloaded clip , playback start immediately instead wait buffer fill . Use SourceDataLine stream data , long sound file wo n't fit memory , sound whose data ca n't know advance playback . As example latter case , suppose 're monitor sound inputâthat , play sound back 's capture . If n't mixer send input audio right back output port , application program take capture data send audio-output mixer . In case , SourceDataLine appropriate Clip . Another example sound ca n't know advance occurs synthesize manipulate sound data interactively response user 's input . For example , imagine game give aural feedback `` morph '' one sound another user move mouse . The dynamic nature sound transformation require application program update sound data continuously playback , instead supply playback start . Using Clip You obtain Clip describe earlier Getting Line Desired Type ; Construct DataLine.Info object Clip.class first argument , pas DataLine.Info argument getLine method AudioSystem Mixer . Obtaining line mean 've get way refer ; getLine n't actually reserve line . Because mixer might limited number line desired type available , happen invoke getLine obtain clip , another application program jump grab clip 're ready start playback . To actually use clip , need reserve program 's exclusive use invoke one following Clip method : void open ( AudioInputStream stream ) void open ( AudioFormat format , byte [ ] data , int offset , int bufferSize ) Despite bufferSize argument second open method , Clip ( unlike SourceDataLine ) include method write new data buffer . The bufferSize argument specify much byte array load clip . It 's buffer subsequently load data , SourceDataLine 's buffer . After open clip , specify point data start playback , use Clip 's setFramePosition setMicroSecondPosition method . Otherwise , start beginning . You also configure playback cycle repeatedly , use setLoopPoints method . When 're ready start playback , simply invoke start method . To stop pause clip , invoke stop method , resume playback , invoke start . The clip remember medium position stop playback , 's need explicit pause resume method . If n't want resume leave , `` rewind '' clip beginning ( position , matter ) use frame- microsecond-positioning method mention . A Clip 's volume level activity status ( active versus inactive ) monitor invoke DataLine method getLevel isActive , respectively . An active Clip one currently play sound . Using SourceDataLine Obtaining SourceDataLine similar obtain Clip . Opening SourceDataLine also similar open Clip , purpose reserve line . However , use different method , inherit DataLine : void open ( AudioFormat format ) Notice open SourceDataLine , n't associate sound data line yet , unlike open Clip . Instead , specify format audio data want play . The system choose default buffer length . You also stipulate certain buffer length byte , use variant : void open ( AudioFormat format , int bufferSize ) For consistency similar method , bufferSize argument express byte , must correspond integral number frame . Instead use open method describe , 's also possible open SourceDataLine use Line 's open ( ) method , without argument . In case , line open default audio format buffer size . However , ca n't change later . If want know line 's default audio format buffer size , invoke DataLine 's getFormat getBufferSize method , even line ever open . Once SourceDataLine open , start play sound . You invoke DataLine 's start method , write data repeatedly line 's playback buffer . The start method permit line begin play sound soon 's data buffer . You place data buffer following method : int write ( byte [ ] b , int offset , int length ) The offset array express byte , array 's length . The line begin send data soon possible mixer . When mixer deliver data target , SourceDataLine generate START event . ( In typical implementation Java Sound API , delay moment source line delivers data mixer moment mixer deliver data target negligible , , much less time one sample . ) This START event get send line 's listener , explain Monitoring Line 's Status . The line consider active , isActive method DataLine return true . Notice happen buffer contain data play , necessarily right start method invoke . If invoke start new SourceDataLine never write data buffer , line would never active START event would never send . ( However , case , isRunning method DataLine would return true . ) So know much data write buffer , send second batch data ? Fortunately , n't need time second invocation write synchronize end first buffer ! Instead , take advantage write method 's block behavior : The method return soon data write buffer . It n't wait data buffer finish playing . ( If , might time write next buffer without create discontinuity audio . ) It 's right try write data buffer hold . In case , method block ( n't return ) data request actually place buffer . In word , one buffer 's worth data time write buffer play , remain data fit buffer , point method return . Whether method block , return soon last buffer 's worth data invocation write . Again , mean code likelihood regain control playback last buffer 's worth data finish . While many context fine write data buffer hold , want certain next write issue block , limit number byte write number DataLine 's available method return . Here 's example iterate chunk data read stream , write one chunk time SourceDataLine playback : // read chunk stream write source data line line.start ( ) ; ( total < totalToRead & & ! stopped ) } numBytesRead = stream.read ( myData , 0 , numBytesToRead ) ; ( numBytesRead == -1 ) break ; total += numBytesRead ; line.write ( myData , 0 , numBytesRead ) ; } If n't want write method block , first invoke available method ( inside loop ) find many byte write without block , limit numBytesToRead variable number , read stream . In example give , though , block wo n't matter much , since write method invoke inside loop wo n't complete last buffer write final loop iteration . Whether use blocking technique , 'll probably want invoke playback loop separate thread rest application program , program n't appear freeze play long sound . On iteration loop , test whether user request playback stop . Such request need set stopped boolean , use code , true . Since write return data finish playing , learn playback actually complete ? One way invoke drain method DataLine write last buffer 's worth data . This method block data play . When control return program , free line , desire , without fear prematurely cut playback audio sample : line.write ( b , offset , numBytesToWrite ) ; //this final invocation write line.drain ( ) ; line.stop ( ) ; line.close ( ) ; line = null ; You intentionally stop playback prematurely , course . For example , application program might provide user Stop button . Invoke DataLine 's stop method stop playback immediately , even middle buffer . This leave unplayed data buffer , subsequently invoke start , playback resume leave . If 's want happen , discard data leave buffer invoke flush . A SourceDataLine generate STOP event whenever flow data stop , whether stoppage initiate drain method , stop method , flush method , end playback buffer reach application program invoke write provide new data . A STOP event n't necessarily mean stop method invoke , n't necessarily mean subsequent invocation isRunning return false . It , however , mean isActive return false . ( When start method invoke , isRunning method return true , even STOP event generate , begin return false stop method invoke . ) It 's important realize START STOP event correspond isActive , isRunning . Monitoring Line 's Status Once start sound playing , find 's finish ? We saw one solution , invoke drain method write last buffer data , approach applicable SourceDataLine . Another approach , work SourceDataLines Clips , register receive notification line whenever line change state . These notification generate form LineEvent object , four type : OPEN , CLOSE , START , STOP . Any object program implement LineListener interface register receive notification . To implement LineListener interface , object simply need update method take LineEvent argument . To register object one line 's listener , invoke following Line method : public void addLineListener ( LineListener listener ) Whenever line open , close , start , stop , send update message listener . Your object query LineEvent receive . First might invoke LineEvent.getLine make sure line stop one care . In case 're discuss , want know sound finish , see whether LineEvent type STOP . If , might check sound 's current position , also store LineEvent object , compare sound 's length ( know ) see whether reach end n't stop mean ( user 's click Stop button , although 'd probably able determine cause elsewhere code ) . Along line , need know line open , close , start , use mechanism . LineEvents generate different kind line , Clips SourceDataLines . However , case Port ca n't count get event learn line 's open closed state . For example , Port might initially open 's create , n't invoke open method Port n't ever generate OPEN event . ( See previous discussion Selecting Input Output Ports . ) Synchronizing Playback Multiple Lines If 're play back multiple track audio simultaneously , probably want start stop exactly time . Some mixer facilitate behavior synchronize method , let apply operation open , close , start , stop group data line use single command , instead control line individually . Furthermore , degree accuracy operation apply line controllable . To find whether particular mixer offer feature specified group data line , invoke Mixer interface 's isSynchronizationSupported method : boolean isSynchronizationSupported ( Line [ ] line , boolean maintainSync ) The first parameter specify group specific data line , second parameter indicate accuracy synchronization must maintain . If second parameter true , query ask whether mixer capable maintain sample-accurate precision control specify line time ; otherwise , precise synchronization require start stop operation , throughout playback . Processing Outgoing Audio Some source data line signal-processing control , gain , pan , reverb , sample-rate control . Similar control , especially gain control , might present output port well . For information determine whether line control , use , see Processing Audio Controls .