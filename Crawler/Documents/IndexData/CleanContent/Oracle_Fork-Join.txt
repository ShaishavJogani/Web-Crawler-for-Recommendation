The fork/join framework implementation ExecutorService interface help take advantage multiple processor . It design work break small piece recursively . The goal use available processing power enhance performance application . As ExecutorService implementation , fork/join framework distribute task worker thread thread pool . The fork/join framework distinct use work-stealing algorithm . Worker thread run thing steal task thread still busy . The center fork/join framework ForkJoinPool class , extension AbstractExecutorService class . ForkJoinPool implement core work-stealing algorithm execute ForkJoinTask process . Basic Use The first step use fork/join framework write code perform segment work . Your code look similar following pseudocode : ( portion work small enough ) work directly else split work two piece invoke two piece wait result Wrap code ForkJoinTask subclass , typically use one specialized type , either RecursiveTask ( return result ) RecursiveAction . After ForkJoinTask subclass ready , create object represent work pass invoke ( ) method ForkJoinPool instance . Blurring Clarity To help understand fork/join framework work , consider following example . Suppose want blur image . The original source image represent array integer , integer contain color value single pixel . The blurred destination image also represent integer array size source . Performing blur accomplish work source array one pixel time . Each pixel average surround pixel ( red , green , blue component average ) , result place destination array . Since image large array , process take long time . You take advantage concurrent processing multiprocessor system implement algorithm use fork/join framework . Here one possible implementation : public class ForkBlur extend RecursiveAction { private int [ ] mSource ; private int mStart ; private int mLength ; private int [ ] mDestination ; // Processing window size ; odd . private int mBlurWidth = 15 ; public ForkBlur ( int [ ] src , int start , int length , int [ ] dst ) { mSource = src ; mStart = start ; mLength = length ; mDestination = dst ; } protect void computeDirectly ( ) { int sidePixels = ( mBlurWidth - 1 ) / 2 ; ( int index = mStart ; index < mStart + mLength ; index++ ) { // Calculate average . float rt = 0 , gt = 0 , bt = 0 ; ( int mi = -sidePixels ; mi < = sidePixels ; mi++ ) { int mindex = Math.min ( Math.max ( mi + index , 0 ) , mSource.length - 1 ) ; int pixel = mSource [ mindex ] ; rt += ( float ) ( ( pixel & 0x00ff0000 ) > > 16 ) / mBlurWidth ; gt += ( float ) ( ( pixel & 0x0000ff00 ) > > 8 ) / mBlurWidth ; bt += ( float ) ( ( pixel & 0x000000ff ) > > 0 ) / mBlurWidth ; } // Reassemble destination pixel . int dpixel = ( 0xff000000 ) | ( ( ( int ) rt ) < < 16 ) | ( ( ( int ) gt ) < < 8 ) | ( ( ( int ) bt ) < < 0 ) ; mDestination [ index ] = dpixel ; } } ... Now implement abstract compute ( ) method , either perform blur directly split two small task . A simple array length threshold help determine whether work perform split . protect static int sThreshold = 100000 ; protect void compute ( ) { ( mLength < sThreshold ) { computeDirectly ( ) ; return ; } int split = mLength / 2 ; invokeAll ( new ForkBlur ( mSource , mStart , split , mDestination ) , new ForkBlur ( mSource , mStart + split , mLength - split , mDestination ) ) ; } If previous method subclass RecursiveAction class , set task run ForkJoinPool straightforward , involve following step : Create task represent work . // source image pixel src // destination image pixel dst ForkBlur fb = new ForkBlur ( src , 0 , src.length , dst ) ; Create ForkJoinPool run task . ForkJoinPool pool = new ForkJoinPool ( ) ; Run task . pool.invoke ( fb ) ; For full source code , include extra code create destination image file , see ForkBlur example . Standard Implementations Besides use fork/join framework implement custom algorithm task perform concurrently multiprocessor system ( ForkBlur.java example previous section ) , generally useful feature Java SE already implement use fork/join framework . One implementation , introduce Java SE 8 , use java.util.Arrays class parallelSort ( ) method . These method similar sort ( ) , leverage concurrency via fork/join framework . Parallel sorting large array fast sequential sort run multiprocessor system . However , exactly fork/join framework leverage method outside scope Java Tutorials . For information , see Java API documentation . Another implementation fork/join framework use method java.util.streams package , part Project Lambda schedule Java SE 8 release . For information , see Lambda Expressions section .