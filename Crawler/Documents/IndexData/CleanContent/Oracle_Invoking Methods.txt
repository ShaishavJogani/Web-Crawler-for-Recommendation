Reflection provide mean invoke method class . Typically , would necessary possible cast instance class desire type non-reflective code . Methods invoke java.lang.reflect.Method.invoke ( ) . The first argument object instance particular method invoke . ( If method static , first argument null . ) Subsequent argument method 's parameter . If underlie method throw exception , wrap java.lang.reflect.InvocationTargetException . The method 's original exception may retrieve use exception chain mechanism 's InvocationTargetException.getCause ( ) method . Finding Invoking Method Specific Declaration Consider test suite use reflection invoke private test method give class . The Deet example search public method class begin string `` test '' , boolean return type , single Locale parameter . It invoke match method . import java.lang.reflect.InvocationTargetException ; import java.lang.reflect.Method ; import java.lang.reflect.Type ; import java.util.Locale ; import static java.lang.System.out ; import static java.lang.System.err ; public class Deet < T > { private boolean testDeet ( Locale l ) { // getISO3Language ( ) may throw MissingResourceException out.format ( `` Locale = % , ISO Language Code = % % n '' , l.getDisplayName ( ) , l.getISO3Language ( ) ) ; return true ; } private int testFoo ( Locale l ) { return 0 ; } private boolean testBar ( ) { return true ; } public static void main ( String ... args ) { ( args.length ! = 4 ) { err.format ( `` Usage : java Deet < classname > < langauge > < country > < variant > % n '' ) ; return ; } try { Class < ? > c = Class.forName ( args [ 0 ] ) ; Object = c.newInstance ( ) ; Method [ ] allMethods = c.getDeclaredMethods ( ) ; ( Method : allMethods ) { String mname = m.getName ( ) ; ( ! mname.startsWith ( `` test '' ) || ( m.getGenericReturnType ( ) ! = boolean.class ) ) { continue ; } Type [ ] pType = m.getGenericParameterTypes ( ) ; ( ( pType.length ! = 1 ) || Locale.class.isAssignableFrom ( pType [ 0 ] .getClass ( ) ) ) { continue ; } out.format ( `` invoke % ( ) % n '' , mname ) ; try { m.setAccessible ( true ) ; Object = m.invoke ( , new Locale ( args [ 1 ] , args [ 2 ] , args [ 3 ] ) ) ; out.format ( `` % ( ) return % b % n '' , mname , ( Boolean ) ) ; // Handle exception throw method invoked. } catch ( InvocationTargetException x ) { Throwable cause = x.getCause ( ) ; err.format ( `` invocation % fail : % % n '' , mname , cause.getMessage ( ) ) ; } } // production code handle exception gracefully } catch ( ClassNotFoundException x ) { x.printStackTrace ( ) ; } catch ( InstantiationException x ) { x.printStackTrace ( ) ; } catch ( IllegalAccessException x ) { x.printStackTrace ( ) ; } } } Deet invokes getDeclaredMethods ( ) return method explicitly declare class . Also , Class.isAssignableFrom ( ) use determine whether parameter locate method compatible desired invocation . Technically code could test whether following statement true since Locale final : Locale.class == pType [ 0 ] .getClass ( ) However , Class.isAssignableFrom ( ) general . $ java Deet Deet ja JP JP invoke testDeet ( ) Locale = Japanese ( Japan , JP ) , ISO Language Code = jpn testDeet ( ) return true $ java Deet Deet xx XX XX invoke testDeet ( ) invocation testDeet fail : Could n't find 3-letter language code xx First , note testDeet ( ) meet declaration restriction enforce code . Next , testDeet ( ) pass invalid argument throw unchecked java.util.MissingResourceException . In reflection , distinction handling checked versus unchecked exception . They wrap InvocationTargetException Invoking Methods Variable Number Arguments Method.invoke ( ) may use pass variable number argument method . The key concept understand method variable arity implement variable argument pack array . The InvokeMain example illustrate invoke main ( ) entry point class pas set argument determine runtime . import java.lang.reflect.InvocationTargetException ; import java.lang.reflect.Method ; import java.util.Arrays ; public class InvokeMain { public static void main ( String ... args ) { try { Class < ? > c = Class.forName ( args [ 0 ] ) ; Class [ ] argTypes = new Class [ ] { String [ ] .class } ; Method main = c.getDeclaredMethod ( `` main '' , argTypes ) ; String [ ] mainArgs = Arrays.copyOfRange ( args , 1 , args.length ) ; System.out.format ( `` invoke % s.main ( ) % n '' , c.getName ( ) ) ; main.invoke ( null , ( Object ) mainArgs ) ; // production code handle exception gracefully } catch ( ClassNotFoundException x ) { x.printStackTrace ( ) ; } catch ( NoSuchMethodException x ) { x.printStackTrace ( ) ; } catch ( IllegalAccessException x ) { x.printStackTrace ( ) ; } catch ( InvocationTargetException x ) { x.printStackTrace ( ) ; } } } First , find main ( ) method code search class name `` main '' single parameter array String Since main ( ) static , null first argument Method.invoke ( ) . The second argument array argument pass . $ java InvokeMain Deet Deet ja JP JP invoke Deet.main ( ) invoke testDeet ( ) Locale = Japanese ( Japan , JP ) , ISO Language Code = jpn testDeet ( ) return true