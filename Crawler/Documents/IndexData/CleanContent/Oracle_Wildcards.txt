Consider problem write routine print element collection . Here 's might write old version language ( i.e. , pre-5.0 release ) : void printCollection ( Collection c ) { Iterator = c.iterator ( ) ; ( k = 0 ; k < c.size ( ) ; k++ ) { System.out.println ( i.next ( ) ) ; } } And naive attempt write use generic ( new loop syntax ) : void printCollection ( Collection < Object > c ) { ( Object e : c ) { System.out.println ( e ) ; } } The problem new version much less useful old one . Whereas old code could call kind collection parameter , new code take Collection < Object > , , 've demonstrate , supertype kind collection ! So supertype kind collection ? It 's write Collection < ? > ( pronounce `` collection unknown '' ) , , collection whose element type match anything . It 's call wildcard type obvious reason . We write : void printCollection ( Collection < ? > c ) { ( Object e : c ) { System.out.println ( e ) ; } } , call type collection . Notice inside printCollection ( ) , still read element c give type Object . This always safe , since whatever actual type collection , contain object . It n't safe add arbitrary object however : Collection < ? > c = new ArrayList < String > ( ) ; c.add ( new Object ( ) ) ; // Compile time error Since n't know element type c stand , add object . The add ( ) method take argument type E , element type collection . When actual type parameter ? , stand unknown type . Any parameter pass add would subtype unknown type . Since n't know type , pass anything . The sole exception null , member every type . On hand , give List < ? > , call get ( ) make use result . The result type unknown type , always know object . It therefore safe assign result get ( ) variable type Object pass parameter type Object expect . Bounded Wildcards Consider simple drawing application draw shape rectangle circle . To represent shape within program , could define class hierarchy : public abstract class Shape { public abstract void draw ( Canvas c ) ; } public class Circle extend Shape { private int x , , radius ; public void draw ( Canvas c ) { ... } } public class Rectangle extend Shape { private int x , , width , height ; public void draw ( Canvas c ) { ... } } These class draw canvas : public class Canvas { public void draw ( Shape ) { s.draw ( ) ; } } Any draw typically contain number shape . Assuming represent list , would convenient method Canvas draw : public void drawAll ( List < Shape > shape ) { ( Shape : shape ) { s.draw ( ) ; } } Now , type rule say drawAll ( ) call list exactly Shape : , instance , call List < Circle > . That unfortunate , since method read shape list , could well call List < Circle > . What really want method accept list kind shape : public void drawAll ( List < ? extends Shape > shape ) { ... } There small important difference : replace type List < Shape > List < ? extends Shape > . Now drawAll ( ) accept list subclass Shape , call List < Circle > want . List < ? extends Shape > example bounded wildcard . The ? stand unknown type , like wildcards saw earlier . However , case , know unknown type fact subtype Shape . ( Note : It could Shape , subclass ; need literally extend Shape . ) We say Shape upper bound wildcard . There , usual , price pay flexibility use wildcards . That price illegal write shape body method . For instance , allow : public void addRectangle ( List < ? extends Shape > shape ) { // Compile-time error ! shapes.add ( 0 , new Rectangle ( ) ) ; } You able figure code disallow . The type second parameter shapes.add ( ) ? extends Shape -- unknown subtype Shape . Since n't know type , n't know supertype Rectangle ; might might supertype , n't safe pass Rectangle . Bounded wildcards one need handle example DMV pass data census bureau . Our example assume data represent map name ( represent string ) people ( represent reference type Person subtypes , Driver ) . Map < K , V > example generic type take two type argument , represent key value map . Again , note naming convention formal type parameter -- K key V value . public class Census { public static void addRegistry ( Map < String , ? extends Person > registry ) { } ... Map < String , Driver > allDrivers = ... ; Census.addRegistry ( allDrivers ) ;