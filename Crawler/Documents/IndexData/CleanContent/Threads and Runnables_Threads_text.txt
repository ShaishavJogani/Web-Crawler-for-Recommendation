In light discussion , thread small unit process schedule operating system . Therefore , use thread , programmer effectively create two task [ 1 ] run time . The first call-to-action implement set task particular thread would execute . To , require creation aRunnableprocess . Creating Runnable process block [ edit ] ARunnableprocess block simple class implement arun ( ) method . Within therun ( ) method actual task need execute running thread . By implement class theRunnableinterface , ensure class hold arun ( ) method . Consider following program : In code , create class calledRunnableProcessand implement theRunnableinterface ensure arun ( ) method class declaration . We declare rest logic class . For constructor , take aStringparameter would serve name class . Then , initialize class member variabletimewith random number between0and999 . To ensure initialization random number , use theRandomclass thejava.utilpackage . The actual task would execute per runnable block present within therun ( ) method . To keep safe exception occur concurrent programming , wrap code within method atry..catchblock . The execute task actually consist three statement . The first output provided name Runnable process , last report thread execute . Perhaps intriguing part code second statement : Thread.sleep ( ... ) . This statement allow thread execute current runnable block halt execution give amount time . This time present millisecond . But convenience , time would random number generate constructor anywhere between0and999milliseconds . We explore late section . Creating aRunnableprocess block beginning . No code actually execute . To , would require creation thread would individually execute task . Creating thread [ edit ] Once aRunnableprocess block , create various thread execute logic encase within block . Multithreading capability Java utilized manipulate use theThreadclass . AThreadobject therefore hold necessary logic device create truly multithreaded program . Consider following program : Creating thread simple program suggest . You create object theThreadclass pas reference aRunnableprocess object . In case , present theThreadconstructor class object theRunnableProcessclass create incode list 1 . But object , give different name ( i.e. , '' Thread-1 '' '' Thread-2 '' , etc . ) differentiate threeThreadobjects . The example declaresThreadobjects n't yet start execution . Starting thread [ edit ] Now , know effectively create aRunnableprocess block aThreadobject execute , need understand start createdThreadobjects . This could n't simpler . For process , call thestart ( ) method theThreadobjects voilà , thread begin execute individual process task . The code start three declare thread . This way , three thread begin execution one-by-one . However , concurrent programming u declare random time halting execution , output every one u would differ . Following output receive execute program . Output forcode list 3Thread-1 sleep 419 Thread-3 sleep 876 Thread-2 sleep 189 Thread-2 Thread-1 Thread-3 It note execution theThreaddid n't occur desired order . Instead ordert1–t2–t3 , thread execute order oft1–t3–t2 . The order thread execute completely dependent operating system may change every execution program , thus make output multithreaded application difficult predict control . Some people suggest major reason add complexity multithreaded programming debugging . However , observe thread put sleep use theThread.sleep ( ... ) function , execution interval order predict quite capably . The thread least amount sleep time wast2 ( `` Thread-2 '' ) with189milliseconds sleep hence get call first . Thent1was call finallyt3was call .