A List ordered Collection ( sometimes call sequence ) . Lists may contain duplicate element . In addition operation inherit Collection , List interface include operation following : Positional access — manipulate element base numerical position list . This include method get , set , add , addAll , remove . Search — search specified object list return numerical position . Search method include indexOf lastIndexOf . Iteration — extend Iterator semantics take advantage list 's sequential nature . The listIterator method provide behavior . Range-view — The sublist method performs arbitrary range operation list . The Java platform contain two general-purpose List implementation . ArrayList , usually better-performing implementation , LinkedList offer good performance certain circumstance . Collection Operations The operation inherit Collection 'd expect , assume 're already familiar . If 're familiar Collection , would good time read The Collection Interface section . The remove operation always remove first occurrence specified element list . The add addAll operation always append new element ( ) end list . Thus , following idiom concatenate one list another . list1.addAll ( list2 ) ; Here 's nondestructive form idiom , produce third List consisting second list append first . List < Type > list3 = new ArrayList < Type > ( list1 ) ; list3.addAll ( list2 ) ; Note idiom , nondestructive form , take advantage ArrayList 's standard conversion constructor . And 's example ( JDK 8 later ) aggregate name List : List < String > list = people.stream ( ) .map ( Person : :getName ) .collect ( Collectors.toList ( ) ) ; Like Set interface , List strengthen requirement equal hashCode method two List object compare logical equality without regard implementation class . Two List object equal contain element order . Positional Access Search Operations The basic positional access operation get , set , add remove . ( The set remove operation return old value overwrite remove . ) Other operation ( indexOf lastIndexOf ) return first last index specified element list . The addAll operation insert element specify Collection start specified position . The element insert order return specify Collection 's iterator . This call positional access analog Collection 's addAll operation . Here 's little method swap two indexed value List . public static < E > void swap ( List < E > , int , int j ) { E tmp = a.get ( ) ; a.set ( , a.get ( j ) ) ; a.set ( j , tmp ) ; } Of course , 's one big difference . This polymorphic algorithm : It swap two element List , regardless implementation type . Here 's another polymorphic algorithm use precede swap method . public static void shuffle ( List < ? > list , Random rnd ) { ( int = list.size ( ) ; > 1 ; -- ) swap ( list , - 1 , rnd.nextInt ( ) ) ; } This algorithm , include Java platform 's Collections class , randomly permute specified list use specify source randomness . It 's bit subtle : It run list bottom , repeatedly swap randomly select element current position . Unlike naive attempt shuffling , 's fair ( permutation occur equal likelihood , assume unbiased source randomness ) fast ( require exactly list.size ( ) -1 swap ) . The following program use algorithm print word argument list random order . import java.util . * ; public class Shuffle { public static void main ( String [ ] args ) { List < String > list = new ArrayList < String > ( ) ; ( String : args ) list.add ( ) ; Collections.shuffle ( list , new Random ( ) ) ; System.out.println ( list ) ; } } In fact , program make even short faster . The Arrays class static factory method call asList , allow array view List . This method copy array . Changes List write array vice versa . The resulting List general-purpose List implementation , n't implement ( optional ) add remove operation : Arrays resizable . Taking advantage Arrays.asList call library version shuffle , use default source randomness , get following tiny program whose behavior identical previous program . import java.util . * ; public class Shuffle { public static void main ( String [ ] args ) { List < String > list = Arrays.asList ( args ) ; Collections.shuffle ( list ) ; System.out.println ( list ) ; } } Iterators As 'd expect , Iterator return List 's iterator operation return element list proper sequence . List also provide rich iterator , call ListIterator , allow traverse list either direction , modify list iteration , obtain current position iterator . The three method ListIterator inherit Iterator ( hasNext , next , remove ) exactly thing interface . The hasPrevious previous operation exact analogue hasNext next . The former operation refer element ( implicit ) cursor , whereas latter refer element cursor . The previous operation move cursor backward , whereas next move forward . Here 's standard idiom iterate backward list . ( ListIterator < Type > = list.listIterator ( list.size ( ) ) ; it.hasPrevious ( ) ; ) { Type = it.previous ( ) ; ... } Note argument listIterator preceding idiom . The List interface two form listIterator method . The form argument return ListIterator position beginning list ; form int argument return ListIterator position specified index . The index refers element would return initial call next . An initial call previous would return element whose index index-1 . In list length n , n+1 valid value index , 0 n , inclusive . Intuitively speaking , cursor always two element — one would return call previous one would return call next . The n+1 valid index value correspond n+1 gap element , gap first element gap last one . The following figure show five possible cursor position list contain four element .