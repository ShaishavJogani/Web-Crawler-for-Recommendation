The section Interfaces describe example involve manufacturer computer-controlled car publish industry-standard interface describe method invoke operate car . What computer-controlled car manufacturer add new functionality , flight , car ? These manufacturer would need specify new method enable company ( electronic guidance instrument manufacturer ) adapt software fly car . Where would car manufacturer declare new flight-related method ? If add original interface , programmer implement interface would rewrite implementation . If add static method , programmer would regard utility method , essential , core method . Default method enable add new functionality interface library ensure binary compatibility code write old version interface . Consider following interface , TimeClient , describe Answers Questions Exercises : Interfaces : import java.time . * ; public interface TimeClient { void setTime ( int hour , int minute , int second ) ; void setDate ( int day , int month , int year ) ; void setDateAndTime ( int day , int month , int year , int hour , int minute , int second ) ; LocalDateTime getLocalDateTime ( ) ; } The following class , SimpleTimeClient , implement TimeClient : package defaultmethods ; import java.time . * ; import java.lang . * ; import java.util . * ; public class SimpleTimeClient implement TimeClient { private LocalDateTime dateAndTime ; public SimpleTimeClient ( ) { dateAndTime = LocalDateTime.now ( ) ; } public void setTime ( int hour , int minute , int second ) { LocalDate currentDate = LocalDate.from ( dateAndTime ) ; LocalTime timeToSet = LocalTime.of ( hour , minute , second ) ; dateAndTime = LocalDateTime.of ( currentDate , timeToSet ) ; } public void setDate ( int day , int month , int year ) { LocalDate dateToSet = LocalDate.of ( day , month , year ) ; LocalTime currentTime = LocalTime.from ( dateAndTime ) ; dateAndTime = LocalDateTime.of ( dateToSet , currentTime ) ; } public void setDateAndTime ( int day , int month , int year , int hour , int minute , int second ) { LocalDate dateToSet = LocalDate.of ( day , month , year ) ; LocalTime timeToSet = LocalTime.of ( hour , minute , second ) ; dateAndTime = LocalDateTime.of ( dateToSet , timeToSet ) ; } public LocalDateTime getLocalDateTime ( ) { return dateAndTime ; } public String toString ( ) { return dateAndTime.toString ( ) ; } public static void main ( String ... args ) { TimeClient myTimeClient = new SimpleTimeClient ( ) ; System.out.println ( myTimeClient.toString ( ) ) ; } } Suppose want add new functionality TimeClient interface , ability specify time zone ZonedDateTime object ( like LocalDateTime object except store time zone information ) : public interface TimeClient { void setTime ( int hour , int minute , int second ) ; void setDate ( int day , int month , int year ) ; void setDateAndTime ( int day , int month , int year , int hour , int minute , int second ) ; LocalDateTime getLocalDateTime ( ) ; ZonedDateTime getZonedDateTime ( String zoneString ) ; } Following modification TimeClient interface , would also modify class SimpleTimeClient implement method getZonedDateTime . However , rather leave getZonedDateTime abstract ( previous example ) , instead define default implementation . ( Remember abstract method method declare without implementation . ) package defaultmethods ; import java.time . * ; public interface TimeClient { void setTime ( int hour , int minute , int second ) ; void setDate ( int day , int month , int year ) ; void setDateAndTime ( int day , int month , int year , int hour , int minute , int second ) ; LocalDateTime getLocalDateTime ( ) ; static ZoneId getZoneId ( String zoneString ) { try { return ZoneId.of ( zoneString ) ; } catch ( DateTimeException e ) { System.err.println ( `` Invalid time zone : `` + zoneString + `` ; use default time zone instead . `` ) ; return ZoneId.systemDefault ( ) ; } } default ZonedDateTime getZonedDateTime ( String zoneString ) { return ZonedDateTime.of ( getLocalDateTime ( ) , getZoneId ( zoneString ) ) ; } } You specify method definition interface default method default keyword beginning method signature . All method declaration interface , include default method , implicitly public , omit public modifier . With interface , modify class SimpleTimeClient , class ( class implement interface TimeClient ) , method getZonedDateTime already define . The following example , TestSimpleTimeClient , invoke method getZonedDateTime instance SimpleTimeClient : package defaultmethods ; import java.time . * ; import java.lang . * ; import java.util . * ; public class TestSimpleTimeClient { public static void main ( String ... args ) { TimeClient myTimeClient = new SimpleTimeClient ( ) ; System.out.println ( `` Current time : `` + myTimeClient.toString ( ) ) ; System.out.println ( `` Time California : `` + myTimeClient.getZonedDateTime ( `` Blah blah '' ) .toString ( ) ) ; } } Extending Interfaces That Contain Default Methods When extend interface contain default method , following : Not mention default method , let extended interface inherit default method . Redeclare default method , make abstract . Redefine default method , override . Suppose extend interface TimeClient follow : public interface AnotherTimeClient extend TimeClient { } Any class implement interface AnotherTimeClient implementation specify default method TimeClient.getZonedDateTime . Suppose extend interface TimeClient follow : public interface AbstractZoneTimeClient extend TimeClient { public ZonedDateTime getZonedDateTime ( String zoneString ) ; } Any class implement interface AbstractZoneTimeClient implement method getZonedDateTime ; method abstract method like nondefault ( nonstatic ) method interface . Suppose extend interface TimeClient follow : public interface HandleInvalidTimeZoneClient extend TimeClient { default public ZonedDateTime getZonedDateTime ( String zoneString ) { try { return ZonedDateTime.of ( getLocalDateTime ( ) , ZoneId.of ( zoneString ) ) ; } catch ( DateTimeException e ) { System.err.println ( `` Invalid zone ID : `` + zoneString + `` ; use default time zone instead . `` ) ; return ZonedDateTime.of ( getLocalDateTime ( ) , ZoneId.systemDefault ( ) ) ; } } } Any class implement interface HandleInvalidTimeZoneClient use implementation getZonedDateTime specify interface instead one specify interface TimeClient . Static Methods In addition default method , define static method interface . ( A static method method associate class define rather object . Every instance class share static method . ) This make easy organize helper method library ; keep static method specific interface interface rather separate class . The following example define static method retrieve ZoneId object correspond time zone identifier ; use system default time zone ZoneId object correspond give identifier . ( As result , simplify method getZonedDateTime ) : public interface TimeClient { // ... static public ZoneId getZoneId ( String zoneString ) { try { return ZoneId.of ( zoneString ) ; } catch ( DateTimeException e ) { System.err.println ( `` Invalid time zone : `` + zoneString + `` ; use default time zone instead . `` ) ; return ZoneId.systemDefault ( ) ; } } default public ZonedDateTime getZonedDateTime ( String zoneString ) { return ZonedDateTime.of ( getLocalDateTime ( ) , getZoneId ( zoneString ) ) ; } } Like static method class , specify method definition interface static method static keyword beginning method signature . All method declaration interface , include static method , implicitly public , omit public modifier . Integrating Default Methods Existing Libraries Default method enable add new functionality exist interface ensure binary compatibility code write old version interface . In particular , default method enable add method accept lambda expression parameter exist interface . This section demonstrate Comparator interface enhance default static method . Consider Card Deck class describe Questions Exercises : Classes . This example rewrite Card Deck class interface . The Card interface contain two enum type ( Suit Rank ) two abstract method ( getSuit getRank ) : package defaultmethods ; public interface Card extend Comparable < Card > { public enum Suit { DIAMONDS ( 1 , `` Diamonds '' ) , CLUBS ( 2 , `` Clubs '' ) , HEARTS ( 3 , `` Hearts '' ) , SPADES ( 4 , `` Spades '' ) ; private final int value ; private final String text ; Suit ( int value , String text ) { this.value = value ; this.text = text ; } public int value ( ) { return value ; } public String text ( ) { return text ; } } public enum Rank { DEUCE ( 2 , `` Two '' ) , THREE ( 3 , `` Three '' ) , FOUR ( 4 , `` Four '' ) , FIVE ( 5 , `` Five '' ) , SIX ( 6 , `` Six '' ) , SEVEN ( 7 , `` Seven '' ) , EIGHT ( 8 , `` Eight '' ) , NINE ( 9 , `` Nine '' ) , TEN ( 10 , `` Ten '' ) , JACK ( 11 , `` Jack '' ) , QUEEN ( 12 , `` Queen '' ) , KING ( 13 , `` King '' ) , ACE ( 14 , `` Ace '' ) ; private final int value ; private final String text ; Rank ( int value , String text ) { this.value = value ; this.text = text ; } public int value ( ) { return value ; } public String text ( ) { return text ; } } public Card.Suit getSuit ( ) ; public Card.Rank getRank ( ) ; } The Deck interface contain various method manipulate card deck : package defaultmethods ; import java.util . * ; import java.util.stream . * ; import java.lang . * ; public interface Deck { List < Card > getCards ( ) ; Deck deckFactory ( ) ; int size ( ) ; void addCard ( Card card ) ; void addCards ( List < Card > card ) ; void addDeck ( Deck deck ) ; void shuffle ( ) ; void sort ( ) ; void sort ( Comparator < Card > c ) ; String deckToString ( ) ; Map < Integer , Deck > deal ( int player , int numberOfCards ) throw IllegalArgumentException ; } The class PlayingCard implement interface Card , class StandardDeck implement interface Deck . The class StandardDeck implement abstract method Deck.sort follow : public class StandardDeck implement Deck { private List < Card > entireDeck ; // ... public void sort ( ) { Collections.sort ( entireDeck ) ; } // ... } The method Collections.sort sort instance List whose element type implement interface Comparable . The member entireDeck instance List whose element type Card , extend Comparable . The class PlayingCard implement Comparable.compareTo method follow : public int hashCode ( ) { return ( ( suit.value ( ) -1 ) *13 ) +rank.value ( ) ; } public int compareTo ( Card ) { return this.hashCode ( ) - o.hashCode ( ) ; } The method compareTo cause method StandardDeck.sort ( ) sort deck card first suit , rank . What want sort deck first rank , suit ? You would need implement Comparator interface specify new sort criterion , use method sort ( List < T > list , Comparator < ? super T > c ) ( version sort method include Comparator parameter ) . You define following method class StandardDeck : public void sort ( Comparator < Card > c ) { Collections.sort ( entireDeck , c ) ; } With method , specify method Collections.sort sort instance Card class . One way implement Comparator interface specify want card sort . The example SortByRankThenSuit : package defaultmethods ; import java.util . * ; import java.util.stream . * ; import java.lang . * ; public class SortByRankThenSuit implement Comparator < Card > { public int compare ( Card firstCard , Card secondCard ) { int compVal = firstCard.getRank ( ) .value ( ) - secondCard.getRank ( ) .value ( ) ; ( compVal ! = 0 ) return compVal ; else return firstCard.getSuit ( ) .value ( ) - secondCard.getSuit ( ) .value ( ) ; } } The following invocation sort deck play card first rank , suit : StandardDeck myDeck = new StandardDeck ( ) ; myDeck.shuffle ( ) ; myDeck.sort ( new SortByRankThenSuit ( ) ) ; However , approach verbose ; would good could specify want sort , want sort . Suppose developer write Comparator interface . What default static method could add Comparator interface enable developer easily specify sort criterion ? To start , suppose want sort deck play card rank , regardless suit . You invoke StandardDeck.sort method follow : StandardDeck myDeck = new StandardDeck ( ) ; myDeck.shuffle ( ) ; myDeck.sort ( ( firstCard , secondCard ) - > firstCard.getRank ( ) .value ( ) - secondCard.getRank ( ) .value ( ) ) ; Because interface Comparator functional interface , use lambda expression argument sort method . In example , lambda expression compare two integer value . It would simpler developer could create Comparator instance invoke method Card.getRank . In particular , would helpful developer could create Comparator instance compare object return numerical value method getValue hashCode . The Comparator interface enhance ability static method comparing : myDeck.sort ( Comparator.comparing ( ( card ) - > card.getRank ( ) ) ) ; In example , use method reference instead : myDeck.sort ( Comparator.comparing ( Card : :getRank ) ) ; This invocation well demonstrate sort rather . The Comparator interface enhance version static method compare comparingDouble comparingLong enable create Comparator instance compare data type . Suppose developer would like create Comparator instance could compare object one criterion . For example , would sort deck play card first rank , suit ? As , could use lambda expression specify sort criterion : StandardDeck myDeck = new StandardDeck ( ) ; myDeck.shuffle ( ) ; myDeck.sort ( ( firstCard , secondCard ) - > { int compare = firstCard.getRank ( ) .value ( ) - secondCard.getRank ( ) .value ( ) ; ( compare ! = 0 ) return compare ; else return firstCard.getSuit ( ) .value ( ) - secondCard.getSuit ( ) .value ( ) ; } ) ; It would simpler developer could build Comparator instance series Comparator instance . The Comparator interface enhance ability default method thenComparing : myDeck.sort ( Comparator .comparing ( Card : :getRank ) .thenComparing ( Comparator.comparing ( Card : :getSuit ) ) ) ; The Comparator interface enhance version default method thenComparing ( thenComparingDouble thenComparingLong ) enable build Comparator instance compare data type . Suppose developer would like create Comparator instance enable sort collection object reverse order . For example , would sort deck play card first descend order rank , Ace Two ( instead Two Ace ) ? As , could specify another lambda expression . However , would simpler developer could reverse exist Comparator invoke method . The Comparator interface enhance ability default method reverse : myDeck.sort ( Comparator.comparing ( Card : :getRank ) .reversed ( ) .thenComparing ( Comparator.comparing ( Card : :getSuit ) ) ) ; This example demonstrate Comparator interface enhance default method , static method , lambda expression , method reference create expressive library method whose functionality programmer quickly deduce look invoke . Use construct enhance interface library .