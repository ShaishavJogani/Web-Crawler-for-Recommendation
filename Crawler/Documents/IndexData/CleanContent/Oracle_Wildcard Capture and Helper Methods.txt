In case , compiler infer type wildcard . For example , list may define List < ? > , evaluate expression , compiler infer particular type code . This scenario know wildcard capture . For part , n't need worry wildcard capture , except see error message contain phrase `` capture '' . The WildcardError example produce capture error compile : import java.util.List ; public class WildcardError { void foo ( List < ? > ) { i.set ( 0 , i.get ( 0 ) ) ; } } In example , compiler process input parameter type Object . When foo method invokes List.set ( int , E ) , compiler able confirm type object insert list , error produce . When type error occur typically mean compiler believe assign wrong type variable . Generics add Java language reason â€” enforce type safety compile time . The WildcardError example generate following error compile Oracle 's JDK 7 javac implementation : WildcardError.java:6 : error : method set interface List < E > apply give type ; i.set ( 0 , i.get ( 0 ) ) ; ^ require : int , CAP # 1 found : int , Object reason : actual argument Object convert CAP # 1 method invocation conversion E type-variable : E extend Object declare interface List CAP # 1 fresh type-variable : CAP # 1 extends Object capture ? 1 error In example , code attempt perform safe operation , work around compiler error ? You fix write private helper method capture wildcard . In case , work around problem create private helper method , fooHelper , show WildcardFixed : public class WildcardFixed { void foo ( List < ? > ) { fooHelper ( ) ; } // Helper method create wildcard capture // type inference . private < T > void fooHelper ( List < T > l ) { l.set ( 0 , l.get ( 0 ) ) ; } } Thanks helper method , compiler use inference determine T CAP # 1 , capture variable , invocation . The example compile successfully . By convention , helper method generally name originalMethodNameHelper . Now consider complex example , WildcardErrorBad : import java.util.List ; public class WildcardErrorBad { void swapFirst ( List < ? extends Number > l1 , List < ? extends Number > l2 ) { Number temp = l1.get ( 0 ) ; l1.set ( 0 , l2.get ( 0 ) ) ; // expect CAP # 1 extends Number , // get CAP # 2 extends Number ; // bound , different type l2.set ( 0 , temp ) ; // expect CAP # 1 extends Number , // get Number } } In example , code attempt unsafe operation . For example , consider following invocation swapFirst method : List < Integer > li = Arrays.asList ( 1 , 2 , 3 ) ; List < Double > ld = Arrays.asList ( 10.10 , 20.20 , 30.30 ) ; swapFirst ( li , ld ) ; While List < Integer > List < Double > fulfill criterion List < ? extends Number > , clearly incorrect take item list Integer value attempt place list Double value . Compiling code Oracle 's JDK javac compiler produce following error : WildcardErrorBad.java:7 : error : method set interface List < E > apply give type ; l1.set ( 0 , l2.get ( 0 ) ) ; // expect CAP # 1 extends Number , ^ require : int , CAP # 1 found : int , Number reason : actual argument Number convert CAP # 1 method invocation conversion E type-variable : E extend Object declare interface List CAP # 1 fresh type-variable : CAP # 1 extends Number capture ? extends Number WildcardErrorBad.java:10 : error : method set interface List < E > apply give type ; l2.set ( 0 , temp ) ; // expect CAP # 1 extends Number , ^ require : int , CAP # 1 found : int , Number reason : actual argument Number convert CAP # 1 method invocation conversion E type-variable : E extend Object declare interface List CAP # 1 fresh type-variable : CAP # 1 extends Number capture ? extends Number WildcardErrorBad.java:15 : error : method set interface List < E > apply give type ; i.set ( 0 , i.get ( 0 ) ) ; ^ require : int , CAP # 1 found : int , Object reason : actual argument Object convert CAP # 1 method invocation conversion E type-variable : E extend Object declare interface List CAP # 1 fresh type-variable : CAP # 1 extends Object capture ? 3 error There helper method work around problem , code fundamentally wrong .