There several modifier may part method declaration : Access modifier : public , protect , private Modifier restrict one instance : static Modifier prohibit value modification : final Modifier require override : abstract Modifier prevent reentrancy : synchronize Modifier indicate implementation another programming language : native Modifier force strict float point behavior : strictfp Annotations The MethodModifierSpy example list modifier method give name . It also display whether method synthetic ( compiler-generated ) , variable arity , bridge method ( compiler-generated support generic interface ) . import java.lang.reflect.Method ; import java.lang.reflect.Modifier ; import static java.lang.System.out ; public class MethodModifierSpy { private static int count ; private static synchronize void inc ( ) { count++ ; } private static synchronize int cnt ( ) { return count ; } public static void main ( String ... args ) { try { Class < ? > c = Class.forName ( args [ 0 ] ) ; Method [ ] allMethods = c.getDeclaredMethods ( ) ; ( Method : allMethods ) { ( ! m.getName ( ) .equals ( args [ 1 ] ) ) { continue ; } out.format ( `` % % n '' , m.toGenericString ( ) ) ; out.format ( `` Modifiers : % % n '' , Modifier.toString ( m.getModifiers ( ) ) ) ; out.format ( `` [ synthetic= % -5b var_args= % -5b bridge= % -5b ] % n '' , m.isSynthetic ( ) , m.isVarArgs ( ) , m.isBridge ( ) ) ; inc ( ) ; } out.format ( `` % matching overload % find % n '' , cnt ( ) , ( cnt ( ) == 1 ? `` '' : `` '' ) ) ; // production code handle exception gracefully } catch ( ClassNotFoundException x ) { x.printStackTrace ( ) ; } } } A example output MethodModifierSpy produce follow . $ java MethodModifierSpy java.lang.Object wait public final void java.lang.Object.wait ( ) throw java.lang.InterruptedException Modifiers : public final [ synthetic=false var_args=false bridge=false ] public final void java.lang.Object.wait ( long , int ) throw java.lang.InterruptedException Modifiers : public final [ synthetic=false var_args=false bridge=false ] public final native void java.lang.Object.wait ( long ) throw java.lang.InterruptedException Modifiers : public final native [ synthetic=false var_args=false bridge=false ] 3 match overload find $ java MethodModifierSpy java.lang.StrictMath toRadians public static double java.lang.StrictMath.toRadians ( double ) Modifiers : public static strictfp [ synthetic=false var_args=false bridge=false ] 1 match overload find $ java MethodModifierSpy MethodModifierSpy inc private synchronize void MethodModifierSpy.inc ( ) Modifiers : private synchronize [ synthetic=false var_args=false bridge=false ] 1 match overload find $ java MethodModifierSpy java.lang.Class getConstructor public java.lang.reflect.Constructor < T > java.lang.Class.getConstructor ( java.lang.Class < T > [ ] ) throw java.lang.NoSuchMethodException , java.lang.SecurityException Modifiers : public transient [ synthetic=false var_args=true bridge=false ] 1 matching overload find $ java MethodModifierSpy java.lang.String compareTo public int java.lang.String.compareTo ( java.lang.String ) Modifiers : public [ synthetic=false var_args=false bridge=false ] public int java.lang.String.compareTo ( java.lang.Object ) Modifiers : public volatile [ synthetic=true var_args=false bridge=true ] 2 match overload find Note Method.isVarArgs ( ) return true Class.getConstructor ( ) . This indicate method declaration look like : public Constructor < T > getConstructor ( Class < ? > ... parameterTypes ) like : public Constructor < T > getConstructor ( Class < ? > [ ] parameterTypes ) Notice output String.compareTo ( ) contain two method . The method declare String.java : public int compareTo ( String anotherString ) ; second synthetic compiler-generated bridge method . This occur String implement parameterized interface Comparable . During type erasure , argument type inherited method Comparable.compareTo ( ) change java.lang.Object java.lang.String . Since parameter type compareTo method Comparable String longer match erasure , override occur . In circumstance , would produce compile-time error interface implement . The addition bridge method avoids problem . Method implement java.lang.reflect.AnnotatedElement . Thus runtime annotation java.lang.annotation.RetentionPolicy.RUNTIME may retrieve . For example obtain annotation see section Examining Class Modifiers Types .