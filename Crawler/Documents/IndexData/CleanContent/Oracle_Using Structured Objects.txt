Note : MySQL Java DB currently support user-defined type . Consequently , JDBC tutorial example available demonstrate feature describe section . The following topic cover : Overview Structured Types Using DISTINCT Type Structured Types Using References Structured Types Sample Code Creating SQL REF Object Using User-Defined Types Column Values Inserting User-Defined Types Tables Overview Structured Types SQL structure type DISTINCT type two data type user define SQL . They often refer UDTs ( user-defined type ) , create SQL CREATE TYPE statement . Getting back example The Coffee Break , suppose owner successful beyond expectation expand new branch . The owner decide add STORES table database contain information establishment . STORES four column : STORE_NO store 's identification number LOCATION address COF_TYPES coffee sell MGR name store manager The owner make column LOCATION SQL structure type , column COF_TYPES SQL ARRAY , column MGR REF ( MANAGER ) , MANAGER SQL structure type . The first thing owner must define new structured type address manager . A SQL structure type similar structured type Java programming language member , call attribute , may data type . The owner write following SQL statement create new data type ADDRESS : CREATE TYPE ADDRESS ( NUM INTEGER , STREET VARCHAR ( 40 ) , CITY VARCHAR ( 40 ) , STATE CHAR ( 2 ) , ZIP CHAR ( 5 ) ) ; In statement , new type ADDRESS five attribute , analogous field Java class . The attribute NUM INTEGER , attribute STREET VARCHAR ( 40 ) , attribute CITY VARCHAR ( 40 ) , attribute STATE CHAR ( 2 ) , attribute ZIP CHAR ( 5 ) . The following excerpt , con valid Connection object , send definition ADDRESS database : String createAddress = `` CREATE TYPE ADDRESS `` + `` ( NUM INTEGER , STREET VARCHAR ( 40 ) , `` + `` CITY VARCHAR ( 40 ) , STATE CHAR ( 2 ) , ZIP CHAR ( 5 ) ) '' ; Statement stmt = con.createStatement ( ) ; stmt.executeUpdate ( createAddress ) ; Now ADDRESS structure type register database data type , owner use data type table column attribute structured type . Using DISTINCT Type Structured Type One attribute owner The Coffee Break plan include new structured type MANAGER manager 's telephone number . Because owner always list telephone number 10-digit number ( sure include area code ) never manipulate number , owner decide define new type call PHONE_NO consist 10 character . The SQL definition data type , think structured type one attribute , look like : CREATE TYPE PHONE_NO AS CHAR ( 10 ) ; Or , note earlier , driver definition might look like : CREATE DISTINCT TYPE PHONE_NO AS CHAR ( 10 ) ; A DISTINCT type always base another data type , must predefined type . In word , DISTINCT type base user-defined type ( UDT ) . To retrieve set value DISTINCT type , use appropriate method underlying type ( type base ) . For example , retrieve instance PHONE_NO , base CHAR type , would use method getString method retrieve CHAR . Assuming value type PHONE_NO fourth column current row ResultSet object r , following line code retrieves : String phoneNumber = rs.getString ( 4 ) ; Similarly , following line code set input parameter type PHONE_NO prepared statement send database : pstmt.setString ( 1 , phoneNumber ) ; Adding previous code fragment , definition PHONE_NO send database following line code : stmt.executeUpdate ( `` CREATE TYPE PHONE_NO AS CHAR ( 10 ) '' ) ; After register type PHONE_NO database , owner use column type table data type attribute structured type . The definition MANAGER following SQL statement use PHONE_NO data type attribute PHONE : CREATE TYPE MANAGER ( MGR_ID INTEGER , LAST_NAME VARCHAR ( 40 ) , FIRST_NAME VARCHAR ( 40 ) , PHONE PHONE_NO ) ; Reusing stmt , define previously , following code fragment send definition structured type MANAGER database : String createManager = `` CREATE TYPE MANAGER `` + `` ( MGR_ID INTEGER , LAST_NAME `` + `` VARCHAR ( 40 ) , `` + `` FIRST_NAME VARCHAR ( 40 ) , `` + `` PHONE PHONE_NO ) '' ; stmt.executeUpdate ( createManager ) ; Using References Structured Types The owner The Coffee Break create three new data type use column type attribute type database : The structured type LOCATION MANAGER , DISTINCT type PHONE_NO . The entrepreneur use PHONE_NO type attribute PHONE new type MANAGER , ADDRESS data type column LOCATION table STORES . The MANAGER type could use type column MGR , instead entrepreneur prefers use type REF ( MANAGER ) entrepreneur often one person manage two three store . Using REF ( MANAGER ) column type avoids repeat data MANAGER one person manage one store . With structured type MANAGER already create , owner create table containing instance MANAGER reference . A reference instance MANAGER type REF ( MANAGER ) . A SQL REF nothing logical pointer structured type , instance REF ( MANAGER ) serve logical pointer instance MANAGER . Because SQL REF value need permanently associate instance structured type reference , store special table together associate instance . A programmer create REF type directly rather create table store instance particular structured type reference . Every structure type reference table . When insert instance structured type table , database automatically create REF instance . For example , contain instance MANAGER reference , owner create following special table use SQL : CREATE TABLE MANAGERS OF MANAGER ( OID REF ( MANAGER ) VALUES ARE SYSTEM GENERATED ) ; This statement create table special column OID , store value type REF ( MANAGER ) . Each time instance MANAGER insert table , database generate instance REF ( MANAGER ) store column OID . Implicitly , additional column store attribute MANAGER insert table , well . For example , following code fragment show entrepreneur create three instance MANAGER structure type represent three manager : INSERT INTO MANAGERS ( MGR_ID , LAST_NAME , FIRST_NAME , PHONE ) VALUES ( 000001 , 'MONTOYA ' , 'ALFREDO ' , '8317225600' ) ; INSERT INTO MANAGERS ( MGR_ID , LAST_NAME , FIRST_NAME , PHONE ) VALUES ( 000002 , 'HASKINS ' , 'MARGARET ' , '4084355600' ) ; INSERT INTO MANAGERS ( MGR_ID , LAST_NAME , FIRST_NAME , PHONE ) VALUES ( 000003 , 'CHEN ' , 'HELEN ' , '4153785600' ) ; The table MANAGERS three row , one row manager insert far . The column OID contain three unique object identifier type REF ( MANAGER ) , one instance MANAGER . These object identifier generate automatically database permanently store table MANAGERS . Implicitly , additional column store attribute MANAGER . For example , table MANAGERS , one row contain REF ( MANAGER ) reference Alfredo Montoya , another row contain REF ( MANAGER ) reference Margaret Haskins , third row contain REF ( MANAGER ) reference Helen Chen . To access REF ( MANAGER ) instance , select table . For example , owner retrieve reference Alfredo Montoya , whose ID number 000001 , following code fragment : String selectMgr = `` SELECT OID FROM MANAGERS `` + `` WHERE MGR_ID = 000001 '' ; ResultSet rs = stmt.executeQuery ( selectMgr ) ; rs.next ( ) ; Ref manager = rs.getRef ( `` OID '' ) ; Now variable manager use column value reference Alfredo Montoya . Sample Code Creating SQL REF Object The following code example create table MANAGERS , table instance structured type MANAGER reference , insert three instance MANAGER table . The column OID table store instance REF ( MANAGER ) . After code execute , MANAGERS table row three MANAGER object insert , value OID column REF ( MANAGER ) type identify instance MANAGER store row . package com.oracle.tutorial.jdbc ; import java.sql . * ; public class CreateRef { public static void main ( String args [ ] ) { JDBCTutorialUtilities myJDBCTutorialUtilities ; Connection myConnection = null ; ( args [ 0 ] == null ) { System.err.println ( `` Properties file specify `` + `` command line '' ) ; return ; } else { try { myJDBCTutorialUtilities = new JDBCTutorialUtilities ( args [ 0 ] ) ; } catch ( Exception e ) { System.err.println ( `` Problem reading property `` + `` file `` + args [ 0 ] ) ; e.printStackTrace ( ) ; return ; } } Connection con = null ; Statement stmt = null ; try { String createManagers = `` CREATE TABLE `` + `` MANAGERS OF MANAGER `` + `` ( OID REF ( MANAGER ) `` + `` VALUES ARE SYSTEM `` + `` GENERATED ) '' ; String insertManager1 = `` INSERT INTO MANAGERS `` + `` ( MGR_ID , LAST_NAME , `` + `` FIRST_NAME , PHONE ) `` + `` VALUES `` + `` ( 000001 , 'MONTOYA ' , `` + `` 'ALFREDO ' , `` + `` '8317225600 ' ) '' ; String insertManager2 = `` INSERT INTO MANAGERS `` + `` ( MGR_ID , LAST_NAME , `` + `` FIRST_NAME , PHONE ) `` + `` VALUES `` + `` ( 000002 , 'HASKINS ' , `` + `` 'MARGARET ' , `` + `` '4084355600 ' ) '' ; String insertManager3 = `` INSERT INTO MANAGERS `` + `` ( MGR_ID , LAST_NAME , `` + `` FIRST_NAME , PHONE ) `` + `` VALUES `` + `` ( 000003 , 'CHEN ' , 'HELEN ' , `` + `` '4153785600 ' ) '' ; con = myJDBCTutorialUtilities.getConnection ( ) ; con.setAutoCommit ( false ) ; stmt = con.createStatement ( ) ; stmt.executeUpdate ( createManagers ) ; stmt.addBatch ( insertManager1 ) ; stmt.addBatch ( insertManager2 ) ; stmt.addBatch ( insertManager3 ) ; int [ ] updateCounts = stmt.executeBatch ( ) ; con.commit ( ) ; System.out.println ( `` Update count : `` ) ; ( int = 0 ; < updateCounts.length ; i++ ) { System.out.print ( `` command `` + ( + 1 ) + `` = `` ) ; System.out.println ( updateCounts [ ] ) ; } } catch ( BatchUpdateException b ) { System.err.println ( `` -- -- -BatchUpdateException -- -- - '' ) ; System.err.println ( `` Message : `` + b.getMessage ( ) ) ; System.err.println ( `` SQLState : `` + b.getSQLState ( ) ) ; System.err.println ( `` Vendor : `` + b.getErrorCode ( ) ) ; System.err.print ( `` Update count `` + `` successful command : `` ) ; int [ ] rowsUpdated = b.getUpdateCounts ( ) ; ( int = 0 ; < rowsUpdated.length ; i++ ) { System.err.print ( rowsUpdated [ ] + `` `` ) ; } System.err.println ( `` '' ) ; } catch ( SQLException ex ) { System.err.println ( `` -- -- -- SQLException -- -- -- '' ) ; System.err.println ( `` Error message : `` + ex.getMessage ( ) ) ; System.err.println ( `` SQLState : `` + ex.getSQLState ( ) ) ; System.err.println ( `` Vendor : `` + ex.getErrorCode ( ) ) ; } finally { ( stmt ! = null ) { stmt.close ( ) ; } JDBCTutorialUtilities.closeConnection ( con ) ; } } } Using User-Defined Types Column Values Our entrepreneur UDTs require create table STORES . The structured type ADDRESS type column LOCATION , type REF ( MANAGER ) type column MGR . The UDT COF_TYPES base SQL data type ARRAY type column COF_TYPES . The following line code create type COF_ARRAY ARRAY value 10 element . The base type COF_ARRAY VARCHAR ( 40 ) . CREATE TYPE COF_ARRAY AS ARRAY ( 10 ) OF VARCHAR ( 40 ) ; With new data type define , following SQL statement create table STORES : CREATE TABLE STORES ( STORE_NO INTEGER , LOCATION ADDRESS , COF_TYPES COF_ARRAY , MGR REF ( MANAGER ) ) ; Inserting User-Defined Types Tables The following code fragment insert one row STORES table , supply value column STORE_NO , LOCATION , COF_TYPES , MGR , order : INSERT INTO STORES VALUES ( 100001 , ADDRESS ( 888 , 'Main_Street ' , 'Rancho_Alegre ' , 'CA ' , '94049 ' ) , COF_ARRAY ( 'Colombian ' , 'French_Roast ' , 'Espresso ' , 'Colombian_Decaf ' , 'French_Roast_Decaf ' ) , SELECT OID FROM MANAGERS WHERE MGR_ID = 000001 ) ; The following go column value insert . STORE_NO : 100001 This column type INTEGER , number 100001 INTEGER type , similar entry make table COFFEES SUPPLIERS . LOCATION : ADDRESS ( 888 , 'Main_Street ' , 'Rancho_Alegre ' , 'CA ' , '94049 ' ) The type column structured type ADDRESS , value constructor instance ADDRESS . When send definition ADDRESS send database , one thing create constructor new type . The comma-separated value parenthesis initialization value attribute ADDRESS type , must appear order attribute list definition ADDRESS type . 888 value attribute NUM , INTEGER value . `` Main_Street '' value STREET , `` Rancho_Alegre '' value CITY , attribute type VARCHAR ( 40 ) . The value attribute STATE `` CA '' , type CHAR ( 2 ) , value attribute ZIP `` 94049 '' , type CHAR ( 5 ) . COF_TYPES : COF_ARRAY ( 'Colombian ' , 'French_Roast ' , 'Espresso ' , 'Colombian_Decaf ' , 'French_Roast_Decaf ' ) , The column COF_TYPES type COF_ARRAY base type VARCHAR ( 40 ) , comma-separated value parenthesis String object array element . The owner define type COF_ARRAY maximum 10 element . This array 5 element entrepreneur supply 5 String object . MGR : SELECT OID FROM MANAGERS WHERE MGR_ID = 000001 The column MGR type REF ( MANAGER ) , mean value column must reference structure type MANAGER . All instance MANAGER store table MANAGERS . All instance REF ( MANAGER ) also store table , column OID . The manager store describe table row Alfredo Montoya , information store instance MANAGER 100001 attribute MGR_ID . To get REF ( MANAGER ) instance associate MANAGER object Alfredo Montoya , select column OID row MGR_ID 100001 table MANAGERS . The value store MGR column STORES table ( REF ( MANAGER ) value ) value DBMS generate uniquely identify instance MANAGER structure type . Send precede SQL statement database following code fragment : String insertMgr = `` INSERT INTO STORES VALUES `` + `` ( 100001 , `` + `` ADDRESS ( 888 , 'Main_Street ' , `` + `` 'Rancho_Alegre ' , 'CA ' , `` + `` '94049 ' ) , `` + `` COF_ARRAY ( 'Colombian ' , `` + `` 'French_Roast ' , 'Espresso ' , `` + `` 'Colombian_Decaf ' , `` + `` 'French_Roast_Decaf ' } , `` + `` SELECT OID FROM MANAGERS `` + `` WHERE MGR_ID = 000001 ) '' ; stmt.executeUpdate ( insertMgr ) ; However , go send several INSERT INTO statement , efficient send together batch update , following code example : package com.oracle.tutorial.jdbc ; import java.sql . * ; public class InsertStores { public static void main ( String args [ ] ) { JDBCTutorialUtilities myJDBCTutorialUtilities ; Connection myConnection = null ; ( args [ 0 ] == null ) { System.err.println ( `` Properties file `` + `` specify `` + `` command line '' ) ; return ; } else { try { myJDBCTutorialUtilities = new JDBCTutorialUtilities ( args [ 0 ] ) ; } catch ( Exception e ) { System.err.println ( `` Problem reading `` + `` property file `` + args [ 0 ] ) ; e.printStackTrace ( ) ; return ; } } Connection con = null ; Statement stmt = null ; try { con = myJDBCTutorialUtilities.getConnection ( ) ; con.setAutoCommit ( false ) ; stmt = con.createStatement ( ) ; String insertStore1 = `` INSERT INTO STORES VALUES ( `` + `` 100001 , `` + `` ADDRESS ( 888 , 'Main_Street ' , `` + `` 'Rancho_Alegre ' , 'CA ' , `` + `` '94049 ' ) , `` + `` COF_ARRAY ( 'Colombian ' , `` + `` 'French_Roast ' , `` + `` 'Espresso ' , `` + `` 'Colombian_Decaf ' , `` + `` 'French_Roast_Decaf ' ) , `` + `` ( SELECT OID FROM MANAGERS `` + `` WHERE MGR_ID = 000001 ) ) '' ; stmt.addBatch ( insertStore1 ) ; String insertStore2 = `` INSERT INTO STORES VALUES ( `` + `` 100002 , `` + `` ADDRESS ( 1560 , 'Alder ' , `` + `` 'Ochos_Pinos ' , `` + `` 'CA ' , '94049 ' ) , `` + `` COF_ARRAY ( 'Colombian ' , `` + `` 'French_Roast ' , `` + `` 'Espresso ' , `` + `` 'Colombian_Decaf ' , `` + `` 'French_Roast_Decaf ' , `` + `` 'Kona ' , 'Kona_Decaf ' ) , `` + `` ( SELECT OID FROM MANAGERS `` + `` WHERE MGR_ID = 000001 ) ) '' ; stmt.addBatch ( insertStore2 ) ; String insertStore3 = `` INSERT INTO STORES VALUES ( `` + `` 100003 , `` + `` ADDRESS ( 4344 , `` + `` 'First_Street ' , `` + `` 'Verona ' , `` + `` 'CA ' , '94545 ' ) , `` + `` COF_ARRAY ( 'Colombian ' , `` + `` 'French_Roast ' , `` + `` 'Espresso ' , `` + `` 'Colombian_Decaf ' , `` + `` 'French_Roast_Decaf ' , `` + `` 'Kona ' , 'Kona_Decaf ' ) , `` + `` ( SELECT OID FROM MANAGERS `` + `` WHERE MGR_ID = 000002 ) ) '' ; stmt.addBatch ( insertStore3 ) ; String insertStore4 = `` INSERT INTO STORES VALUES ( `` + `` 100004 , `` + `` ADDRESS ( 321 , 'Sandy_Way ' , `` + `` 'La_Playa ' , `` + `` 'CA ' , '94544 ' ) , `` + `` COF_ARRAY ( 'Colombian ' , `` + `` 'French_Roast ' , `` + `` 'Espresso ' , `` + `` 'Colombian_Decaf ' , `` + `` 'French_Roast_Decaf ' , `` + `` 'Kona ' , 'Kona_Decaf ' ) , `` + `` ( SELECT OID FROM MANAGERS `` + `` WHERE MGR_ID = 000002 ) ) '' ; stmt.addBatch ( insertStore4 ) ; String insertStore5 = `` INSERT INTO STORES VALUES ( `` + `` 100005 , `` + `` ADDRESS ( 1000 , 'Clover_Road ' , `` + `` 'Happyville ' , `` + `` 'CA ' , '90566 ' ) , `` + `` COF_ARRAY ( 'Colombian ' , `` + `` 'French_Roast ' , `` + `` 'Espresso ' , `` + `` 'Colombian_Decaf ' , `` + `` 'French_Roast_Decaf ' ) , `` + `` ( SELECT OID FROM MANAGERS `` + `` WHERE MGR_ID = 000003 ) ) '' ; stmt.addBatch ( insertStore5 ) ; int [ ] updateCounts = stmt.executeBatch ( ) ; ResultSet rs = stmt.executeQuery ( `` SELECT * FROM STORES '' ) ; System.out.println ( `` Table STORES insertion : '' ) ; System.out.println ( `` STORE_NO `` + `` LOCATION `` + `` COF_TYPE `` + `` MGR '' ) ; ( rs.next ( ) ) { int storeNo = rs.getInt ( `` STORE_NO '' ) ; Struct location = ( Struct ) rs.getObject ( `` LOCATION '' ) ; Object [ ] locAttrs = location.getAttributes ( ) ; Array coffeeTypes = rs.getArray ( `` COF_TYPE '' ) ; String [ ] cofTypes = ( String [ ] ) coffeeTypes.getArray ( ) ; Ref managerRef = rs.getRef ( `` MGR '' ) ; PreparedStatement pstmt = con.prepareStatement ( `` SELECT MANAGER `` + `` FROM MANAGERS `` + `` WHERE OID = ? `` ) ; pstmt.setRef ( 1 , managerRef ) ; ResultSet rs2 = pstmt.executeQuery ( ) ; rs2.next ( ) ; Struct manager = ( Struct ) rs2.getObject ( `` MANAGER '' ) ; Object [ ] manAttrs = manager.getAttributes ( ) ; System.out.print ( storeNo + `` `` ) ; System.out.print ( locAttrs [ 0 ] + `` `` + locAttrs [ 1 ] + `` `` + locAttrs [ 2 ] + `` , `` + locAttrs [ 3 ] + `` `` + locAttrs [ 4 ] + `` `` ) ; ( int = 0 ; < cofTypes.length ; i++ ) System.out.print ( cofTypes [ ] + `` `` ) ; System.out.println ( manAttrs [ 1 ] + `` , `` + manAttrs [ 2 ] ) ; rs2.close ( ) ; pstmt.close ( ) ; } rs.close ( ) ; } catch ( BatchUpdateException b ) { System.err.println ( `` -- -- -BatchUpdateException -- -- - '' ) ; System.err.println ( `` SQLState : `` + b.getSQLState ( ) ) ; System.err.println ( `` Message : `` + b.getMessage ( ) ) ; System.err.println ( `` Vendor : `` + b.getErrorCode ( ) ) ; System.err.print ( `` Update count : `` ) ; int [ ] updateCounts = b.getUpdateCounts ( ) ; ( int = 0 ; < updateCounts.length ; i++ ) { System.err.print ( updateCounts [ ] + `` `` ) ; } System.err.println ( `` '' ) ; } catch ( SQLException ex ) { System.err.println ( `` SQLException : `` + ex.getMessage ( ) ) ; System.err.println ( `` SQLState : `` + ex.getSQLState ( ) ) ; System.err.println ( `` Message : `` + ex.getMessage ( ) ) ; System.err.println ( `` Vendor : `` + ex.getErrorCode ( ) ) ; } finally { ( stmt ! = null ) { stmt.close ( ) ; } JDBCTutorialUtilities.closeConnection ( con ) ; } } } }