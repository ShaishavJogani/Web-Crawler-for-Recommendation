Just non-reflective code , array field may set retrieve entirety component component . To set entire array , use java.lang.reflect.Field.set ( Object obj , Object value ) . To retrieve entire array , use Field.get ( Object ) . Individual component set retrieve use method java.lang.reflect.Array . Array provide method form setFoo ( ) getFoo ( ) set get component primitive type . For example , component int array may set Array.setInt ( Object array , int index , int value ) may retrieve Array.getInt ( Object array , int index ) . These method support automatic widening data type . Therefore , Array.getShort ( ) may use set value int array since 16-bit short may widen 32-bit int without loss data ; hand , invoke Array.setLong ( ) array int cause IllegalArgumentException throw 64-bit long narrow storage 32-bit int loss information . This true regardless whether actual value pass could accurately represent target data type . The Java Language Specification , Java SE 7 Edition , section Widening Primitive Conversion Narrowing Primitive Conversion contain complete discussion widening narrowing conversion . The component array reference type ( include array array ) set retrieve use Array.set ( Object array , int index , int value ) Array.get ( Object array , int index ) . Setting Field Type Array The GrowBufferedReader example illustrate replace value field type array . In case , code replace backing array java.io.BufferedReader large one . ( This assume creation original BufferedReader code modifiable ; otherwise , would trivial simply use alternate constructor BufferedReader ( java.io.Reader , int size ) accept input buffer size . ) import java.io.BufferedReader ; import java.io.CharArrayReader ; import java.io.FileNotFoundException ; import java.io.IOException ; import java.lang.reflect.Field ; import java.util.Arrays ; import static java.lang.System.out ; public class GrowBufferedReader { private static final int srcBufSize = 10 * 1024 ; private static char [ ] src = new char [ srcBufSize ] ; static { src [ srcBufSize - 1 ] = 'x ' ; } private static CharArrayReader car = new CharArrayReader ( src ) ; public static void main ( String ... args ) { try { BufferedReader br = new BufferedReader ( car ) ; Class < ? > c = br.getClass ( ) ; Field f = c.getDeclaredField ( `` cb '' ) ; // cb private field f.setAccessible ( true ) ; char [ ] cbVal = char [ ] .class.cast ( f.get ( br ) ) ; char [ ] newVal = Arrays.copyOf ( cbVal , cbVal.length * 2 ) ; ( args.length > 0 & & args [ 0 ] .equals ( `` grow '' ) ) f.set ( br , newVal ) ; ( int = 0 ; < srcBufSize ; i++ ) br.read ( ) ; // see new backing array use ( newVal [ srcBufSize - 1 ] == src [ srcBufSize - 1 ] ) out.format ( `` Using new back array , size= % % n '' , newVal.length ) ; else out.format ( `` Using original backing array , size= % % n '' , cbVal.length ) ; // production code handle exception gracefully } catch ( FileNotFoundException x ) { x.printStackTrace ( ) ; } catch ( NoSuchFieldException x ) { x.printStackTrace ( ) ; } catch ( IllegalAccessException x ) { x.printStackTrace ( ) ; } catch ( IOException x ) { x.printStackTrace ( ) ; } } } $ java GrowBufferedReader grow Using new back array , size=16384 $ java GrowBufferedReader Using original backing array , size=8192 Note example make use array utility method java.util.Arrays.copyOf ) . java.util.Arrays contain many method convenient operate array . Accessing Elements Multidimensional Array Multi-dimensional array simply nested array . A two-dimensional array array array . A three-dimensional array array two-dimensional array , . The CreateMatrix example illustrate create initialize multi-dimensional array use reflection . import java.lang.reflect.Array ; import static java.lang.System.out ; public class CreateMatrix { public static void main ( String ... args ) { Object matrix = Array.newInstance ( int.class , 2 , 2 ) ; Object row0 = Array.get ( matrix , 0 ) ; Object row1 = Array.get ( matrix , 1 ) ; Array.setInt ( row0 , 0 , 1 ) ; Array.setInt ( row0 , 1 , 2 ) ; Array.setInt ( row1 , 0 , 3 ) ; Array.setInt ( row1 , 1 , 4 ) ; ( int = 0 ; < 2 ; i++ ) ( int j = 0 ; j < 2 ; j++ ) out.format ( `` matrix [ % ] [ % ] = % % n '' , , j , ( ( int [ ] [ ] ) matrix ) [ ] [ j ] ) ; } } $ java CreateMatrix matrix [ 0 ] [ 0 ] = 1 matrix [ 0 ] [ 1 ] = 2 matrix [ 1 ] [ 0 ] = 3 matrix [ 1 ] [ 1 ] = 4 The result could obtain use following code fragment : Object matrix = Array.newInstance ( int.class , 2 ) ; Object row0 = Array.newInstance ( int.class , 2 ) ; Object row1 = Array.newInstance ( int.class , 2 ) ; Array.setInt ( row0 , 0 , 1 ) ; Array.setInt ( row0 , 1 , 2 ) ; Array.setInt ( row1 , 0 , 3 ) ; Array.setInt ( row1 , 1 , 4 ) ; Array.set ( matrix , 0 , row0 ) ; Array.set ( matrix , 1 , row1 ) ; The variable argument Array.newInstance ( Class < ? > componentType , int ... dimension ) provide convenient way create multi-dimensional array , component still need initialize use principle multi-dimensional array nest array . ( Reflection provide multiple indexed get/set method purpose . )