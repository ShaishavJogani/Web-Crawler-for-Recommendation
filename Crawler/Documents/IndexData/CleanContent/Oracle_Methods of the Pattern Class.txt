Until , 've use test harness create Pattern object basic form . This section explore advanced technique create pattern flag use embedded flag expression . It also explore additional useful method n't yet discuss . Creating Pattern Flags The Pattern class define alternate compile method accept set flag affect way pattern match . The flags parameter bit mask may include following public static field : Pattern.CANON_EQ Enables canonical equivalence . When flag specify , two character consider match , , full canonical decomposition match . The expression `` a\u030A '' , example , match string `` \u00E5 '' flag specify . By default , match take canonical equivalence account . Specifying flag may impose performance penalty . Pattern.CASE_INSENSITIVE Enables case-insensitive matching . By default , case-insensitive matching assume character US-ASCII charset match . Unicode-aware case-insensitive matching enable specify UNICODE_CASE flag conjunction flag . Case-insensitive matching also enable via embedded flag expression ( ? ) . Specifying flag may impose slight performance penalty . Pattern.COMMENTS Permits whitespace comment pattern . In mode , whitespace ignore , embed comment start # ignore end line . Comments mode also enable via embedded flag expression ( ? x ) . Pattern.DOTALL Enables dotall mode . In dotall mode , expression . match character , include line terminator . By default expression match line terminator . Dotall mode also enable via embedded flag expression ( ? ) . ( The mnemonic `` single-line '' mode , call Perl . ) Pattern.LITERAL Enables literal parsing pattern . When flag specify input string specify pattern treat sequence literal character . Metacharacters escape sequence input sequence give special meaning . The flag CASE_INSENSITIVE UNICODE_CASE retain impact match use conjunction flag . The flags become superfluous . There embedded flag character enable literal parsing . Pattern.MULTILINE Enables multiline mode . In multiline mode expression ^ $ match , respectively , line terminator end input sequence . By default expression match beginning end entire input sequence . Multiline mode also enable via embedded flag expression ( ? ) . Pattern.UNICODE_CASE Enables Unicode-aware case folding . When flag specify case-insensitive matching , enable CASE_INSENSITIVE flag , manner consistent Unicode Standard . By default , case-insensitive matching assume character US-ASCII charset match . Unicode-aware case folding also enable via embedded flag expression ( ? u ) . Specifying flag may impose performance penalty . Pattern.UNIX_LINES Enables UNIX line mode . In mode , '\n ' line terminator recognize behavior . , ^ , $ . UNIX line mode also enable via embedded flag expression ( ? ) . In following step modify test harness , RegexTestHarness.java create pattern case-insensitive matching . First , modify code invoke alternate version compile : Pattern pattern = Pattern.compile ( console.readLine ( `` % nEnter regex : `` ) , Pattern.CASE_INSENSITIVE ) ; Then compile run test harness get following result : Enter regex : dog Enter input string search : DoGDOg I find text `` DoG '' start index 0 end index 3 . I find text `` DOg '' start index 3 end index 6 . As see , string literal `` dog '' match occurences , regardless case . To compile pattern multiple flag , separate flag include use bitwise OR operator `` | '' . For clarity , following code sample hardcode regular expression instead read Console : pattern = Pattern.compile ( `` [ az ] $ '' , Pattern.MULTILINE | Pattern.UNIX_LINES ) ; You could also specify int variable instead : final int flag = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE ; Pattern pattern = Pattern.compile ( `` aa '' , flag ) ; Embedded Flag Expressions It 's also possible enable various flag use embedded flag expression . Embedded flag expression alternative two-argument version compile , specify regular expression . The following example use original test harness , RegexTestHarness.java embedded flag expression ( ? ) enable case-insensitive matching . Enter regex : ( ? ) foo Enter input string search : FOOfooFoOfoO I find text `` FOO '' start index 0 end index 3 . I find text `` foo '' start index 3 end index 6 . I find text `` FoO '' start index 6 end index 9 . I find text `` foO '' start index 9 end index 12 . Once , match succeed regardless case . The embedded flag expression correspond Pattern 's publicly accessible field present following table : Constant Equivalent Embedded Flag Expression Pattern.CANON_EQ None Pattern.CASE_INSENSITIVE ( ? ) Pattern.COMMENTS ( ? x ) Pattern.MULTILINE ( ? ) Pattern.DOTALL ( ? ) Pattern.LITERAL None Pattern.UNICODE_CASE ( ? u ) Pattern.UNIX_LINES ( ? ) Using match ( String , CharSequence ) Method The Pattern class define convenient match method allow quickly check pattern present give input string . As public static method , invoke match class name , Pattern.matches ( `` \\d '' , '' 1 '' ) ; . In example , method return true , digit `` 1 '' match regular expression \d . Using split ( String ) Method The split method great tool gather text lie either side pattern 's match . As show SplitDemo.java , split method could extract word `` one two three four five '' string `` one : two : three : four : five '' : import java.util.regex.Pattern ; import java.util.regex.Matcher ; public class SplitDemo { private static final String REGEX = `` : '' ; private static final String INPUT = `` one : two : three : four : five '' ; public static void main ( String [ ] args ) { Pattern p = Pattern.compile ( REGEX ) ; String [ ] item = p.split ( INPUT ) ; ( String : item ) { System.out.println ( ) ; } } } OUTPUT : one two three four five For simplicity , 've match string literal , colon ( : ) instead complex regular expression . Since 're still use Pattern Matcher object , use split get text fall either side regular expression . Here 's example , SplitDemo2.java , modify split digit instead : import java.util.regex.Pattern ; import java.util.regex.Matcher ; public class SplitDemo2 { private static final String REGEX = `` \\d '' ; private static final String INPUT = `` one9two4three7four1five '' ; public static void main ( String [ ] args ) { Pattern p = Pattern.compile ( REGEX ) ; String [ ] item = p.split ( INPUT ) ; ( String : item ) { System.out.println ( ) ; } } } OUTPUT : one two three four five Other Utility Methods You may find following method use well : public static String quote ( String ) Returns literal pattern String specified String . This method produce String use create Pattern would match String literal pattern . Metacharacters escape sequence input sequence give special meaning . public String toString ( ) Returns String representation pattern . This regular expression pattern compile . Pattern Method Equivalents java.lang.String Regular expression support also exist java.lang.String several method mimic behavior java.util.regex.Pattern . For convenience , key excerpt API present . public boolean match ( String regex ) : Tells whether string match give regular expression . An invocation method form str.matches ( regex ) yield exactly result expression Pattern.matches ( regex , str ) . public String [ ] split ( String regex , int limit ) : Splits string around match give regular expression . An invocation method form str.split ( regex , n ) yield result expression Pattern.compile ( regex ) .split ( str , n ) public String [ ] split ( String regex ) : Splits string around match give regular expression . This method work invoke two-argument split method give expression limit argument zero . Trailing empty string include resulting array . There also replace method , replace one CharSequence another : public String replace ( CharSequence target , CharSequence replacement ) : Replaces substring string match literal target sequence specified literal replacement sequence . The replacement proceeds beginning string end , example , replace `` aa '' `` b '' string `` aaa '' result `` ba '' rather `` ab '' .