In programming , atomic action one effectively happen . An atomic action stop middle : either happen completely , n't happen . No side effect atomic action visible action complete . We already see increment expression , c++ , describe atomic action . Even simple expression define complex action decompose action . However , action specify atomic : Reads writes atomic reference variable primitive variable ( type except long double ) . Reads writes atomic variable declare volatile ( include long double variable ) . Atomic action interleave , use without fear thread interference . However , eliminate need synchronize atomic action , memory consistency error still possible . Using volatile variable reduce risk memory consistency error , write volatile variable establishes happens-before relationship subsequent read variable . This mean change volatile variable always visible thread . What 's , also mean thread read volatile variable , see late change volatile , also side effect code lead change . Using simple atomic variable access efficient access variable synchronize code , require care programmer avoid memory consistency error . Whether extra effort worthwhile depends size complexity application . Some class java.util.concurrent package provide atomic method rely synchronization . We 'll discuss section High Level Concurrency Objects .