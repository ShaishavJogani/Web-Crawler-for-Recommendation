This page cover following topic : Overview Prepared Statements Creating PreparedStatement Object Supplying Values PreparedStatement Parameters Overview Prepared Statements Sometimes convenient use PreparedStatement object send SQL statement database . This special type statement derive general class , Statement , already know . If want execute Statement object many time , usually reduce execution time use PreparedStatement object instead . The main feature PreparedStatement object , unlike Statement object , give SQL statement create . The advantage case , SQL statement send DBMS right away , compile . As result , PreparedStatement object contain SQL statement , SQL statement precompiled . This mean PreparedStatement execute , DBMS run PreparedStatement SQL statement without compile first . Although PreparedStatement object use SQL statement parameter , probably use often SQL statement take parameter . The advantage use SQL statement take parameter use statement supply different value time execute . Examples following section . The following method , CoffeesTable.updateCoffeeSales , store number pound coffee sell current week SALES column type coffee , update total number pound coffee sell TOTAL column type coffee : public void updateCoffeeSales ( HashMap < String , Integer > salesForWeek ) throw SQLException { PreparedStatement updateSales = null ; PreparedStatement updateTotal = null ; String updateString = `` update `` + dbName + `` .COFFEES `` + `` set SALES = ? COF_NAME = ? `` ; String updateStatement = `` update `` + dbName + `` .COFFEES `` + `` set TOTAL = TOTAL + ? `` + `` COF_NAME = ? `` ; try { con.setAutoCommit ( false ) ; updateSales = con.prepareStatement ( updateString ) ; updateTotal = con.prepareStatement ( updateStatement ) ; ( Map.Entry < String , Integer > e : salesForWeek.entrySet ( ) ) { updateSales.setInt ( 1 , e.getValue ( ) .intValue ( ) ) ; updateSales.setString ( 2 , e.getKey ( ) ) ; updateSales.executeUpdate ( ) ; updateTotal.setInt ( 1 , e.getValue ( ) .intValue ( ) ) ; updateTotal.setString ( 2 , e.getKey ( ) ) ; updateTotal.executeUpdate ( ) ; con.commit ( ) ; } } catch ( SQLException e ) { JDBCTutorialUtilities.printSQLException ( e ) ; ( con ! = null ) { try { System.err.print ( `` Transaction roll back '' ) ; con.rollback ( ) ; } catch ( SQLException excep ) { JDBCTutorialUtilities.printSQLException ( excep ) ; } } } finally { ( updateSales ! = null ) { updateSales.close ( ) ; } ( updateTotal ! = null ) { updateTotal.close ( ) ; } con.setAutoCommit ( true ) ; } } Creating PreparedStatement Object The following create PreparedStatement object take two input parameter : String updateString = `` update `` + dbName + `` .COFFEES `` + `` set SALES = ? COF_NAME = ? `` ; updateSales = con.prepareStatement ( updateString ) ; Supplying Values PreparedStatement Parameters You must supply value place question mark placeholder ( ) execute PreparedStatement object . Do call one setter method define PreparedStatement class . The following statement supply two question mark placeholder PreparedStatement name updateSales : updateSales.setInt ( 1 , e.getValue ( ) .intValue ( ) ) ; updateSales.setString ( 2 , e.getKey ( ) ) ; The first argument setter method specify question mark placeholder . In example , setInt specifies first placeholder setString specifies second placeholder . After parameter set value , retain value reset another value , method clearParameters call . Using PreparedStatement object updateSales , following code fragment illustrate reuse prepared statement reset value one parameter leave one : // change SALES column French Roast //row 100 updateSales.setInt ( 1 , 100 ) ; updateSales.setString ( 2 , `` French_Roast '' ) ; updateSales.executeUpdate ( ) ; // change SALES column Espresso row 100 // ( first parameter stay 100 , second // parameter reset `` Espresso '' ) updateSales.setString ( 2 , `` Espresso '' ) ; updateSales.executeUpdate ( ) ; Using Loops Set Values You often make cod easy use loop loop set value input parameter . The CoffeesTable.updateCoffeeSales method use for-each loop repeatedly set value PreparedStatement object updateSales updateTotal : ( Map.Entry < String , Integer > e : salesForWeek.entrySet ( ) ) { updateSales.setInt ( 1 , e.getValue ( ) .intValue ( ) ) ; updateSales.setString ( 2 , e.getKey ( ) ) ; // ... } The method CoffeesTable.updateCoffeeSales take one argument , HashMap . Each element HashMap argument contain name one type coffee number pound type coffee sell current week . The for-each loop iterates element HashMap argument set appropriate question mark placeholder updateSales updateTotal . Executing PreparedStatement Objects As Statement object , execute PreparedStatement object , call execute statement : executeQuery query return one ResultSet ( SELECT SQL statement ) , executeUpdate query return ResultSet ( UPDATE SQL statement ) , execute query might return one ResultSet object . Both PreparedStatement object CoffeesTable.updateCoffeeSales contain UPDATE SQL statement , execute call executeUpdate : updateSales.setInt ( 1 , e.getValue ( ) .intValue ( ) ) ; updateSales.setString ( 2 , e.getKey ( ) ) ; updateSales.executeUpdate ( ) ; updateTotal.setInt ( 1 , e.getValue ( ) .intValue ( ) ) ; updateTotal.setString ( 2 , e.getKey ( ) ) ; updateTotal.executeUpdate ( ) ; con.commit ( ) ; No argument supply executeUpdate use execute updateSales updateTotals ; PreparedStatement object already contain SQL statement execute . Note : At beginning CoffeesTable.updateCoffeeSales , auto-commit mode set false : con.setAutoCommit ( false ) ; Consequently , SQL statement commit method commit call . For information auto-commit mode , see Transactions . Return Values executeUpdate Method Whereas executeQuery return ResultSet object contain result query send DBMS , return value executeUpdate int value indicate many row table update . For instance , following code show return value executeUpdate assign variable n : updateSales.setInt ( 1 , 50 ) ; updateSales.setString ( 2 , `` Espresso '' ) ; int n = updateSales.executeUpdate ( ) ; // n = 1 one row change The table COFFEES update ; value 50 replace value column SALES row Espresso . That update affect one row table , n equal 1 . When method executeUpdate use execute DDL ( data definition language ) statement , create table , return int value 0 . Consequently , following code fragment , execute DDL statement use create table COFFEES , n assign value 0 : // n = 0 int n = executeUpdate ( createTableCoffees ) ; Note return value executeUpdate 0 , mean one two thing : The statement execute update statement affect zero row . The statement execute DDL statement .