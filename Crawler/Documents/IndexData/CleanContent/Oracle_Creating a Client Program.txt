The compute engine relatively simple program : run task hand . The client compute engine complex . A client need call compute engine , also define task perform compute engine . Two separate class make client example . The first class , ComputePi , look invoke Compute object . The second class , Pi , implement Task interface define work compute engine . The job Pi class compute value number decimal place . The non-remote Task interface define follow : package compute ; public interface Task < T > { T execute ( ) ; } The code invoke Compute object 's method must obtain reference object , create Task object , request task execute . The definition task class Pi show later . A Pi object construct single argument , desired precision result . The result task execution java.math.BigDecimal represent calculate specify precision . Here source code client.ComputePi , main client class : package client ; import java.rmi.registry.LocateRegistry ; import java.rmi.registry.Registry ; import java.math.BigDecimal ; import compute.Compute ; public class ComputePi { public static void main ( String args [ ] ) { ( System.getSecurityManager ( ) == null ) { System.setSecurityManager ( new SecurityManager ( ) ) ; } try { String name = `` Compute '' ; Registry registry = LocateRegistry.getRegistry ( args [ 0 ] ) ; Compute comp = ( Compute ) registry.lookup ( name ) ; Pi task = new Pi ( Integer.parseInt ( args [ 1 ] ) ) ; BigDecimal pi = comp.executeTask ( task ) ; System.out.println ( pi ) ; } catch ( Exception e ) { System.err.println ( `` ComputePi exception : '' ) ; e.printStackTrace ( ) ; } } } Like ComputeEngine server , client begin instal security manager . This step necessary process receive server remote object 's stub could require download class definition server . For RMI download class , security manager must force . After instal security manager , client construct name use look Compute remote object , use name use ComputeEngine bind remote object . Also , client use LocateRegistry.getRegistry API synthesize remote reference registry server 's host . The value first command-line argument , args [ 0 ] , name remote host Compute object run . The client invoke lookup method registry look remote object name server host 's registry . The particular overload LocateRegistry.getRegistry use , single String parameter , return reference registry name host default registry port , 1099 . You must use overload int parameter registry create port 1099 . Next , client create new Pi object , pass Pi constructor value second command-line argument , args [ 1 ] , parse integer . This argument indicate number decimal place use calculation . Finally , client invoke executeTask method Compute remote object . The object pass executeTask invocation return object type BigDecimal , program store variable result . Finally , program print result . The following figure depict flow message among ComputePi client , rmiregistry , ComputeEngine . The Pi class implement Task interface compute value specified number decimal place . For example , actual algorithm unimportant . What important algorithm computationally expensive , mean would want execute capable server . Here source code client.Pi , class implement Task interface : package client ; import compute.Task ; import java.io.Serializable ; import java.math.BigDecimal ; public class Pi implement Task < BigDecimal > , Serializable { private static final long serialVersionUID = 227L ; /** constant use pi computation */ private static final BigDecimal FOUR = BigDecimal.valueOf ( 4 ) ; /** round mode use pi computation */ private static final int roundingMode = BigDecimal.ROUND_HALF_EVEN ; /** digit precision decimal point */ private final int digit ; /** * Construct task calculate pi specify * precision . */ public Pi ( int digit ) { this.digits = digit ; } /** * Calculate pi . */ public BigDecimal execute ( ) { return computePi ( digit ) ; } /** * Compute value pi specified number * digit decimal point . The value * compute use Machin 's formula : * * pi/4 = 4*arctan ( 1/5 ) - arctan ( 1/239 ) * * power series expansion arctan ( x ) * sufficient precision . */ public static BigDecimal computePi ( int digit ) { int scale = digits + 5 ; BigDecimal arctan1_5 = arctan ( 5 , scale ) ; BigDecimal arctan1_239 = arctan ( 239 , scale ) ; BigDecimal pi = arctan1_5.multiply ( FOUR ) .subtract ( arctan1_239 ) .multiply ( FOUR ) ; return pi.setScale ( digit , BigDecimal.ROUND_HALF_UP ) ; } /** * Compute value , radian , arctangent * inverse supplied integer specify * number digit decimal point . The value * compute use power series expansion * arc tangent : * * arctan ( x ) = x - ( x^3 ) /3 + ( x^5 ) /5 - ( x^7 ) /7 + * ( x^9 ) /9 ... */ public static BigDecimal arctan ( int inverseX , int scale ) { BigDecimal result , numer , term ; BigDecimal invX = BigDecimal.valueOf ( inverseX ) ; BigDecimal invX2 = BigDecimal.valueOf ( inverseX * inverseX ) ; numer = BigDecimal.ONE.divide ( invX , scale , roundingMode ) ; result = numer ; int = 1 ; { numer = numer.divide ( invX2 , scale , roundingMode ) ; int denom = 2 * + 1 ; term = numer.divide ( BigDecimal.valueOf ( denom ) , scale , roundingMode ) ; ( ( % 2 ) ! = 0 ) { result = result.subtract ( term ) ; } else { result = result.add ( term ) ; } i++ ; } ( term.compareTo ( BigDecimal.ZERO ) ! = 0 ) ; return result ; } } Note serializable class , whether implement Serializable interface directly indirectly , must declare private static final field name serialVersionUID guarantee serialization compatibility version . If previous version class release , value field long value , similar 227L use Pi , long value use consistently future version . If previous version class release without explicit serialVersionUID declaration , serialization compatibility version important , default implicitly compute value previous version must use value new version 's explicit declaration . The serialver tool run previous version determine default compute value . The interesting feature example Compute implementation object never need Pi class 's definition Pi object pass argument executeTask method . At point , code class load RMI Compute object 's Java virtual machine , execute method invoke , task 's code execute . The result , case Pi task BigDecimal object , hand back call client , use print result computation . The fact supplied Task object compute value Pi irrelevant ComputeEngine object . You could also implement task , example , generate random prime number use probabilistic algorithm . That task would also computationally intensive therefore good candidate pass ComputeEngine , would require different code . This code could also download Task object pass Compute object . In way algorithm computing bring need , code generate random prime number would bring need . The Compute object know object receive implement execute method . The Compute object know , need know , implementation .