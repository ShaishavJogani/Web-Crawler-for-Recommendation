A Map object map key value . A map contain duplicate key : Each key map one value . It model mathematical function abstraction . The Map interface include method basic operation ( put , get , remove , containsKey , containsValue , size , empty ) , bulk operation ( putAll clear ) , collection view ( keySet , entrySet , value ) . The Java platform contain three general-purpose Map implementation : HashMap , TreeMap , LinkedHashMap . Their behavior performance precisely analogous HashSet , TreeSet , LinkedHashSet , describe The Set Interface section . The remainder page discuss Map interface detail . But first , example collect Maps use JDK 8 aggregate operation . Modeling real-world object common task object-oriented programming , reasonable think program might , example , group employee department : // Group employee department Map < Department , List < Employee > > byDept = employees.stream ( ) .collect ( Collectors.groupingBy ( Employee : :getDepartment ) ) ; Or compute sum salary department : // Compute sum salary department Map < Department , Integer > totalByDept = employees.stream ( ) .collect ( Collectors.groupingBy ( Employee : :getDepartment , Collectors.summingInt ( Employee : :getSalary ) ) ) ; Or perhaps group student pass fail grade : // Partition student passing fail Map < Boolean , List < Student > > passingFailing = students.stream ( ) .collect ( Collectors.partitioningBy ( - > s.getGrade ( ) > = PASS_THRESHOLD ) ) ; You could also group people city : // Classify Person object city Map < String , List < Person > > peopleByCity = personStream.collect ( Collectors.groupingBy ( Person : :getCity ) ) ; Or even cascade two collector classify people state city : // Cascade Collectors Map < String , Map < String , List < Person > > > peopleByStateAndCity = personStream.collect ( Collectors.groupingBy ( Person : :getState , Collectors.groupingBy ( Person : :getCity ) ) ) Again , example use new JDK 8 APIs . For in-depth coverage lambda expression aggregate operation see lesson entitle Aggregate Operations . Map Interface Basic Operations The basic operation Map ( put , get , containsKey , containsValue , size , isEmpty ) behave exactly like counterpart Hashtable . The following program generate frequency table word find argument list . The frequency table map word number time occur argument list . import java.util . * ; public class Freq { public static void main ( String [ ] args ) { Map < String , Integer > = new HashMap < String , Integer > ( ) ; // Initialize frequency table command line ( String : args ) { Integer freq = m.get ( ) ; m.put ( , ( freq == null ) ? 1 : freq + 1 ) ; } System.out.println ( m.size ( ) + `` distinct word : '' ) ; System.out.println ( ) ; } } The tricky thing program second argument put statement . That argument conditional expression effect set frequency one word never see one current value word already see . Try run program command : java Freq delegate The program yield following output . 8 distinct word : { to=3 , delegate=1 , be=1 , it=2 , up=1 , if=1 , me=1 , is=2 } Suppose 'd prefer see frequency table alphabetical order . All change implementation type Map HashMap TreeMap . Making four-character change cause program generate following output command line . 8 distinct word : { be=1 , delegate=1 , if=1 , is=2 , it=2 , me=1 , to=3 , up=1 } Similarly , could make program print frequency table order word first appear command line simply change implementation type map LinkedHashMap . Doing result following output . 8 distinct word : { if=1 , it=2 , is=2 , to=3 , be=1 , up=1 , me=1 , delegate=1 } This flexibility provide potent illustration power interface-based framework . Like Setand Listinterfaces , Map strengthen requirement equal hashCode method two Map object compare logical equality without regard implementation type . Two Map instance equal represent key-value mapping . By convention , general-purpose Map implementation provide constructor take Map object initialize new Map contain key-value mapping specified Map . This standard Map conversion constructor entirely analogous standard Collection constructor : It allow caller create Map desired implementation type initially contain mapping another Map , regardless Map 's implementation type . For example , suppose Map , name m. The following one-liner create new HashMap initially contain key-value mapping m. Map < K , V > copy = new HashMap < K , V > ( ) ; Map Interface Bulk Operations The clear operation exactly would think could : It remove mapping Map . The putAll operation Map analogue Collection interface 's addAll operation . In addition obvious use dump one Map another , second , subtle use . Suppose Map use represent collection attribute-value pair ; putAll operation , combination Map conversion constructor , provide neat way implement attribute map creation default value . The following static factory method demonstrate technique . static < K , V > Map < K , V > newAttributeMap ( Map < K , V > default , Map < K , V > override ) { Map < K , V > result = new HashMap < K , V > ( default ) ; result.putAll ( override ) ; return result ; } Collection Views The Collection view method allow Map view Collection three way : keySet — Set key contain Map . value — The Collection value contain Map . This Collection Set , multiple key map value . entrySet — Set key-value pair contain Map . The Map interface provide small nested interface call Map.Entry , type element Set . The Collection view provide mean iterate Map . This example illustrate standard idiom iterate key Map for-each construct : ( KeyType key : m.keySet ( ) ) System.out.println ( key ) ; iterator : // Filter map base // property key . ( Iterator < Type > = m.keySet ( ) .iterator ( ) ; it.hasNext ( ) ; ) ( it.next ( ) .isBogus ( ) ) it.remove ( ) ; The idiom iterate value analogous . Following idiom iterate key-value pair . ( Map.Entry < KeyType , ValType > e : m.entrySet ( ) ) System.out.println ( e.getKey ( ) + `` : `` + e.getValue ( ) ) ; At first , many people worry idiom may slow Map create new Collection instance time Collection view operation call . Rest easy : There 's reason Map always return object time ask give Collection view . This precisely Map implementation java.util . With three Collection view , call Iterator 's remove operation remove associated entry backing Map , assume backing Map support element removal begin . This illustrate precede filtering idiom . With entrySet view , also possible change value associate key call Map.Entry 's setValue method iteration ( , assume Map support value modification begin ) . Note safe way modify Map iteration ; behavior unspecified underlie Map modify way iteration progress . The Collection view support element removal many form — remove , removeAll , retainAll , clear operation , well Iterator.remove operation . ( Yet , assume backing Map support element removal . ) The Collection view support element addition circumstance . It would make sense keySet value view , 's unnecessary entrySet view , backing Map 's put putAll method provide functionality . Fancy Uses Collection Views : Map Algebra When apply Collection view , bulk operation ( containsAll , removeAll , retainAll ) surprisingly potent tool . For starter , suppose want know whether one Map submap another — , whether first Map contain key-value mapping second . The following idiom trick . ( m1.entrySet ( ) .containsAll ( m2.entrySet ( ) ) ) { ... } Along similar line , suppose want know whether two Map object contain mapping key . ( m1.keySet ( ) .equals ( m2.keySet ( ) ) ) { ... } Suppose Map represent collection attribute-value pair , two Sets represent require attribute permissible attribute . ( The permissible attribute include required attribute . ) The following snippet determine whether attribute map conforms constraint print detailed error message n't . static < K , V > boolean validate ( Map < K , V > attrMap , Set < K > requiredAttrs , Set < K > permittedAttrs ) { boolean valid = true ; Set < K > attrs = attrMap.keySet ( ) ; ( ! attrs.containsAll ( requiredAttrs ) ) { Set < K > miss = new HashSet < K > ( requiredAttrs ) ; missing.removeAll ( attrs ) ; System.out.println ( `` Missing attribute : `` + miss ) ; valid = false ; } ( ! permittedAttrs.containsAll ( attrs ) ) { Set < K > illegal = new HashSet < K > ( attrs ) ; illegal.removeAll ( permittedAttrs ) ; System.out.println ( `` Illegal attribute : `` + illegal ) ; valid = false ; } return valid ; } Suppose want know key common two Map object . Set < KeyType > commonKeys = new HashSet < KeyType > ( m1.keySet ( ) ) ; commonKeys.retainAll ( m2.keySet ( ) ) ; A similar idiom get common value . All idiom present thus far nondestructive ; , n't modify backing Map . Here . Suppose want remove key-value pair one Map common another . m1.entrySet ( ) .removeAll ( m2.entrySet ( ) ) ; Suppose want remove one Map key mapping another . m1.keySet ( ) .removeAll ( m2.keySet ( ) ) ; What happen start mix key value bulk operation ? Suppose Map , manager , map employee company employee 's manager . We 'll deliberately vague type key value object . It n't matter , long 're . Now suppose want know `` individual contributor '' ( nonmanagers ) . The following snippet tell exactly want know . Set < Employee > individualContributors = new HashSet < Employee > ( managers.keySet ( ) ) ; individualContributors.removeAll ( managers.values ( ) ) ; Suppose want fire employee report directly manager , Simon . Employee simon = ... ; managers.values ( ) .removeAll ( Collections.singleton ( simon ) ) ; Note idiom make use Collections.singleton , static factory method return immutable Set single , specified element . Once 've , may bunch employee whose manager longer work company ( Simon 's direct-reports manager ) . The following code tell employee manager long work company . Map < Employee , Employee > = new HashMap < Employee , Employee > ( manager ) ; m.values ( ) .removeAll ( managers.keySet ( ) ) ; Set < Employee > slacker = m.keySet ( ) ; This example bit tricky . First , make temporary copy Map , remove temporary copy entry whose ( manager ) value key original Map . Remember original Map entry employee . Thus , remain entry temporary Map comprise entry original Map whose ( manager ) value longer employee . The key temporary copy , , represent precisely employee 're look . There many idiom like one contain section , would impractical tedious list . Once get hang , 's difficult come right one need . Multimaps A multimap like Map map key multiple value . The Java Collections Framework n't include interface multimaps n't use commonly . It 's fairly simple matter use Map whose value List instance multimap . This technique demonstrate next code example , read word list contain one word per line ( lowercase ) print anagram group meet size criterion . An anagram group bunch word , contain exactly letter different order . The program take two argument command line : ( 1 ) name dictionary file ( 2 ) minimum size anagram group print . Anagram group contain word specify minimum print . There standard trick find anagram group : For word dictionary , alphabetize letter word ( , reorder word 's letter alphabetical order ) put entry multimap , map alphabetized word original word . For example , word bad cause entry mapping abd bad put multimap . A moment 's reflection show word give key map form anagram group . It 's simple matter iterate key multimap , print anagram group meet size constraint . The following program straightforward implementation technique . import java.util . * ; import java.io . * ; public class Anagrams { public static void main ( String [ ] args ) { int minGroupSize = Integer.parseInt ( args [ 1 ] ) ; // Read word file put simulated multimap Map < String , List < String > > = new HashMap < String , List < String > > ( ) ; try { Scanner = new Scanner ( new File ( args [ 0 ] ) ) ; ( s.hasNext ( ) ) { String word = s.next ( ) ; String alpha = alphabetize ( word ) ; List < String > l = m.get ( alpha ) ; ( l == null ) m.put ( alpha , l=new ArrayList < String > ( ) ) ; l.add ( word ) ; } } catch ( IOException e ) { System.err.println ( e ) ; System.exit ( 1 ) ; } // Print permutation group size threshold ( List < String > l : m.values ( ) ) ( l.size ( ) > = minGroupSize ) System.out.println ( l.size ( ) + `` : `` + l ) ; } private static String alphabetize ( String ) { char [ ] = s.toCharArray ( ) ; Arrays.sort ( ) ; return new String ( ) ; } } Running program 173,000-word dictionary file minimum anagram group size eight produce following output . 9 : [ estrin , inerts , insert , inters , niter , nitre , sinter , triens , trine ] 8 : [ lapse , leap , pale , peal , plea , salep , sepal , spale ] 8 : [ asper , par , passer , prases , repass , spare , sparse , spear ] 10 : [ least , setal , slate , stale , steal , stela , tael , tale , teal , tesla ] 8 : [ enters , nester , renest , rente , resent , tenser , ternes , treens ] 8 : [ arles , earl , lares , laser , lear , rale , real , seral ] 8 : [ earings , erase , gainer , reagin , regains , regina , sear , seringa ] 8 : [ peri , pier , pry , prise , ripes , speir , spier , spire ] 12 : [ aper , apres , asper , pares , parse , pear , prase , presa , rape , reaps , spare , spear ] 11 : [ alert , alters , artels , estral , laster , ratel , salter , slater , staler , stelar , talers ] 9 : [ caper , crape , escarp , pacer , parsec , recap , scrape , secpar , spacer ] 9 : [ palest , palets , pastel , petal , plate , pleat , septal , staple , tepal ] 9 : [ anestri , antsier , nasty , ratines , retains , retina , retsina , stainer , stearin ] 8 : [ ate , east , eats , eta , sate , seat , seta , teas ] 8 : [ caret , carte , caster , caters , crate , reacts , recast , trace ] Many word seem bit bogus , 's program 's fault ; 're dictionary file . Here 's dictionary file use . It derive Public Domain ENABLE benchmark reference word list .