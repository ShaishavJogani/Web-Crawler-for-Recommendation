The section Aggregate Operations describe following pipeline operation , calculate average age male member collection roster : double average = roster .stream ( ) .filter ( p - > p.getGender ( ) == Person.Sex.MALE ) .mapToInt ( Person : :getAge ) .average ( ) .getAsDouble ( ) ; The JDK contain many terminal operation ( average , sum , min , max , count ) return one value combine content stream . These operation call reduction operation . The JDK also contain reduction operation return collection instead single value . Many reduction operation perform specific task , find average value group element category . However , JDK provide general-purpose reduction operation reduce collect , section describe detail . This section cover following topic : The Stream.reduce Method The Stream.collect Method You find code excerpt describe section example ReductionExamples . The Stream.reduce Method The Stream.reduce method general-purpose reduction operation . Consider following pipeline , calculate sum male member ' age collection roster . It use Stream.sum reduction operation : Integer totalAge = roster .stream ( ) .mapToInt ( Person : :getAge ) .sum ( ) ; Compare following pipeline , use Stream.reduce operation calculate value : Integer totalAgeReduce = roster .stream ( ) .map ( Person : :getAge ) .reduce ( 0 , ( , b ) - > + b ) ; The reduce operation example take two argument : identity : The identity element initial value reduction default result element stream . In example , identity element 0 ; initial value sum age default value member exist collection roster . accumulator : The accumulator function take two parameter : partial result reduction ( example , sum processed integer far ) next element stream ( example , integer ) . It return new partial result . In example , accumulator function lambda expression add two Integer value return Integer value : ( , b ) - > + b The reduce operation always return new value . However , accumulator function also return new value every time process element stream . Suppose want reduce element stream complex object , collection . This might hinder performance application . If reduce operation involve add element collection , every time accumulator function process element , create new collection include element , inefficient . It would efficient update exist collection instead . You Stream.collect method , next section describes . The Stream.collect Method Unlike reduce method , always create new value process element , collect method modifies , mutates , exist value . Consider find average value stream . You require two piece data : total number value sum value . However , like reduce method reduction method , collect method return one value . You create new data type contain member variable keep track total number value sum value , following class , Averager : class Averager implement IntConsumer { private int total = 0 ; private int count = 0 ; public double average ( ) { return count > 0 ? ( ( double ) total ) /count : 0 ; } public void accept ( int ) { total += ; count++ ; } public void combine ( Averager ) { total += other.total ; count += other.count ; } } The following pipeline use Averager class collect method calculate average age male member : Averager averageCollect = roster.stream ( ) .filter ( p - > p.getGender ( ) == Person.Sex.MALE ) .map ( Person : :getAge ) .collect ( Averager : :new , Averager : :accept , Averager : :combine ) ; System.out.println ( `` Average age male member : `` + averageCollect.average ( ) ) ; The collect operation example take three argument : supplier : The supplier factory function ; construct new instance . For collect operation , create instance result container . In example , new instance Averager class . accumulator : The accumulator function incorporate stream element result container . In example , modify Averager result container incrementing count variable one add total member variable value stream element , integer represent age male member . combiner : The combiner function take two result container merges content . In example , modify Averager result container incrementing count variable count member variable Averager instance add total member variable value Averager instance 's total member variable . Note following : The supplier lambda expression ( method reference ) oppose value like identity element reduce operation . The accumulator combiner function return value . You use collect operation parallel stream ; see section Parallelism information . ( If run collect method parallel stream , JDK create new thread whenever combiner function create new object , Averager object example . Consequently , worry synchronization . ) Although JDK provide average operation calculate average value element stream , use collect operation custom class need calculate several value element stream . The collect operation best suit collection . The following example put name male member collection collect operation : List < String > namesOfMaleMembersCollect = roster .stream ( ) .filter ( p - > p.getGender ( ) == Person.Sex.MALE ) .map ( p - > p.getName ( ) ) .collect ( Collectors.toList ( ) ) ; This version collect operation take one parameter type Collector . This class encapsulate function use argument collect operation require three argument ( supplier , accumulator , combiner function ) . The Collectors class contain many useful reduction operation , accumulate element collection summarize element accord various criterion . These reduction operation return instance class Collector , use parameter collect operation . This example use Collectors.toList operation , accumulate stream elements new instance List . As operation Collectors class , toList operator return instance Collector , collection . The following example group member collection roster gender : Map < Person.Sex , List < Person > > byGender = roster .stream ( ) .collect ( Collectors.groupingBy ( Person : :getGender ) ) ; The groupingBy operation return map whose key value result apply lambda expression specify parameter ( call classification function ) . In example , return map contain two key , Person.Sex.MALE Person.Sex.FEMALE . The key ' corresponding value instance List contain stream elements , process classification function , correspond key value . For example , value correspond key Person.Sex.MALE instance List contain male member . The following example retrieve name member collection roster group gender : Map < Person.Sex , List < String > > namesByGender = roster .stream ( ) .collect ( Collectors.groupingBy ( Person : :getGender , Collectors.mapping ( Person : :getName , Collectors.toList ( ) ) ) ) ; The groupingBy operation example take two parameter , classification function instance Collector . The Collector parameter call downstream collector . This collector Java runtime applies result another collector . Consequently , groupingBy operation enable apply collect method List value create groupingBy operator . This example apply collector mapping , apply mapping function Person : :getName element stream . Consequently , result stream consist name member . A pipeline contain one downstream collector , like example , call multilevel reduction . The following example retrieve total age member gender : Map < Person.Sex , Integer > totalAgeByGender = roster .stream ( ) .collect ( Collectors.groupingBy ( Person : :getGender , Collectors.reducing ( 0 , Person : :getAge , Integer : :sum ) ) ) ; The reducing operation take three parameter : identity : Like Stream.reduce operation , identity element initial value reduction default result element stream . In example , identity element 0 ; initial value sum age default value member exist . mapper : The reduce operation applies mapper function stream element . In example , mapper retrieve age member . operation : The operation function use reduce mapped value . In example , operation function add Integer value . The following example retrieve average age member gender : Map < Person.Sex , Double > averageAgeByGender = roster .stream ( ) .collect ( Collectors.groupingBy ( Person : :getGender , Collectors.averagingInt ( Person : :getAge ) ) ) ;