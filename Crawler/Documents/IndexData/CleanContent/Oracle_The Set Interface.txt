A Set Collection contain duplicate element . It model mathematical set abstraction . The Set interface contain method inherit Collection add restriction duplicate element prohibit . Set also add strong contract behavior equal hashCode operation , allow Set instance compare meaningfully even implementation type differ . Two Set instance equal contain element . The Java platform contain three general-purpose Set implementation : HashSet , TreeSet , LinkedHashSet . HashSet , store element hash table , best-performing implementation ; however make guarantee concern order iteration . TreeSet , store element red-black tree , order element base value ; substantially slow HashSet . LinkedHashSet , implement hash table linked list run , order element base order insert set ( insertion-order ) . LinkedHashSet spar client unspecified , generally chaotic order provide HashSet cost slightly high . Here 's simple useful Set idiom . Suppose Collection , c , want create another Collection contain element duplicate eliminate . The following one-liner trick . Collection < Type > noDups = new HashSet < Type > ( c ) ; It work create Set ( , definition , contain duplicate ) , initially contain element c. It use standard conversion constructor describe The Collection Interface section . Or , use JDK 8 later , could easily collect Set use aggregate operation : c.stream ( ) .collect ( Collectors.toSet ( ) ) ; // duplicate Here 's slightly longer example accumulate Collection name TreeSet : Set < String > set = people.stream ( ) .map ( Person : :getName ) .collect ( Collectors.toCollection ( TreeSet : :new ) ) ; And following minor variant first idiom preserve order original collection remove duplicate element : Collection < Type > noDups = new LinkedHashSet < Type > ( c ) ; The following generic method encapsulate precede idiom , return Set generic type one pass . public static < E > Set < E > removeDups ( Collection < E > c ) { return new LinkedHashSet < E > ( c ) ; } Set Interface Basic Operations The size operation return number element Set ( cardinality ) . The isEmpty method exactly think would . The add method add specified element Set already present return boolean indicating whether element add . Similarly , remove method remove specified element Set present return boolean indicating whether element present . The iterator method return Iterator Set . The following program print distinct word argument list . Two version program provide . The first use JDK 8 aggregate operation . The second use for-each construct . Using JDK 8 Aggregate Operations : import java.util . * ; import java.util.stream . * ; public class FindDups { public static void main ( String [ ] args ) { Set < String > distinctWords = Arrays.asList ( args ) .stream ( ) .collect ( Collectors.toSet ( ) ) ; System.out.println ( distinctWords.size ( ) + `` distinct word : `` + distinctWords ) ; } } Using for-each Construct : import java.util . * ; public class FindDups { public static void main ( String [ ] args ) { Set < String > = new HashSet < String > ( ) ; ( String : args ) s.add ( ) ; System.out.println ( s.size ( ) + `` distinct word : `` + ) ; } } Now run either version program . java FindDups come saw leave The following output produce : 4 distinct word : [ leave , come , saw , ] Note code always refers Collection interface type ( Set ) rather implementation type . This strongly recommended programming practice give flexibility change implementation merely change constructor . If either variable use store collection parameter use pass around declare Collection 's implementation type rather interface type , variable parameter must change order change implementation type . Furthermore , 's guarantee result program work . If program use nonstandard operation present original implementation type new one , program fail . Referring collection interface prevents use nonstandard operation . The implementation type Set preceding example HashSet , make guarantee order element Set . If want program print word list alphabetical order , merely change Set 's implementation type HashSet TreeSet . Making trivial one-line change cause command line previous example generate following output . java FindDups come saw leave 4 distinct word : [ come , , leave , saw ] Set Interface Bulk Operations Bulk operation particularly well suit Sets ; apply , perform standard set-algebraic operation . Suppose s1 s2 set . Here 's bulk operation : s1.containsAll ( s2 ) — return true s2 subset s1 . ( s2 subset s1 set s1 contain element s2 . ) s1.addAll ( s2 ) — transforms s1 union s1 s2 . ( The union two set set contain element contain either set . ) s1.retainAll ( s2 ) — transforms s1 intersection s1 s2 . ( The intersection two set set contain element common set . ) s1.removeAll ( s2 ) — transforms s1 ( asymmetric ) set difference s1 s2 . ( For example , set difference s1 minus s2 set contain element find s1 s2 . ) To calculate union , intersection , set difference two set nondestructively ( without modify either set ) , caller must copy one set call appropriate bulk operation . The following result idiom . Set < Type > union = new HashSet < Type > ( s1 ) ; union.addAll ( s2 ) ; Set < Type > intersection = new HashSet < Type > ( s1 ) ; intersection.retainAll ( s2 ) ; Set < Type > difference = new HashSet < Type > ( s1 ) ; difference.removeAll ( s2 ) ; The implementation type result Set preceding idiom HashSet , , already mention , best all-around Set implementation Java platform . However , general-purpose Set implementation could substitute . Let 's revisit FindDups program . Suppose want know word argument list occur occur , want duplicate print repeatedly . This effect achieve generate two set — one containing every word argument list contain duplicate . The word occur set difference two set , know compute . Here 's result program look . import java.util . * ; public class FindDups2 { public static void main ( String [ ] args ) { Set < String > uniques = new HashSet < String > ( ) ; Set < String > dups = new HashSet < String > ( ) ; ( String : args ) ( ! uniques.add ( ) ) dups.add ( ) ; // Destructive set-difference uniques.removeAll ( dups ) ; System.out.println ( `` Unique word : `` + uniques ) ; System.out.println ( `` Duplicate word : `` + dups ) ; } } When run argument list use earlier ( come saw leave ) , program yield following output . Unique word : [ leave , saw , come ] Duplicate word : [ ] A less common set-algebraic operation symmetric set difference — set element contain either two specified set . The following code calculate symmetric set difference two set nondestructively . Set < Type > symmetricDiff = new HashSet < Type > ( s1 ) ; symmetricDiff.addAll ( s2 ) ; Set < Type > tmp = new HashSet < Type > ( s1 ) ; tmp.retainAll ( s2 ) ; symmetricDiff.removeAll ( tmp ) ; Set Interface Array Operations The array operation n't anything special Sets beyond Collection . These operation describe The Collection Interface section .