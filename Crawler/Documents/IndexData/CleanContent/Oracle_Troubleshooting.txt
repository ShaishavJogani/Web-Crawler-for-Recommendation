The following example show problem may encounter use enumerate type . IllegalArgumentException When Attempting Instantiate Enum Type As mention , instantiation enum type forbidden . The EnumTrouble example attempt . import java.lang.reflect.Constructor ; import java.lang.reflect.InvocationTargetException ; import static java.lang.System.out ; enum Charge { POSITIVE , NEGATIVE , NEUTRAL ; Charge ( ) { out.format ( `` construction % n '' ) ; } } public class EnumTrouble { public static void main ( String ... args ) { try { Class < ? > c = Charge.class ; Constructor [ ] ctors = c.getDeclaredConstructors ( ) ; ( Constructor ctor : ctors ) { out.format ( `` Constructor : % % n '' , ctor.toGenericString ( ) ) ; ctor.setAccessible ( true ) ; ctor.newInstance ( ) ; } // production code handle exception gracefully } catch ( InstantiationException x ) { x.printStackTrace ( ) ; } catch ( IllegalAccessException x ) { x.printStackTrace ( ) ; } catch ( InvocationTargetException x ) { x.printStackTrace ( ) ; } } } $ java EnumTrouble Constructor : private Charge ( ) Exception thread `` main '' java.lang.IllegalArgumentException : Can reflectively create enum object java.lang.reflect.Constructor.newInstance ( Constructor.java:511 ) EnumTrouble.main ( EnumTrouble.java:22 ) Tip : It compile-time error attempt explicitly instantiate enum would prevent defined enum constant unique . This restriction also enforce reflective code . Code attempt instantiate class use default constructor invoke Class.isEnum ( ) first determine class enum . IllegalArgumentException Setting Field Incompatible Enum Type Fields store enums set appropriate enum type . ( Actually , field type must set compatible type . ) The EnumTroubleToo example produce expected error . import java.lang.reflect.Field ; enum E0 { A , B } enum E1 { A , B } class ETest { private E0 fld = E0.A ; } public class EnumTroubleToo { public static void main ( String ... args ) { try { ETest test = new ETest ( ) ; Field f = test.getClass ( ) .getDeclaredField ( `` fld '' ) ; f.setAccessible ( true ) ; f.set ( test , E1.A ) ; // IllegalArgumentException // production code handle exception gracefully } catch ( NoSuchFieldException x ) { x.printStackTrace ( ) ; } catch ( IllegalAccessException x ) { x.printStackTrace ( ) ; } } } $ java EnumTroubleToo Exception thread `` main '' java.lang.IllegalArgumentException : Can set E0 field ETest.fld E1 sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException ( UnsafeFieldAccessorImpl.java:146 ) sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException ( UnsafeFieldAccessorImpl.java:150 ) sun.reflect.UnsafeObjectFieldAccessorImpl.set ( UnsafeObjectFieldAccessorImpl.java:63 ) java.lang.reflect.Field.set ( Field.java:657 ) EnumTroubleToo.main ( EnumTroubleToo.java:16 ) Tip : Strictly speak , attempt set field type X value type Y succeed following statement hold : X.class.isAssignableFrom ( Y.class ) == true The code could modify perform following test verify whether type compatible : ( f.getType ( ) .isAssignableFrom ( E0.class ) ) // compatible else // expect IllegalArgumentException