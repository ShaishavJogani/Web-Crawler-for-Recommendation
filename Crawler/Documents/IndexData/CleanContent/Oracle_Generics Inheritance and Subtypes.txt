As already know , possible assign object one type object another type provide type compatible . For example , assign Integer Object , since Object one Integer 's supertypes : Object someObject = new Object ( ) ; Integer someInteger = new Integer ( 10 ) ; someObject = someInteger ; // OK In object-oriented terminology , call `` '' relationship . Since Integer kind Object , assignment allow . But Integer also kind Number , following code valid well : public void someMethod ( Number n ) { /* ... */ } someMethod ( new Integer ( 10 ) ) ; // OK someMethod ( new Double ( 10.1 ) ) ; // OK The also true generic . You perform generic type invocation , pass Number type argument , subsequent invocation add allow argument compatible Number : Box < Number > box = new Box < Number > ( ) ; box.add ( new Integer ( 10 ) ) ; // OK box.add ( new Double ( 10.1 ) ) ; // OK Now consider following method : public void boxTest ( Box < Number > n ) { /* ... */ } What type argument accept ? By look signature , see accept single argument whose type Box < Number > . But mean ? Are allow pass Box < Integer > Box < Double > , might expect ? The answer `` '' , Box < Integer > Box < Double > subtypes Box < Number > . This common misunderstanding come program generic , important concept learn . Box < Integer > subtype Box < Number > even though Integer subtype Number . Note : Given two concrete type A B ( example , Number Integer ) , MyClass < A > relationship MyClass < B > , regardless whether A B relate . The common parent MyClass < A > MyClass < B > Object . For information create subtype-like relationship two generic class type parameter relate , see Wildcards Subtyping . Generic Classes Subtyping You subtype generic class interface extend implement . The relationship type parameter one class interface type parameter another determine extends implement clause . Using Collections class example , ArrayList < E > implement List < E > , List < E > extend Collection < E > . So ArrayList < String > subtype List < String > , subtype Collection < String > . So long vary type argument , subtyping relationship preserve type . A sample Collections hierarchy Now imagine want define list interface , PayloadList , associate optional value generic type P element . Its declaration might look like : interface PayloadList < E , P > extend List < E > { void setPayload ( int index , P val ) ; ... } The following parameterizations PayloadList subtypes List < String > : PayloadList < String , String > PayloadList < String , Integer > PayloadList < String , Exception > A sample PayloadList hierarchy