This section use XSLT convert arbitrary data structure XML . Here outline process : Modify exist program read data , make generate SAX event . ( Whether program real parser simply data filter kind irrelevant moment ) . Use SAX `` parser '' construct SAXSource transformation . Use StreamResult object create last exercise display result . ( But note could easily create DOMResult object create DOM memory ) . Wire source result use transformer object make conversion . For starter , need data set want convert program capable read data . The next two section create simple data file program read . Creating Simple File This example use data set address book , PersonalAddressBook.ldif . If already , download XSLT example unzip install-dir/jaxp-1_4_2-release-date/samples directory . The file show produce create new address book Netscape Messenger , give dummy data ( one address card ) , export LDAP Data Interchange Format ( LDIF ) format . It contain directory xslt/data unzip XSLT example . The following Figure show address book entry create . Figure Address Book Entry Exporting address book produce file like one show next . The part file care show bold . dn : cn=Fred Flintstone , mail=fred @ barneys.house modifytimestamp : 20010409210816Z cn : Fred Flintstone xmozillanickname : Fred mail : Fred @ barneys.house xmozillausehtmlmail : TRUE givenname : Fred sn : Flintstone telephonenumber : 999-Quarry homephone : 999-BedrockLane facsimiletelephonenumber : 888-Squawk pagerphone : 777-pager cellphone : 555-cell xmozillaanyphone : 999-Quarry objectclass : top objectclass : person Note line file contain variable name , colon , space follow value variable . The sn variable contain person 's surname ( last name ) variable cn contain DisplayName field address book entry . Creating Simple Parser The next step create program parse data . Note - The code discuss section AddressBookReader01.java , find xslt directory unzip XSLT example install-dir/jaxp-1_4_2-release-date/samples directory . The text program show next . It extremely simple program even loop multiple entry , , demo . import java.io . * ; public class AddressBookReader01 { public static void main ( String argv [ ] ) { // Check argument ( argv.length ! = 1 ) { System.err.println ( `` Usage : java AddressBookReader01 filename '' ) ; System.exit ( 1 ) ; } String filename = argv [ 0 ] ; File f = new File ( filename ) ; AddressBookReader01 reader = new AddressBookReader01 ( ) ; reader.parse ( f ) ; } // Parse input file public void parse ( File f ) { try { // Get efficient reader file FileReader r = new FileReader ( f ) ; BufferedReader br = new BufferedReader ( r ) ; // Read file display content . String line = br.readLine ( ) ; ( null ! = ( line = br.readLine ( ) ) ) { ( line.startsWith ( `` xmozillanickname : `` ) ) break ; } output ( `` nickname '' , `` xmozillanickname '' , line ) ; line = br.readLine ( ) ; output ( `` email '' , `` mail '' , line ) ; line = br.readLine ( ) ; output ( `` html '' , `` xmozillausehtmlmail '' , line ) ; line = br.readLine ( ) ; output ( `` firstname '' , '' givenname '' , line ) ; line = br.readLine ( ) ; output ( `` lastname '' , `` sn '' , line ) ; line = br.readLine ( ) ; output ( `` work '' , `` telephonenumber '' , line ) ; line = br.readLine ( ) ; output ( `` home '' , `` homephone '' , line ) ; line = br.readLine ( ) ; output ( `` fax '' , `` facsimiletelephonenumber '' , line ) ; line = br.readLine ( ) ; output ( `` pager '' , `` pagerphone '' , line ) ; line = br.readLine ( ) ; output ( `` cell '' , `` cellphone '' , line ) ; } catch ( Exception e ) { e.printStackTrace ( ) ; } } } This program contain three method : main The main method get name file command line , create instance parser , set work parse file . This method disappear convert program SAX parser . ( That one reason put parsing code separate method ) . parse This method operate File object send main routine . As see , straightforward . The concession efficiency use BufferedReader , become important start operate large file . output The output method contain logic structure line . It take three argument . The first argument give method name display , output html variable name , instead xmozillausehtmlmail . The second argument give variable name store file ( xmozillausehtmlmail ) . The third argument give line contain data . The routine strip variable name start line output desired name , plus data . Running AddressBookReader01 Sample Navigate sample directory . % cd install-dir/jaxp-1_4_2-release-date/samples . Download XSLT example click link unzip install-dir/jaxp-1_4_2-release-date/samples directory . Navigate xslt directory . cd xslt Compile AddressBookReader01 sample . Type following command : % javac AddressBookReader01.java Run AddressBookReader01 sample data file . In case , AddressBookReader01 run file PersonalAddressBook.ldif show , find xslt/data directory unzip sample bundle . % java AddressBookReader01 data/PersonalAddressBook.ldif You see following output : nickname : Fred email : Fred @ barneys.house html : TRUE firstname : Fred lastname : Flintstone work : 999-Quarry home : 999-BedrockLane fax : 888-Squawk pager : 777-pager cell : 555-cell This bit readable file show Creating Simple File . Creating Parser Generates SAX Events This section show make parser generate SAX event , use basis SAXSource object XSLT transform . Note - The code discuss section AddressBookReader02.java , find xslt directory unzip XSLT example install-dir/jaxp-1_4_2-release-date/samples directory . AddressBookReader02.java adapt AddressBookReader01.java , difference code two example discuss . AddressBookReader02 require following highlighted class use AddressBookReader01 . import java.io . * ; import org.xml.sax . * ; import org.xml.sax.helpers.AttributesImpl ; The application also extend XmlReader . This change convert application parser generate appropriate SAX event . public class AddressBookReader02 implement XMLReader { /* ... */ } Unlike AddressBookReader01 sample , application main method . The follow global variable use later section : public class AddressBookReader02 implement XMLReader { ContentHandler handler ; String nsu = `` '' ; Attributes atts = new AttributesImpl ( ) ; String rootElement = `` addressbook '' ; String indent = `` \n `` ; // ... } The SAX ContentHandler object get SAX event generate parser . To make application XmlReader , application define setContentHandler method . The handler variable hold reference object send setContentHandler invoke . When parser generate SAX element event , need supply namespace attribute information . Because simple application , define null value . The application also define root element data structure ( addressbook ) set indent string improve readability output . Furthermore , parse method modify take InputSource ( rather File ) argument account exception generate : public void parse ( InputSource input ) throw IOException , SAXException Now , rather create new FileReader instance AddressBookReader01 , reader encapsulate InputSource object : try { java.io.Reader r = input.getCharacterStream ( ) ; BufferedReader Br = new BufferedReader ( r ) ; // ... } Note - The next section show create input source object put , fact , buffered reader . But AddressBookReader could use someone else , somewhere line . This step make sure processing efficient , regardless reader give . The next step modify parse method generate SAX event start document root element . The following highlighted code : public void parse ( InputSource input ) { try { // ... String line = br.readLine ( ) ; ( null ! = ( line = br.readLine ( ) ) ) { ( line.startsWith ( `` xmozillanickname : `` ) ) break ; } ( handler == null ) { throw new SAXException ( `` No content handler '' ) ; } handler.startDocument ( ) ; handler.startElement ( nsu , rootElement , rootElement , atts ) ; output ( `` nickname '' , `` xmozillanickname '' , line ) ; // ... output ( `` cell '' , `` cellphone '' , line ) ; handler.ignorableWhitespace ( `` \n '' .toCharArray ( ) , 0 , // start index 1 // length ) ; handler.endElement ( nsu , rootElement , rootElement ) ; handler.endDocument ( ) ; } catch ( Exception e ) { // ... } } Here , application check make sure parser properly configure ContentHandler . ( For application , care anything else ) . It generate event start document root element , finish send end event root element end event document . Two item noteworthy point : The setDocumentLocator event send , optional . Were important , event would send immediately startDocument event . An ignorableWhitespace event generate end root element . This , , optional , drastically improve readability output , see shortly . ( In case , whitespace consist single newline , send way character send character method : character array , start index , length ) . Now SAX event generate document root element , next step modify output method generate appropriate element event data item . Removing call System.out.println ( name + `` : `` + text ) add follow highlight code achieves : void output ( String name , String prefix , String line ) throw SAXException { int startIndex = prefix.length ( ) + 2 ; // 2=length `` : `` String text = line.substring ( startIndex ) ; int textLength = line.length ( ) - startIndex ; handler.ignorableWhitespace ( indent.toCharArray ( ) , 0 , // start index indent.length ( ) ) ; handler.startElement ( nsu , name , name /* '' qName '' */ , atts ) ; handler.characters ( line.toCharArray ( ) , startIndex , textLength ; ) ; handler.endElement ( nsu , name , name ) ; } Because ContentHandler method send SAXExceptions back parser , parser must prepare deal . In case , none expect , application simply allow fail occur . The length data calculate , generate ignorable whitespace readability . In case , one level data , use fixed-indent string . ( If data structured , would calculate much space indent , depend nesting data ) . Note - The indent string make difference data make output lot easy read . Without string , element would concatenate end end : < addressbook > < nickname > Fred < /nickname > < email > ... Next , following method configure parser ContentHandler receive event generate : void output ( String name , String prefix , String line ) throw SAXException { // ... } // Allow application register content event handler . public void setContentHandler ( ContentHandler handler ) { this.handler = handler ; } // Return current content handler . public ContentHandler getContentHandler ( ) { return this.handler ; } Several method must implement order satisfy XmlReader interface . For purpose exercise , null method generate . A production application , however , would require error handler method implement produce robust application . For example , though , following code generate null method : // Allow application register error event handler . public void setErrorHandler ( ErrorHandler handler ) { } // Return current error handler . public ErrorHandler getErrorHandler ( ) { return null ; } Then follow code generates null method remainder XmlReader interface . ( Most value real SAX parser little bearing data-conversion application like one ) . // Parse XML document system identifier ( URI ) . public void parse ( String systemId ) throw IOException , SAXException { } // Return current DTD handler . public DTDHandler getDTDHandler ( ) { return null ; } // Return current entity resolver . public EntityResolver getEntityResolver ( ) { return null ; } // Allow application register entity resolver . public void setEntityResolver ( EntityResolver resolver ) { } // Allow application register DTD event handler . public void setDTDHandler ( DTDHandler handler ) { } // Look value property . public Object getProperty ( String name ) { return null ; } // Set value property . public void setProperty ( String name , Object value ) { } // Set state feature . public void setFeature ( String name , boolean value ) { } // Look value feature . public boolean getFeature ( String name ) { return false ; } You parser use generate SAX event . In next section , use construct SAX source object let transform data XML . Using Parser SAXSource Given SAX parser use event source , construct transformer produce result . In section , TransformerApp update produce stream output result , although could easily produce DOM result . Note - Note : The code discuss section TransformationApp03.java , find xslt directory unzip XSLT example install-dir/jaxp-1_4_2-release-date/samples directory . To start , TransformationApp03 differs TransformationApp02 class need import construct SAXSource object . These class show highlighted . The DOM class longer need point , discard , although leave harm . import org.xml.sax.SAXException ; import org.xml.sax.SAXParseException ; import org.xml.sax.ContentHandler ; import org.xml.sax.InputSource ; import javax.xml.transform.sax.SAXSource ; import javax.xml.transform.stream.StreamResult ; Next , instead create DOM DocumentBuilderFactory instance , application create SAX parser , instance AddressBookReader : public class TransformationApp03 { static Document document ; public static void main ( String argv [ ] ) { // ... // Create sax `` parser '' . AddressBookReader saxReader = new AddressBookReader ( ) ; try { File f = new File ( argv [ 0 ] ) ; // ... } // ... } } Then , follow highlight code construct SAXSource object // Use Transformer output // ... Transformer transformer = tFactory.newTransformer ( ) ; // Use parser SAX source input FileReader fr = new FileReader ( f ) ; BufferedReader br = new BufferedReader ( fr ) ; InputSource inputSource = new InputSource ( br ) ; SAXSource source = new SAXSource ( saxReader , inputSource ) ; StreamResult result = new StreamResult ( System.out ) ; transformer.transform ( source , result ) ; Here , TransformationApp03 construct buffered reader ( mention earlier ) encapsulate input source object . It create SAXSource object , pass reader InputSource object , pass transformer . When application run , transformer configure ContentHandler SAX parser ( AddressBookReader ) tell parser operate inputSource object . Events generate parser go transformer , appropriate thing pass data result object . Finally , TransformationApp03 generate exception , exception handle code see TransformationApp02 longer present . Running TransformationApp03 Sample Navigate sample directory . % cd install-dir/jaxp-1_4_2-release-date/samples . Download XSLT example click link unzip install-dir/jaxp-1_4_2-release-date/samples directory . Navigate xslt directory . cd xslt Compile TransformationApp03 sample . Type following command : % javac TransformationApp03.java Run TransformationApp03 sample data file wish convert XML . In case , TransformationApp03 run PersonalAddressBook.ldif file , find xslt/data directory unzip sample bundle . % java TransformationApp03 data/PersonalAddressBook.ldif You see following output : < ? xml version= '' 1.0 '' encoding= '' UTF-8 '' ? > < addressbook > < nickname > Fred < /nickname > < email > Fred @ barneys.house < /email > < html > TRUE < /html > < firstname > Fred < /firstname > < lastname > Flintstone < /lastname > < work > 999-Quarry < /work > < home > 999-BedrockLane < /home > < fax > 888-Squawk < /fax > < pager > 777-pager < /pager > < cell > 555-cell < /cell > < /addressbook > As see , LDIF format file PersonalAddressBook convert XML !