The following section describe several example build concept demonstrate Basic example . The goal section illustrate customize JAXB binding use custom binding declaration , make one follow two way : As annotation make inline XML schema As statement external file pass JAXB bind compiler Unlike example Basic JAXB Examples , focus Java code respective Main.java class file , example focus customizations make XML schema generate schema-derived Java binding class . Note : JAXB bind customizations currently must make hand . One goal JAXB technology standardize format bind declaration , thereby make possible create customization tool provide standard interchange format JAXB implementation . This section introduce customizations make JAXB binding validation method . For information , see JAXB Specification . Why Customize ? In case , default binding generate JAXB binding compiler sufficient . There case , however , might want modify default binding . Some include : Creating API documentation schema-derived JAXB package , class , method constant : By add custom Javadoc tool annotation schema , explain concept , guideline , rule specific implementation . Providing semantically meaningful customized name case default XML name-to-Java identifier mapping handle automatically ; example : To resolve name collision ( describe Appendix D.2.1 JAXB Specification ) . Note JAXB bind compiler detects report name conflict . To provide name typesafe enumeration constant valid Java identifier ; example , enumeration integer value . To provide good name Java representation unnamed model group bind Java property class . To provide meaningful package name derive default target namespace URI . Overriding default binding ; example : Specify model group must bind class rather list . Specify fixed attribute bind Java constant . Override specify default binding XML Schema built-in data type Java data type . In case , might want introduce alternative Java class represent additional characteristic built-in XML Schema data type . Customization Overview This section explain core JAXB customization concept : Inline external customizations Scope , inheritance , precedence Customization syntax Customization namespace prefix Inline External Customizations Customizations default JAXB binding make form bind declaration pass JAXB binding compiler . These bind declaration make either two way : As inline annotation source XML schema As declaration external binding customizations file For , use inline customizations easy see customizations context schema apply . Conversely , use external binding customization file enable customize JAXB binding without modify source schema , enable easily apply customizations several schema file . Note : You combine two type customizations . For example , could include reference external binding customizations file inline annotation . However , declare inline external customization schema element . Each type customization describe detail following section : Inline Customizations Customizations JAXB binding make mean inline bind declaration XML schema file take form < xsd : appinfo > element embed schema < xsd : annotation > element ( xsd : XML schema namespace prefix , define W3C XML Schema Part 1 : Structures ) . The general form inline customizations show following example : < x : annotation > < x : appinfo > < ! -- ... binding declaration . ... -- > < /xs : appinfo > < /xs : annotation > Customizations apply location declare schema . For example , declaration level particular element applies element . Note XML schema namespace prefix must use < annotation > < appinfo > declaration tag . In previous example , x : use namespace prefix , declaration tag < x : annotation > < x : appinfo > . External Binding Customization Files Customizations JAXB binding make use external file contain binding declaration , take general form show following example : < jxb : binding schemaLocation = `` x : anyURI '' > < jxb : binding node = `` x : string '' > * < ! -- bind declaration -- > < jxb : binding > < /jxb : binding > schemaLocation URI reference remote schema . node XPath 1.0 expression identify schema node within schemaLocation give binding declaration associate . For example , first schemaLocation/node declaration JAXB binding declaration file specify schema name root schema node : < jxb : binding schemaLocation= '' po.xsd '' node= '' /xs : schema '' > < /jxb : binding > A subsequent schemaLocation/node declaration , simpleType element name ZipCodeType previous schema example , take following form : < jxb : binding node= '' //xs : simpleType [ @ name= ’ ZipCodeType ’ ] '' > Binding Customization File Format Binding customization file must ASCII text . The name extension matter ; although typical extension , use chapter , .xjb . Passing Customization Files JAXB Binding Compiler Customization file contain bind declaration pass JAXB Binding compiler , xjc , use following syntax : xjc -b file schema file name bind customization file , schema name schema want pass binding compiler . You single binding file contain customizations multiple schema , seperate customizations multiple binding file ; example : xjc schema1.xsd schema2.xsd schema3.xsd \ -b bindings123.xjb xjc schema1.xsd schema2.xsd schema3.xsd \ -b bindings1.xjb \ -b bindings2.xjb \ -b bindings3.xjb Note ordering schema file bind file command-line matter ; although bind customization file must precede -b switch command line . For information xjc compiler option general , see JAXB Compiler Options . Restrictions External Binding Customizations There several rule apply bind declaration make external binding customization file apply similar declaration make inline source schema : The bind customization file must begin jxb : binding version attribute , plus attribute JAXB XMLSchema namespaces : < jxb : binding version= '' 1.0 '' xmlns : jxb= '' http : //java.sun.com/xml/ns/jaxb '' xmlns : xs= '' http : //www.w3.org/2001/XMLSchema '' > The remote schema binding declaration applies must identify explicitly XPath notation use jxb : binding declaration specify schemaLocation node attribute : schemaLocation specify URI reference remote schema . node specifies XPath 1.0 expression identify schema node within schemaLocation give binding declaration associate ; case initial jxb : binding declaration binding customization file , node typically `` /xs : schema '' . Similarly , individual node within schema customizations apply must specify use XPath notation ; example : < jxb : binding node= '' //xs : complexType [ @ name= ’ USAddress ’ ] '' > In case , customization apply node bind compiler declaration embed inline node ’ < x : appinfo > element . To summarize rule , external binding element < jxb : binding > recognize processing JAXB bind compiler three case : When parent < x : appinfo > element . When ancestor another < jxb : binding > element . When root element document . An XML document < jxb : binding > element root refer external binding declaration file . Scope , Inheritance , Precedence Default JAXB binding customize override four different level , scope . The following figure illustrate inheritance precedence customization declaration . Specifically , declaration towards top pyramid inherit supersede declaration . Component declaration inherit supersede Definition declaration ; Definition declaration inherit supersede Schema declaration ; Schema declaration inherit supersede Global declaration . Figure : Customization Scope Inheritance Precedence Customization Syntax The syntax four type JAXB bind declaration , syntax XML-to-Java data type binding declaration , customization namespace prefix describe following section . Global Binding Declarations Schema Binding Declarations Class Binding Declarations Property Binding Declarations javaType Binding Declarations Typesafe Enumeration Binding Declarations javadoc Binding Declarations Global Binding Declarations Global scope customizations declare < globalBindings > . The syntax global scope customizations follow : < globalBindings > [ collectionType = `` collectionType '' ] [ fixedAttributeAsConstantProperty = `` true '' | `` false '' | `` 1 '' | `` 0 '' ] [ generateIsSetMethod = `` true '' | `` false '' | `` 1 '' | `` 0 '' ] [ enableFailFastCheck = `` true '' | `` false '' | `` 1 '' | `` 0 '' ] [ choiceContentProperty = `` true '' | `` false '' | `` 1 '' | `` 0 '' ] [ underscoreBinding = `` asWordSeparator '' | `` asCharInWord '' ] [ typesafeEnumBase = `` typesafeEnumBase '' ] [ typesafeEnumMemberName = `` generateName '' | `` generateError '' ] [ enableJavaNamingConventions = `` true '' | `` false '' | `` 1 '' | `` 0 '' ] [ bindingStyle = `` elementBinding '' | `` modelGroupBinding '' ] [ < javaType > ... < /javaType > ] * < /globalBindings > collectionType either index fully qualified class name implement java.util.List . fixedAttributeAsConstantProperty either true , false , 1 , 0 . The default value false . generateIsSetMethod either true , false , 1 , 0 . The default value false . enableFailFastCheck either true , false , 1 , 0 . If enableFailFastCheck true 1 JAXB implementation support optional checking , type constraint checking perform set property . The default value false . Please note JAXB implementation support failfast validation . choiceContentProperty either true , false , 1 , 0 . The default value false . choiceContentProperty relevant bindingStyle elementBinding . Therefore , bindingStyle specify elementBinding , choiceContentProperty must result invalid customization . underscoreBinding either asWordSeparator asCharInWord . The default value asWordSeparator . typesafeEnumBase list QNames , must resolve simple type definition . The default value xs : NCName . See Typesafe Enumeration Binding Declarations information localized mapping simpleType definition Java typesafe enum class . typesafeEnumMemberName either generateError generateName . The default value generateError . enableJavaNamingConventions either true , false , 1 , 0 . The default value true . bindingStyle either elementBinding , modelGroupBinding . The default value elementBinding . < javaType > zero javaType binding declaration . For information , see javaType Binding Declarations . < globalBindings > declaration valid annotation element top-level schema element . There single instance < globalBindings > declaration give schema binding declaration file . If one source schema include import second source schema , < globalBindings > declaration must declare first source schema . Schema Binding Declarations Schema scope customizations declare < schemaBindings > . The syntax schema scope customizations : < schemaBindings > [ < package > package < /package > ] [ < nameXmlTransform > ... < /nameXmlTransform > ] * < /schemaBindings > < package [ name = `` packageName '' ] [ < javadoc > ... < /javadoc > ] < /package > < nameXmlTransform > [ < typeName [ suffix= '' suffix '' ] [ prefix= '' prefix '' ] / > ] [ < elementName [ suffix= '' suffix '' ] [ prefix= '' prefix '' ] / > ] [ < modelGroupName [ suffix= '' suffix '' ] [ prefix= '' prefix '' ] / > ] [ < anonymousTypeName [ suffix= '' suffix '' ] [ prefix= '' prefix '' ] / > ] < /nameXmlTransform > As show , < schemaBinding > declaration include two subcomponents : < package > ... < /package > specify name package , desire , location API documentation schema-derived class . < nameXmlTransform > ... < /nameXmlTransform > specifies customizations apply . Class Binding Declarations The < class > bind declaration enables customize binding schema element Java content interface Java Element interface . < class > declaration use customize : A name schema-derived Java interface An implementation class schema-derived Java content interface The syntax < class > customizations : < class [ name = `` className '' ] [ implClass= `` implClass '' ] > [ < javadoc > ... < /javadoc > ] < /class > name name derived Java interface . It must valid Java interface name must contain package prefix . The package prefix inherit current value package . implClass name implementation class className must include complete package name . The < javadoc > element specify Javadoc tool annotation schema-derived Java interface . The string enter must use CDATA < escape embedded HTML tag . Property Binding Declarations The < property > bind declaration enables customize binding XML schema element Java representation property . The scope customization either definition level component level depend upon < property > bind declaration specify . The syntax < property > customizations : < property [ name = `` propertyName '' ] [ collectionType = `` propertyCollectionType '' ] [ fixedAttributeAsConstantProperty = `` true '' | `` false '' | `` 1 '' | `` 0 '' ] [ generateIsSetMethod = `` true '' | `` false '' | `` 1 '' | `` 0 '' ] [ enableFailFastCheck = '' true '' | `` false '' | `` 1 '' | `` 0 '' ] [ < baseType > ... < /baseType > ] [ < javadoc > ... < /javadoc > ] < /property > < baseType > < javaType > ... < /javaType > < /baseType > name define customization value propertyName ; must valid Java identifier . collectionType define customization value propertyCollectionType , collection type property , propertyCollectionType . If specify , property either index fully-qualified class name implement java.util.List . fixedAttributeAsConstantProperty define customization value fixedAttributeAsConstantProperty . The value either true , false , 1 , 0. generateIsSetMethod define customization value generateIsSetMethod . The value either true , false , 1 , 0. enableFailFastCheck define customization value enableFailFastCheck . The value either true , false , 1 , 0 . Please note JAXB implementation support failfast validation . < javadoc > customize Javadoc tool annotation property ’ getter method . javaType Binding Declarations The < javaType > declaration provide way customize translation XML data type Java data type . XML provide data type Java , < javaType > declaration enable specify custom data type binding default JAXB binding sufficiently represent schema . The target Java data type Java built-in data type application-specific Java data type . If application-specific Java data type use target , implementation must also provide parse print method unmarshalling marshal data . To end , JAXB specification support parseMethod printMethod : The parseMethod call unmarshalling convert string input document value target Java data type . The printMethod call marshal convert value target type lexical representation . If prefer define data type conversion , JAXB define static class , DatatypeConverter , assist parsing printing valid lexical representation XML Schema built-in data type . The syntax < javaType > customization : < javaType name= `` javaType '' [ xmlType= `` xmlType '' ] [ hasNsContext = `` true '' | `` false '' ] [ parseMethod= `` parseMethod '' ] [ printMethod= `` printMethod '' ] > name Java data type xmlType bind . xmlType name XML Schema data type javaType bind ; attribute require parent < javaType > declaration < globalBindings > . hasNsContext allow namespace context specify second parameter print parse method ; either true , false , 1 , 0 . By default , attribute false , case , need change . parseMethod name parse method call unmarshalling . printMethod name print method call marshalling . The < javaType > declaration use : A < globalBindings > declaration An annotation element simple type definition , GlobalBindings , < basetype > declaration A < property > declaration See MyDatatypeConverter Class example < javaType > declaration DatatypeConverterInterface interface implement custom data type converter class . Typesafe Enumeration Binding Declarations The typesafe enumeration declaration provide localized way map XML simpleType element Java typesafe enum class . There two type typesafe enumeration declaration make : < typesafeEnumClass > let map entire simpleType class typesafe enum class . < typesafeEnumMember > let map select member simpleType class typesafe enum class . In case , two primary limitation type customization : Only simpleType definition enumeration facet customize use binding declaration . This customization apply single simpleType definition time . To map set similar simpleType definition global level , use typesafeEnumBase attribute < globalBindings > declaration , describe Global Binding Declarations . The syntax < typesafeEnumClass > customization : < typesafeEnumClass [ name = `` enumClassName '' ] [ < typesafeEnumMember > ... < /typesafeEnumMember > ] * [ < javadoc > enumClassJavadoc < /javadoc > ] < /typesafeEnumClass > name must valid Java Identifier , must package prefix . You zero < typesafeEnumMember > declaration embed < typesafeEnumClass > declaration . < javadoc > customize Javadoc tool annotation enumeration class . The syntax < typesafeEnumMember > customization : < typesafeEnumMember name = `` enumMemberName '' > [ value = `` enumMemberValue '' ] [ < javadoc > enumMemberJavadoc < /javadoc > ] < /typesafeEnumMember > name must always specify must valid Java identifier . value must enumeration value specify ource schema . < javadoc > customize Javadoc tool annotation enumeration constant . For inline annotation , < typesafeEnumClass > declaration must specify annotation element < simpleType > element . The < typesafeEnumMember > must specify annotation element enumeration member . This enable enumeration member customize independently enumeration class . For information typesafe enum design pattern , see sample chapter Joshua Bloch ’ Effective Java Programming Oracle Technology Network.. javadoc Binding Declarations The < javadoc > declaration let add custom Javadoc tool annotation schema-derived JAXB package , class , interface , method , field . Note < javadoc > declaration apply globally ; valid sub-elements bind customizations . The syntax < javadoc > customization : < javadoc > Contents < b > Javadoc < \b > format . < /javadoc > < javadoc > < < ! [ CDATA [ Contents < b > Javadoc < \b > format ] ] > < /javadoc > Note documentation string < javadoc > declaration apply package level must contain < body > open close tag ; example : < jxb : package name= '' primer.myPo '' > < jxb : javadoc > < ! [ CDATA [ < body > Package level documentation generated package primer.myPo . < /body > ] ] > < /jxb : javadoc > < /jxb : package > Customization Namespace Prefix All standard JAXB bind declaration must precede namespace prefix map JAXB namespace URI http : //java.sun.com/xml/ns/jaxb . For example , sample , jxb : use . To end , schema want customize standard JAXB binding declaration must include JAXB namespace declaration JAXB version number top schema file . For example , po.xsd Customize Inline example , namespace declaration follow : < xsd : schema xmlns : xsd= `` http : //www.w3.org/2001/XMLSchema '' xmlns : jxb= `` http : //java.sun.com/xml/ns/jaxb '' jxb : version= '' 1.0 '' > A binding declaration jxb namespace prefix take following form : < xsd : annotation > < xsd : appinfo > < jxb : globalBindings bind declaration / > < jxb : schemaBindings > ... binding declaration . ... < /jxb : schemaBindings > < /xsd : appinfo > < /xsd : annotation > Note example , globalBindings schemaBindings declaration use specify , respectively , global scope schema scope customizations . These customization scope describe detail Scope , Inheritance , Precedence . Customize Inline Example The Customize Inline example illustrate basic customizations make mean inline annotation XML schema name po.xsd . In addition , example implement custom data type converter class , MyDatatypeConverter.java , illustrate print parse method < javaType > customization handle custom data type conversion . To summarize example : po.xsd XML schema contain inline binding customizations . MyDatatypeConverter.java Java class file implement print parse method specify < javaType > customizations po.xsd . Main.java primary class file Customize Inline example , use schema-derived class generate JAXB compiler . Building Running Customize Inline Example Using Ant To compile run Customize Inline example use Ant , terminal window , go jaxb-ri-install/samples/inline-customize/ directory type following : ant Key customizations sample custom MyDatatypeConverter.java class describe detail following section . Customized Schema The customized schema use Customize Inline example file jaxb-ri-install/samples/inline-customize/po.xsd . The customizations < xsd : annotation > tag . Global Binding Declarations The follow code example show globalBindings declaration po.xsd : < jxb : globalBindings fixedAttributeAsConstantProperty= '' true '' collectionType= '' java.util.Vector '' typesafeEnumBase= '' xsd : NCName '' choiceContentProperty= '' false '' typesafeEnumMemberName= '' generateError '' bindingStyle= '' elementBinding '' enableFailFastCheck= '' false '' generateIsSetMethod= '' false '' underscoreBinding= '' asCharInWord '' / > In example , value set default except collectionType . Setting fixedAttributeAsConstantProperty true indicates fix attribute bind Java constant . By default , fix attribute map either simple collection property , whichever appropriate . Setting collectionType java.util.Vector specifies list generated implementation class represent internally vector . Note class name specify collectionType must implement java.util.List callable newInstance . If typesafeEnumBase set xsd : string , global way specify simple type definition derive directly indirectly xsd : string enumeration facet , must bind default typesafe enum . If typesafeEnumBase set empty string ( `` '' ) , simple type definition bind typesafe enum class default . The value typesafeEnumBase atomic simple type definition except xsd : boolean binary type . The JAXB implementation support enableFailFastCheck attribute . Note : Using typesafe enum class enable map schema enumeration value Java constant , make possible comparison Java constant rather string value . Schema Binding Declarations The following code show schema bind declaration po.xsd : < jxb : schemaBindings > < jxb : package name= '' primer.myPo '' > < jxb : javadoc > < ! [ CDATA [ < body > Package level documentation generated package primer.myPo . < /body > ] ] > < /jxb : javadoc > < /jxb : package > < jxb : nameXmlTransform > < jxb : elementName suffix= '' Element '' / > < /jxb : nameXmlTransform > < /jxb : schemaBindings > < jxb : package name= '' primer.myPo '' / > specify primer.myPo package schema-derived class generate . < jxb : nameXmlTransform > specifies generate Java element interface Element append generate name default . For example , JAXB compiler run schema , element interface CommentElement PurchaseOrderElement generate . By contrast , without customization , default bind generates Comment PurchaseOrder . This customization useful schema use name different symbol space ; example , global element type definition . In case , customization enable resolve collision one declaration rather individually resolve collision separate binding declaration . < jxb : javadoc > specifies customize Javadoc tool annotation primer.myPo package . Note , unlike < javadoc > declaration class level , show following example , opening closing < body > tag must include < javadoc > declaration make package level . Class Binding Declarations The following code show class binding declaration po.xsd : < xsd : complexType name= '' PurchaseOrderType '' > < xsd : annotation > < xsd : appinfo > < jxb : class name= '' POType '' > < jxb : javadoc > A & lt ; b > Purchase Order & lt ; /b > consists address item . < /jxb : javadoc > < /jxb : class > < /xsd : appinfo > < /xsd : annotation > < ! -- ... -- > < /xsd : complexType > The Javadoc tool annotation schema-derived POType class contain description `` A & lt ; b > Purchase Order & lt ; /b > consists address item . '' The & lt ; use escape opening bracket < b > HTML tag . Note : When < class > customization specify appinfo element complexType definition , show previous example , complexType definition bind Java content interface . Later po.xsd , another < javadoc > customization declare class level , time HTML string escape CDATA : < xsd : annotation > < xsd : appinfo > < jxb : class > < jxb : javadoc > < ! [ CDATA [ First line documentation < b > USAddress < /b > . ] ] > < /jxb : javadoc > < /jxb : class > < /xsd : appinfo > < /xsd : annotation > Note : If want include HTML tag < jaxb : javadoc > customization , must enclose data within CDATA section escape left angle bracket use & lt ; . See XML 1.0 2nd Edition information . Property Binding Declarations Of particular interest generateIsSetMethod customization , cause two additional property method , isSetQuantity unsetQuantity , generate . These method enable client application distinguish schema default value value occur explicitly within instance document . For example , po.xsd : < xsd : complexType name= '' Items '' > < xsd : sequence > < xsd : element name= '' item '' minOccurs= '' 1 '' maxOccurs= '' unbounded '' > < xsd : complexType > < xsd : sequence > < xsd : element name= '' productName '' type= '' xsd : string '' / > < xsd : element name= '' quantity '' default= '' 10 '' > < xsd : annotation > < xsd : appinfo > < jxb : property generateIsSetMethod= '' true '' / > < /xsd : appinfo > < /xsd : annotation > < ! -- ... -- > < /xsd : complexType > < /xsd : element > < /xsd : sequence > < /xsd : complexType > The @ generateIsSetMethod applies quantity element , bind property within Items.ItemType interface . unsetQuantity isSetQuantity method generate Items.ItemType interface . MyDatatypeConverter Class The class jaxb-ri-install/samples/inline-customize/src/inlinecustomize/primer/MyDatatypeConverter , show following example , provide way customize translation XML data type Java data type use < javaType > customization . package primer ; import java.math.BigInteger ; import javax.xml.bind.DatatypeConverter ; public class MyDatatypeConverter { public static short parseIntegerToShort ( String value ) { BigInteger result = DatatypeConverter.parseInteger ( value ) ; return ( short ) ( result.intValue ( ) ) ; } public static String printShortToInteger ( short value ) { BigInteger result = BigInteger.valueOf ( value ) ; return DatatypeConverter.printInteger ( result ) ; } public static int parseIntegerToInt ( String value ) { BigInteger result = DatatypeConverter.parseInteger ( value ) ; return result.intValue ( ) ; } public static String printIntToInteger ( int value ) { BigInteger result = BigInteger.valueOf ( value ) ; return DatatypeConverter.printInteger ( result ) ; } } ; The following code show MyDatatypeConverter class reference < javaType > declaration po.xsd : < xsd : simpleType name= '' ZipCodeType '' > < xsd : annotation > < xsd : appinfo > < jxb : javaType name= '' int '' parseMethod= '' primer.MyDatatypeConverter.parseIntegerToInt '' printMethod= '' primer.MyDatatypeConverter.printIntTo Integer '' / > < /xsd : appinfo > < /xsd : annotation > < xsd : restriction base= '' xsd : integer '' > < xsd : minInclusive value= '' 10000 '' / > < xsd : maxInclusive value= '' 99999 '' / > < /xsd : restriction > < /xsd : simpleType > In example , jxb : javaType bind declaration override default JAXB binding type java.math.BigInteger . For purpose Customize Inline example , restriction ZipCodeType ( specifically , valid United States ZIP code limit five digit ) make possible valid value fit within Java primitive data type int . Note also , < jxb : javaType name= '' int '' / > declare within ZipCodeType , customization applies JAXB property reference simpleType definition , include getZip setZip method . DataType Converter Example The DataType Converter example similar Customize Inline example . As Customize Inline example , customizations Datatype Converter example make use inline binding declaration XML schema application , po.xsd . The global , schema , package , class customizations Customize Inline DataType Converter example identical . Where Datatype Converter example differs Customize Inline example parseMethod printMethod use convert XML data Java int data type . Specifically , rather use method custom MyDataTypeConverter class perform data type conversion , Datatype Converter example use built-in method provide javax.xml.bind.DatatypeConverter : < xsd : simpleType name= '' ZipCodeType '' > < xsd : annotation > < xsd : appinfo > < jxb : javaType name= '' int '' parseMethod= '' javax.xml.bind.DatatypeConverter.parseInt '' printMethod= '' javax.xml.bind.DatatypeConverter.printInt '' / > < /xsd : appinfo > < /xsd : annotation > < xsd : restriction base= '' xsd : integer '' > < xsd : minInclusive value= '' 10000 '' / > < xsd : maxInclusive value= '' 99999 '' / > < /xsd : restriction > < /xsd : simpleType > Building Running Datatype Converter Example Using Ant To compile run DataType Converter example use Ant , terminal window , go jaxb-ri-install/samples/datatypeconverter/ directory type following : ant Binding Declaration Files The following section provide information bind declaration file : JAXB Version , Namespace , Schema Attributes Global Schema Binding Declarations Class Declarations JAXB Version , Namespace , Schema Attributes All JAXB bind declaration file must begin : JAXB version number Namespace declaration Schema name node The version , namespace , schema declaration bindings.xjb follow : < jxb : binding version= '' 1.0 '' xmlns : jxb= '' http : //java.sun.com/xml/ns/jaxb '' xmlns : xs= '' http : //www.w3.org/2001/XMLSchema '' > < jxb : binding schemaLocation= '' po.xsd '' node= '' /xs : schema '' > < ! -- ... binding-declarations ... -- > < /jxb : binding > < ! -- schemaLocation= '' po.xsd '' node= '' /xs : schema '' -- > < /jxb : binding > JAXB Version Number An XML file root element < jaxb : binding > consider external binding file . The root element must specify JAXB version attribute binding declaration must comply ; specifically root < jxb : binding > element must contain either < jxb : version > declaration version attribute . By contrast , make bind declaration inline , JAXB version number make attribute < xsd : schema > declaration : < xsd : schema xmlns : xsd= '' http : //www.w3.org/2001/XMLSchema '' xmlns : jxb= '' http : //java.sun.com/xml/ns/jaxb '' jxb : version= '' 1.0 '' > Namespace Declarations As show JAXB Version , Namespace , Schema Attributes , namespace declaration external binding declaration file include JAXB namespace XMLSchema namespace . Note prefix use example could fact anything want ; important thing consistently use whatever prefix define subsequent declaration file . Schema Name Schema Node The fourth line code JAXB Version , Namespace , Schema Attributes specify name schema binding declaration file applies , schema node customizations first take effect . Subsequent binding declaration file reference specific node within schema , first declaration encompass schema whole ; example , bindings.xjb : < jxb : binding schemaLocation= '' po.xsd '' node= '' /xs : schema '' > Global Schema Binding Declarations The global schema bind declaration bindings.xjb po.xsd DataType Converter example . The difference declaration po.xsd make inline , must embed < x : appinfo > element , turn embed < x : annotation > element . Embedding declaration way unnecessary external binding file . < jxb : globalBindings fixedAttributeAsConstantProperty= '' true '' collectionType= '' java.util.Vector '' typesafeEnumBase= '' x : NCName '' choiceContentProperty= '' false '' typesafeEnumMemberName= '' generateError '' bindingStyle= '' elementBinding '' enableFailFastCheck= '' false '' generateIsSetMethod= '' false '' underscoreBinding= '' asCharInWord '' / > < jxb : schemaBindings > < jxb : package name= '' primer.myPo '' > < jxb : javadoc > < ! [ CDATA [ < body > Package level documentation generated package primer.myPo. < /body > ] ] > < /jxb : javadoc > < /jxb : package > < jxb : nameXmlTransform > < jxb : elementName suffix= '' Element '' / > < /jxb : nameXmlTransform > < /jxb : schemaBindings > By comparison , syntax use po.xsd DataType Converter example : < xsd : annotation > < xsd : appinfo > < jxb : globalBindings ... binding-declarations ... < jxb : schemaBindings > ... binding-declarations ... < /jxb : schemaBindings > < /xsd : appinfo > < /xsd : annotation > Class Declarations The class-level binding declaration bindings.xjb differ analogous declaration po.xsd Datatype Converter example two way : As bind declaration bindings.xjb , need embed customizations schema < xsd : appinfo > element . You must specify schema node customization apply . The general syntax type declaration : < jxb : binding node= '' //node-type [ @ name= ’ node-name ’ ] '' > For example , following code show bind declaration complexType name USAddress . < jxb : binding node= '' //xs : complexType [ @ name= ’ USAddress ’ ] '' > < jxb : class > < jxb : javadoc > < ! [ CDATA [ First line documentation < b > USAddress < /b > . ] ] > < /jxb : javadoc > < /jxb : class > < jxb : binding node= '' .//xs : element [ @ name= ’ name ’ ] '' > < jxb : property name= '' toName '' / > < /jxb : binding > < jxb : binding node= '' .//xs : element [ @ name= ’ zip ’ ] '' > < jxb : property name= '' zipCode '' / > < /jxb : binding > < /jxb : binding > < ! -- node= '' //xs : complexType [ @ name= ’ USAddress ’ ] '' -- > Note example USAddress parent child element name zip , therefore < /jxb : binding > tag enclose binding declaration child element class-level javadoc declaration . External Customize Example The External Customize example identical DataType Converter example , except binding declaration External Customize example make use external binding declaration file rather inline source XML schema . The binding customization file use External Customize example jaxb-ri-install/samples/external-customize/binding.xjb . This section compare customization declaration bindings.xjb analogous declaration use XML schema , po.xsd , DataType Converter example . The two set declaration achieve precisely result . Building Running External Customize Example Using Ant To compile run External Customize example use Ant , terminal window , go jaxb-ri-install/samples/external-customize/ directory type following : ant