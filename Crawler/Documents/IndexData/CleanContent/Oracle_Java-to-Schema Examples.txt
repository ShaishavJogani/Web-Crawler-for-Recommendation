The Java-to-Schema example show use annotation map Java class XML schema . j2s-create-marshal Example The j2s-create-marshal example illustrate Java-to-schema data binding . It demonstrate marshal unmarshalling JAXB annotate class also show enable JAXP 1.3 validation unmarshal time use schema file generate JAXB map class . The schema file , bc.xsd , generate following command : schemagen src/cardfile/*.java cp schema1.xsd bc.xsd Note schema1.xsd copy bc.xsd ; schemagen allow specify schema name choice . Building Running j2s-create-marshal Example Using Ant To compile run j2s-create-marshal example use Ant , terminal window , go jaxb-ri-install/samples/j2s-create-marshal/ directory type following : ant j2s-xmlAccessorOrder Example The j2s-xmlAccessorOrder example show use @ XmlAccessorOrder @ XmlType.propOrder annotation dictate order XML content marshal unmarshalled Java type . With Java-to-schema mapping , JavaBean ’ property field map XML Schema type . The class element map either XML Schema complex type XML Schema simple type . The default element order generated schema type currently unspecified Java reflection impose return order . The lack reliable element order negatively impact application portability . You use two annotation , @ XmlAccessorOrder @ XmlType.propOrder , define schema element order application must portable across JAXB Providers . Using @ XmlAccessorOrder Annotation Define Schema Element Ordering The @ XmlAccessorOrder annotation impose one two element order algorithm , AccessorOrder.UNDEFINED AccessorOrder.ALPHABETICAL . AccessorOrder.UNDEFINED default setting . The order dependent system ’ reflection implementation . AccessorOrder.ALPHABETICAL algorithm order element lexicographic order determine java.lang.String.CompareTo ( String anotherString ) . You define @ XmlAccessorOrder annotation annotation type ElementType.PACKAGE class object . When @ XmlAccessorOrder annotation define package , scope formatting rule active every class package . When define class , rule active content class . There multiple @ XmlAccessorOrder annotation within package . The innermost ( class ) annotation take precedence annotation . For example , @ XmlAccessorOrder ( AccessorOrder.ALPHABETICAL ) define package @ XmlAccessorOrder ( AccessorOrder.UNDEFINED ) define class package , content generated schema type class would unspecified order content generated schema type every class package would alphabetical order . Using @ XmlType Annotation Define Schema Element Ordering The @ XmlType annotation define class . The annotation element propOrder ( ) @ XmlType annotation enable specify content order generated schema type . When use @ XmlType.propOrder annotation class specify content order , public property public field class must specify parameter list . Any public property field want keep parameter list must annotate @ XmlAttribute @ XmlTransient annotation . The default content order @ XmlType.propOrder { } { `` '' } , active . In case , active @ XmlAccessorOrder annotation take precedence . When class content order specify @ XmlType.propOrder annotation , take precedence active @ XmlAccessorOrder annotation class package . If @ XmlAccessorOrder @ XmlType.propOrder ( A , B , ... ) annotation specify class , propOrder always take precedence regardless order annotation statement . For example , following code segment , @ XmlAccessorOrder annotation precede @ XmlType.propOrder annotation . @ XmlAccessorOrder ( AccessorOrder.ALPHABETICAL ) @ XmlType ( propOrder= { `` name '' , `` city '' } ) public class USAddress { // ... public String getCity ( ) { return city ; } public void setCity ( String city ) { this.city = city ; } public String getName ( ) { return name ; } public void setName ( String name ) { this.name = name ; } // ... } In following code segment , @ XmlType.propOrder annotation precede @ XmlAccessorOrder annotation . @ XmlType ( propOrder= { `` name '' , `` city '' } ) @ XmlAccessorOrder ( AccessorOrder.ALPHABETICAL ) public class USAddress { // ... public String getCity ( ) { return city ; } public void setCity ( String city ) { this.city = city ; } public String getName ( ) { return name ; } public void setName ( String name ) { this.name = name ; } // ... } In scenario , propOrder take precedence following identical schema content generate : < x : complexType name= '' usAddress '' > < x : sequence > < x : element name= '' name '' type= '' x : string '' minOccurs= '' 0 '' / > < x : element name= '' city '' type= '' x : string '' minOccurs= '' 0 '' / > < /xs : sequence > < /xs : complexType > Schema Content Ordering Example The purchase order code example demonstrate effect schema content order use @ XmlAccessorOrder annotation package class level , @ XmlType.propOrder annotation class . Class package-info.java defines @ XmlAccessorOrder ALPHABETICAL package . The public field shipTo billTo class PurchaseOrderType affect generated schema content order rule . Class USAddress define @ XmlType.propOrder annotation class demonstrate user-defined property order supersede ALPHABETICAL order generated schema . The generated schema file find jaxb-ri-install/samples/j2s-xmlAccessorOrder/build/schemas/ directory . Building Running j2s-xmlAccessorOrder Example Using Ant To compile run j2s-xmlAccessorOrder example use Ant , terminal window , go jaxb-ri-install/samples/j2s-xmlAccessorOrder/ directory type following : ant j2s-xmlAdapter Example The j2s-xmlAdapter example demonstrate use XmlAdapter interface @ XmlJavaTypeAdapter annotation provide custom mapping XML content HashMap ( field ) use int key String value . Interface XmlAdapter annotation @ XmlJavaTypeAdapter use special processing data type unmarshalling marshalling . There variety XML data type representation map easily Java ( example , x : DateTime x : Duration ) , Java type map properly XML representation . For example , implementation java.util.Collection ( List ) java.util.Map ( HashMap ) non-JavaBean class . The XmlAdapter interface @ XmlJavaTypeAdapter annotation provide case . This combination provide portable mechanism reading write XML content Java application . The XmlAdapter interface define method data reading writing . /* * ValueType - Java class provide * XML representation data . * It object use marshal * unmarshalling . * * BoundType - Java class use * process XML content . */ public abstract class XmlAdapter < ValueType , BoundType > { // Do-nothing constructor derived class . protect XmlAdapter ( ) { } // Convert value type bound type . public abstract BoundType unmarshal ( ValueType v ) ; // Convert bound type value type . public abstract ValueType marshal ( BoundType v ) ; } You use @ XmlJavaTypeAdapter annotation associate particular XmlAdapter implementation Target type , PACKAGE , FIELD , METHOD , TYPE , PARAMETER . The j2s-xmlAdapter example show use XmlAdapter map XML content ( custom ) HashMap . The HashMap object , basket , class KitchenWorldBasket , use key type int value type String . These data type reflect XML content read write , XML content look following example : < basket > < entry key= '' 9027 '' > glasstop stove black < /entry > < entry key= '' 288 '' > wooden spoon < /entry > < /basket > The default schema generate Java type HashMap reflect desired format . < x : element name= '' basket '' > < x : complexType > < x : sequence > < x : element name= '' entry '' minOccurs= '' 0 '' maxOccurs= '' unbounded '' > < x : complexType > < x : sequence > < x : element name= '' key '' minOccurs= '' 0 '' type= '' x : anyType '' / > < x : element name= '' value '' minOccurs= '' 0 '' type= '' x : anyType '' / > < /xs : sequence > < /xs : complexType > < /xs : element > < /xs : sequence > < /xs : complexType > < /xs : element > In default HashMap schema , key value element data type anyType . The XML content look like following : < basket > < entry > < key > 9027 < /key > < value > glasstop stove black < /value > < /entry > < entry > < key > 288 < /key > < value > wooden spoon < /value > < /entry > < /basket > To resolve issue , example use two Java class , PurchaseList PartEntry , reflect needed schema format unmarshalling marshal content . The XML schema generate class follow : < x : complexType name= '' PurchaseListType '' > < x : sequence > < x : element name= '' entry '' type= '' partEntry '' nillable= '' true '' maxOccurs= '' unbounded '' minOccurs= '' 0 '' / > < /xs : sequence > < /xs : complexType > < x : complexType name= '' partEntry '' > < x : simpleContent > < x : extension base= '' x : string '' > < x : attribute name= '' key '' type= '' x : int '' use= '' require '' / > < /xs : extension > < /xs : simpleContent > < /xs : complexType > Class AdapterPurchaseListToHashMap implement XmlAdapter interface . In class KitchenWorldBasket , @ XmlJavaTypeAdapter annotation use pair AdapterPurchaseListToHashMap field HashMap basket . This pairing cause marshal unmarshal method AdapterPurchaseListToHashMap call corresponding marshal unmarshal action KitchenWorldBasket . Building Running j2s-xmlAdapter Example Using Ant To compile run j2s-xmlAdapter example use Ant , terminal window , go jaxb-ri-install/samples/j2s-xmlAdapter/ directory type following : ant j2s-xmlAttribute Example The j2s-xmlAttribute example show use @ XmlAttribute annotation define property field treat XML attribute . The @ XmlAttribute annotation map field JavaBean property XML attribute . The following rule impose : A static final field map XML fix attribute . When field property collection type , item collection type must map schema simple type . When field property collection type , type must map schema simple type . When follow JavaBean programming paradigm , property define get set prefix field name . int zip ; public int getZip ( ) { return zip ; } public void setZip ( int z ) { zip=z ; } Within bean class , choice set @ XmlAttribute annotation one three component : field , setter method , getter method . If set @ XmlAttribute annotation field , setter method must rename naming conflict compile time . If set @ XmlAttribute annotation one method , must set either setter getter method , . The XmlAttribute example show use @ XmlAttribute annotation static final field , field rather one corresponding bean method , bean property ( method ) , field collection type . In class USAddress , field , country , zip tag attribute . The setZip method disable avoid compile error . Property state tag attribute setter method . You could use getter method instead . In class PurchaseOrderType , field cCardVendor non-collection type . It meet requirement simple type ; enum type . Building Running j2s-xmlAttribute Example Using Ant To compile run j2s-xmlAttribute example use Ant , terminal window , go jaxb-ri-install/samples/j2s-xmlAttribute/ directory type following : ant j2s-xmlRootElement Example The j2s-xmlRootElement example demonstrate use @ XmlRootElement annotation define XML element name XML schema type corresponding class . The @ XmlRootElement annotation map class enum type XML element . At least one element definition need top-level Java type use unmarshalling marshalling . If element definition , start location XML content processing . The @ XmlRootElement annotation use class name default element name . You change default name use annotation attribute name . If , specify name use element name type name . It common schema practice element type name different . You use @ XmlType annotation set element type name . The namespace attribute @ XmlRootElement annotation use define namespace element . Building Running j2s-xmlRootElement Example Using Ant To compile run j2s-xmlRootElement example use Ant , terminal window , go jaxb-ri-install/samples/j2s-xmlRootElement/ directory type following : ant j2s-xmlSchemaType Example The j2s-xmlSchemaType example demonstrate use annotation @ XmlSchemaType customize mapping property field XML built-in type . The @ XmlSchemaType annotation use map Java type one XML built-in type . This annotation useful map Java type one nine date/time primitive data type . When @ XmlSchemaType annotation define package level , identification require XML built-in type name corresponding Java type class . An @ XmlSchemaType definition field property take precedence package definition . The XmlSchemaType Class example show use @ XmlSchemaType annotation package level , field , property . File TrackingOrder two field , orderDate deliveryDate , define type XMLGregorianCalendar . The generate schema define element XML built-in type gMonthDay . This relationship define package file package-info.java . Field shipDate file TrackingOrder also define type XMLGregorianCalendar , @ XmlSchemaType annotation statement override package definition specify field type date . Property method getTrackingDuration define schema element define primitive type duration Java type String . Building Running j2s-xmlSchemaType Example Using Ant To compile run j2s-xmlSchemaType example use Ant , terminal window , go jaxb-ri-install/samples/j2s-xmlSchemaType/ directory type following : ant j2s-xmlType Example The j2s-xmlType example demonstrate use @ XmlType annotation . The @ XmlType annotation map class enum type XML Schema type . A class must either public zero-argument constructor static zero-argument factory method order map annotation . One method use unmarshalling create instance class . The factory method locate within factory class exist class . There order precedence method use unmarshalling : If factory class identify annotation , corresponding factory method class must also identify , method use . If factory method identify annotation factory class identify , factory method must locate current class . The factory method use even public zero argument constructor method present . If factory method identify annotation , class must contain public zero argument constructor method . In example , factory class provide zero arg factory method several class . The @ XmlType annotation class OrderContext reference factory class . The unmarshaller use identified factory method class . public class OrderFormsFactory { public OrderContext newOrderInstance ( ) { return new OrderContext ( ) } public PurchaseOrderType { newPurchaseOrderType ( ) { return new newPurchaseOrderType ( ) ; } } @ XmlType ( name= '' oContext '' , factoryClass= '' OrderFormsFactory '' , factoryMethod= '' newOrderInstance '' ) public class OrderContext { public OrderContext ( ) { // ... } } } In example , factory method define class , also contain standard class construct . Because factoryMethod value define factoryClass define , factory method newOrderInstance use unmarshalling . @ XmlType ( name= '' oContext '' , factoryMethod= '' newOrderInstance '' ) public class OrderContext { public OrderContext ( ) { // ... } public OrderContext newOrderInstance ( ) { return new OrderContext ( ) ; } } Building Running j2s-xmlType Example Using Ant To compile run j2s-xmlType example use Ant , terminal window , go jaxb-ri-install/samples/j2s-xmlType/ directory type following : ant