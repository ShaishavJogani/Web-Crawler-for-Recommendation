This section discuss work bidirectional text class java.awt java.awt.font package . These class let draw style text language script support The Unicode Standard : global character cod system handle diverse modern , classical , historical language . When draw text , direction text read must take account word string display correctly . These class maintain direction text correctly draw matter string run left-to-right , right-to-left , ( bidirectional ) . Bidirectional text present interest problem correctly position caret , accurately locate selection , correctly display multiple line . Also bidirectional right-to-left text present similar problem move caret correct direction response right leave arrow key press . The following topic cover : Ordering Text Manipulating Bidirectional Text Displaying Carets Moving Carets Hit Testing Highlighting Selections Performing Text Layout Java Application Managing Text Layout TextLayout Class Laying Out Text TextLayout Class Displaying Dual Carets TextLayout Class Moving Caret TextLayout Class Hit Testing TextLayout Class Highlighting Selections TextLayout Class If plan work Swing component see Working Bidirectional Text JTextComponent Class Using Text Components information . Ordering Text Java SE store text memory logical order , order character word read write . The logical order necessarily visual order , order corresponding glyph display . A writing system ' visual order must maintain bidirectional text even language mixed together . This illustrate following figure , display Arabic phrase embed English sentence . Note : In subsequent example , Arabic Hebrew text represent upper case letter space represent underscore . Each illustration contain two part : representation character store memory ( character logical order ) follow representation character display ( character visual order ) . The number character box indicate insertion offset . Even though part English sentence , Arabic word display Arabic script order , right-to-left . Because italicized Arabic word logically Arabic plain text , visually left plain text . When line mixture left-to-right right-to-left text display , base direction significant . The base direction script order predominant writing system . For example , text primarily English embedded Arabic , base direction left-to-right . If text primarily Arabic embedded English number , base direction right-to-left . The base direction determine order segment text common direction display . In example show previous figure , base direction left-to-right . There three directional run example : English text beginning sentence run leave right , Arabic text run right leave , period run leave right . Graphics often embed flow text . These inline graphic behave like glyph term affect text flow line wrapping . Such inline graphic need position use bidirectional layout algorithm appear proper location flow character . Java SE use Unicode Bidirectional Algorithm , algorithm use order glyph within line , thereby determine directionality bidirectional text . In case , need include additional information order algorithm obtain correct display order . Manipulating Bidirectional Text To allow user edit bidirectional text , must able following : Displaying Carets Moving Carets Hit Testing Highlighting Selections Displaying Carets In editable text , caret use graphically represent current insertion point , position text new character insert . Typically , caret show blinking vertical bar two glyph . New character insert display caret 's location . Calculating caret position complicate , particularly bidirectional text . Insertion offset directional boundary two possible caret position two glyph correspond character offset display adjacent one another . This illustrate following figure . In figure , caret show square bracket indicate glyph caret correspond . Character offset 8 corresponds location underscore A . If user enter Arabic character , glyph display right ( ) A ; user enter English character , glyph display right ( ) underscore . To handle situation , system display dual caret , strong ( primary ) caret weak ( secondary ) caret . The strong caret indicate inserted character display character 's direction base direction text . The weak caret show inserted character display character 's direction opposite base direction TextLayout automatically support dual caret . When 're work bidirectional text , ca n't simply add width glyph character offset calculate caret position . If , caret would draw wrong place , show following figure : For caret properly position , width glyph left offset need add current context take account . Unless context take account , glyph metric necessarily match display . ( The context affect glyph use . ) Moving Carets All text editor allow user move caret arrow key . Users expect caret move direction pressed arrow key . In left-to-right text , move insertion offset simple : right arrow key increase insertion offset one left arrow key decrease one . In bidirectional text text ligature , behavior would cause caret jump across glyph direction boundary move reverse direction within different directional run . To move caret smoothly bidirectional text , need take account direction text run . You ca n't simply increment insertion offset right arrow key press decrement left arrow key press . If current insertion offset within run right-to-left character , right arrow key decrease insertion offset , left arrow key increase . Moving caret across directional boundary even complicated . The following figure illustrate happen directional boundary cross user navigate arrow key . Stepping three position right displayed text corresponds move character offset 7 , 19 , 18 . Certain glyph never caret ; instead , caret move though glyph represent single character . For example , never caret umlaut represent two separate character . The TextLayout class provide method ( getNextRightHit getNextLeftHit ) enable easily move caret smoothly bidirectional text . Hit Testing Often , location device space must convert text offset . For example , user click mouse selectable text , location mouse convert text offset use one end selection range . Logically , inverse position caret . When 're work bidirectional text , single visual location display correspond two different offset source text , show following figure : Because single visual location correspond two different offset , hit test bidirectional text n't matter measure glyph width glyph correct location find map position back character offset . Detecting side hit helps distinguish two alternative . You perform hit test use TextLayout.hitTestChar . Hit information encapsulate TextHitInfo object include information side hit . Highlighting Selections A select range character represent graphically highlight region , area glyph display inverse video different background color . Highlight region , like caret , complicated bidirectional text unidirectional text . In bidirectional text , contiguous range character might contiguous highlight region displayed . Conversely , highlight region show visually contiguous range glyph might correspond single , contiguous range character . This result two strategy highlight selection bidirectional text : Logical highlighting : With logical highlighting , select character always contiguous text model , highlight region allow discontiguous . The following example logical highlighting : Visual highlighting : With visual highlighting , might one range select character , highlight region always contiguous . The following example visual highlighting : Logical highlighting simpler implement , since select character always contiguous text . The sample SelectionSample.java demonstrate logical highlighting : Performing Text Layout Java Application Depending Java APIs use , little much control text layout need : If want display block text need editable text control , use JTextComponent , perform text layout . JTextComponent design handle need international application support bidirectional text For information JTextComponent , see Working Bidirectional Text JTextComponent Class Using Text Components information . If want display simple text string , call method Graphics2D.drawString let Java 2D lay string . You also use Graphics2D.drawString render styled string string contain bidirectional text . For information render text Graphics2D , see Working Text APIs . If want implement text edit routine , use TextLayout manage text layout , highlighting , hit detection . The facility provide TextLayout handle common case , include text string mixed font , mixed language , bidirectional text . For information use TextLayout , see Managing Text Layout . If want total control text shape position , construct GlyphVector instance use Font class render Graphics2D class . Generally , need perform text layout operation . For application , JTextComponent best solution display static editable text . However , JTextComponent support display dual caret discontiguous selection bidirectional text . If application require feature , prefer implement text edit routine , use Java 2D text layout APIs . Managing Text Layout TextLayout Class The TextLayout class support text contain multiple style character different write system , include Arabic Hebrew . ( Arabic Hebrew particularly difficult display must reshape reorder text achieve acceptable representation . ) TextLayout simplifies process display measure text even work English-only text . By use TextLayout , achieve high-quality typography extra effort . TextLayout design significant performance impact use display simple , unidirectional text . There additional processing overhead TextLayout use display Arabic Hebrew text . However , 's typically order microsecond per character dominate execution normal draw code . The TextLayout class manage positioning ordering glyph . You use TextLayout following : Laying Out Text TextLayout Class Displaying Dual Carets TextLayout Class Moving Caret TextLayout Class Hit Testing TextLayout Class Highlighting Selections TextLayout Class Laying Out Text TextLayout Class TextLayout automatically lay text , include bidirectional text , correct shaping ordering . To correctly shape order glyph represent line text , TextLayout must know full context text : If text fit single line , single-word label button line dialog box , construct TextLayout directly text . If text fit single line want break text single line tabbed segment , construct TextLayout directly . You must use LineBreakMeasurer provide sufficient context . See Drawing Multiple Lines Text information . The base direction text normally set attribute ( style ) text . If attribute miss , TextLayout follow Unicode bidirectional algorithm derive base direction initial character paragraph . Displaying Dual Carets TextLayout Class TextLayout maintain caret information caret Shape , position , angle . You use information easily display caret unidirectional bidirectional text . When 're draw caret bidirectional text , use TextLayout ensure caret position correctly . TextLayout provide default caret Shapes automatically support dual caret . For italic oblique glyph , TextLayout produce angled caret , show following figure . These caret position also use boundary glyph highlight hit testing , help produce consistent user experience . Given insertion offset , getCaretShapes method return two-element array Shape object : element 0 contain strong caret element 1 contain weak caret , one exist . To display dual caret , simply draw caret Shape object ; caret automatically render correct position . If want use custom caret , retrieve position angle caret TextLayout draw . The sample HitTestSample.java demonstrate dual caret . A click side towards Hebrew text record end user click , part English text . This position weak ( black ) caret next strong caret ( red ) front H : A click space right record end user click space , part Hebrew text . This position strong ( red ) caret next weak caret ( black ) front H : Moving Caret TextLayout Class You also use TextLayout class determine result insertion offset user press left right arrow key . Given TextHitInfo object represent current insertion offset , getNextRightHit method return TextHitInfo object represent correct insertion offset right arrow key press . The getNextLeftHit method provide information left arrow key . The following excerpt sample ArrowKeySample.java demonstrate determine result insertion offset user press left right arrow key : public class ArrowKeySample extend JPanel implement KeyListener { // ... private static void createAndShowGUI ( ) { // Create set window . ArrowKey demo = new ArrowKey ( ) ; frame = new JFrame ( `` Arrow Key Sample '' ) ; frame.addKeyListener ( demo ) ; // ... } private void handleArrowKey ( boolean rightArrow ) { TextHitInfo newPosition ; ( rightArrow ) { newPosition = textLayout.getNextRightHit ( insertionIndex ) ; } else { newPosition = textLayout.getNextLeftHit ( insertionIndex ) ; } // getNextRightHit ( ) / getNextLeftHit ( ) return null // caret position right ( leave ) // current position . ( newPosition ! = null ) { // Update insertionIndex . insertionIndex = newPosition.getInsertionIndex ( ) ; // Repaint Component new caret ( ) display . frame.repaint ( ) ; } } // ... @ Override public void keyPressed ( KeyEvent e ) { int keyCode = e.getKeyCode ( ) ; ( keyCode == KeyEvent.VK_LEFT || keyCode == KeyEvent.VK_RIGHT ) { handleArrowKey ( keyCode == KeyEvent.VK_RIGHT ) ; } } } Hit Testing TextLayout Class The TextLayout class provide simple mechanism hit test text . The hitTextChar method take x coordinate mouse argument return TextHitInfo object . The TextHitInfo contain insertion offset specified position side hit . The insertion offset offset closest hit : hit past end line , offset end line return . The following excerpt HitTestSample.java retrieve offset mouse click : private class HitTestMouseListener extend MouseAdapter { public void mouseClicked ( MouseEvent e ) { Point2D origin = computeLayoutOrigin ( ) ; // Compute mouse click location relative // textLayout 's origin . float clickX = ( float ) ( e.getX ( ) - origin.getX ( ) ) ; float clickY = ( float ) ( e.getY ( ) - origin.getY ( ) ) ; // Get character position mouse click . TextHitInfo currentHit = textLayout.hitTestChar ( clickX , clickY ) ; insertionIndex = currentHit.getInsertionIndex ( ) ; // Repaint Component new caret ( ) display . repaint ( ) ; } } Highlighting Selections TextLayout Class You get Shape represent highlight region TextLayout . TextLayout automatically take context account calculate dimension highlight region . TextLayout support logical visual highlighting . The following excerpt SelectionSample.java demonstrate one way display highlight text : public void paint ( Graphics g ) { // ... boolean haveCaret = anchorEnd == activeEnd ; ( ! haveCaret ) { // Retrieve highlight region selection range . Shape highlight = textLayout.getLogicalHighlightShape ( anchorEnd , activeEnd ) ; // Fill highlight region highlight color . graphics2D.setColor ( HIGHLIGHT_COLOR ) ; graphics2D.fill ( highlight ) ; } // ... } // ... private class SelectionMouseMotionListener extend MouseMotionAdapter { public void mouseDragged ( MouseEvent e ) { Point2D origin = computeLayoutOrigin ( ) ; // Compute mouse location relative // textLayout 's origin . float clickX = ( float ) ( e.getX ( ) - origin.getX ( ) ) ; float clickY = ( float ) ( e.getY ( ) - origin.getY ( ) ) ; // Get character position mouse location . TextHitInfo position = textLayout.hitTestChar ( clickX , clickY ) ; int newActiveEnd = position.getInsertionIndex ( ) ; // If newActiveEnd different activeEnd , update activeEnd // repaint Panel new selection display . ( activeEnd ! = newActiveEnd ) { activeEnd = newActiveEnd ; frame.repaint ( ) ; } } } private class SelectionMouseListener extend MouseAdapter { public void mousePressed ( MouseEvent e ) { Point2D origin = computeLayoutOrigin ( ) ; // Compute mouse location relative // TextLayout 's origin . float clickX = ( float ) ( e.getX ( ) - origin.getX ( ) ) ; float clickY = ( float ) ( e.getY ( ) - origin.getY ( ) ) ; // Set anchor active end selection // character position mouse location . TextHitInfo position = textLayout.hitTestChar ( clickX , clickY ) ; anchorEnd = position.getInsertionIndex ( ) ; activeEnd = anchorEnd ; // Repaint Panel new selection display . frame.repaint ( ) ; } } The method SelectionMouseListener.mousePressed specifies variable anchorEnd , position text mouse click . The method SelectionMouseMotionListener.mouseDragged specify variable activeEnd , position text mouse drag . The paint method retrieve Shape object represent select text ( text position anchorEnd activeEnd ) . The paint method fill Shape object highlight color .