Synchronized code relies simple kind reentrant lock . This kind lock easy use , many limitation . More sophisticated locking idiom support java.util.concurrent.locks package . We wo n't examine package detail , instead focus basic interface , Lock . Lock object work much like implicit lock use synchronized code . As implicit lock , one thread Lock object time . Lock object also support wait/notify mechanism , associate Condition object . The big advantage Lock object implicit lock ability back attempt acquire lock . The tryLock method back lock available immediately timeout expire ( specify ) . The lockInterruptibly method back another thread send interrupt lock acquire . Let 's use Lock object solve deadlock problem saw Liveness . Alphonse Gaston train notice friend bow . We model improvement require Friend object must acquire lock participant proceed bow . Here source code improved model , Safelock . To demonstrate versatility idiom , assume Alphonse Gaston infatuated newfound ability bow safely ca n't stop bow : import java.util.concurrent.locks.Lock ; import java.util.concurrent.locks.ReentrantLock ; import java.util.Random ; public class Safelock { static class Friend { private final String name ; private final Lock lock = new ReentrantLock ( ) ; public Friend ( String name ) { this.name = name ; } public String getName ( ) { return this.name ; } public boolean impendingBow ( Friend bower ) { Boolean myLock = false ; Boolean yourLock = false ; try { myLock = lock.tryLock ( ) ; yourLock = bower.lock.tryLock ( ) ; } finally { ( ! ( myLock & & yourLock ) ) { ( myLock ) { lock.unlock ( ) ; } ( yourLock ) { bower.lock.unlock ( ) ; } } } return myLock & & yourLock ; } public void bow ( Friend bower ) { ( impendingBow ( bower ) ) { try { System.out.format ( `` % : % '' + `` bow ! % n '' , this.name , bower.getName ( ) ) ; bower.bowBack ( ) ; } finally { lock.unlock ( ) ; bower.lock.unlock ( ) ; } } else { System.out.format ( `` % : % start '' + `` bow , saw '' + `` I already bow '' + `` him. % n '' , this.name , bower.getName ( ) ) ; } } public void bowBack ( Friend bower ) { System.out.format ( `` % : % '' + `` bow back ! % n '' , this.name , bower.getName ( ) ) ; } } static class BowLoop implement Runnable { private Friend bower ; private Friend bowee ; public BowLoop ( Friend bower , Friend bowee ) { this.bower = bower ; this.bowee = bowee ; } public void run ( ) { Random random = new Random ( ) ; ( ; ; ) { try { Thread.sleep ( random.nextInt ( 10 ) ) ; } catch ( InterruptedException e ) { } bowee.bow ( bower ) ; } } } public static void main ( String [ ] args ) { final Friend alphonse = new Friend ( `` Alphonse '' ) ; final Friend gaston = new Friend ( `` Gaston '' ) ; new Thread ( new BowLoop ( alphonse , gaston ) ) .start ( ) ; new Thread ( new BowLoop ( gaston , alphonse ) ) .start ( ) ; } }