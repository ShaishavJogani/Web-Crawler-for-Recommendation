In real-life application , want use SAX parser process XML data something useful . This section examine example JAXP program , SAXLocalNameCount , count number element use localName component element , XML document . Namespace name ignore simplicity . This example also show use SAX ErrorHandler . Note - After download instal source JAXP API JAXP download area , sample program example find directory install-dir/jaxp-1_4_2-release-date/samples/sax . The XML file interact find install-dir/jaxp-1_4_2-release-date/samples/data . Creating Skeleton The SAXLocalNameCount program create file name SAXLocalNameCount.java . public class SAXLocalNameCount { static public void main ( String [ ] args ) { // ... } } Because run standalone , need main ( ) method . And need command-line argument tell application file process . Importing Classes The import statement class application use following . package sax ; import javax.xml.parsers . * ; import org.xml.sax . * ; import org.xml.sax.helpers . * ; import java.util . * ; import java.io . * ; public class SAXLocalNameCount { // ... } The javax.xml.parsers package contain SAXParserFactory class create parser instance use . It throw ParserConfigurationException produce parser match specified configuration option . ( Later , see configuration option ) . The javax.xml.parsers package also contain SAXParser class , factory return parsing . The org.xml.sax package define interface use SAX parser . The org.xml.sax.helpers package contain DefaultHandler , define class handle SAX event parser generates . The class java.util java.io , need provide hash table output . Setting Up I/O The first order business process command-line argument , stage serve get name file process . The following code main method tell application file want SAXLocalNameCountMethod process . static public void main ( String [ ] args ) throw Exception { String filename = null ; ( int = 0 ; < args.length ; i++ ) { filename = args [ ] ; ( ! = args.length - 1 ) { usage ( ) ; } } ( filename == null ) { usage ( ) ; } } This code set main method throw Exception encounter problem , define command-line option require tell application name XML file process . Other command line argument part code examine later lesson , start look validation . The filename String give run application convert java.io.File URL internal method , convertToFileURL ( ) . This following code SAXLocalNameCountMethod . public class SAXLocalNameCount { private static String convertToFileURL ( String filename ) { String path = new File ( filename ) .getAbsolutePath ( ) ; ( File.separatorChar ! = '/ ' ) { path = path.replace ( File.separatorChar , '/ ' ) ; } ( ! path.startsWith ( `` / '' ) ) { path = `` / '' + path ; } return `` file : '' + path ; } // ... } If incorrect command-line argument specify program run , SAXLocalNameCount application 's usage ( ) method invoke , print correct option onscreen . private static void usage ( ) { System.err.println ( `` Usage : SAXLocalNameCount < file.xml > '' ) ; System.err.println ( `` -usage -help = message '' ) ; System.exit ( 1 ) ; } Further usage ( ) option examine later lesson , validation address . Implementing ContentHandler Interface The important interface SAXLocalNameCount ContentHandler . This interface require number method SAX parser invokes response various parse event . The major event-handling method : startDocument , endDocument , startElement , endElement . The easy way implement interface extend DefaultHandler class , define org.xml.sax.helpers package . That class provide do-nothing method ContentHandler event . The example program extend class . public class SAXLocalNameCount extend DefaultHandler { // ... } Note - DefaultHandler also define do-nothing method major event , define DTDHandler , EntityResolver , ErrorHandler interface . You learn method later lesson . Each method require interface throw SAXException . An exception thrown send back parser , send code invoke parser . Handling Content Events This section show code process ContentHandler event . When start tag end tag encounter , name tag pass String startElement endElement method , appropriate . When start tag encounter , attribute defines also pass Attributes list . Characters find within element pass array character , along number character ( length ) offset array point first character . Document Events The following code handle start-document end-document event : public class SAXLocalNameCount extend DefaultHandler { private Hashtable tag ; public void startDocument ( ) throw SAXException { tag = new Hashtable ( ) ; } public void endDocument ( ) throw SAXException { Enumeration e = tags.keys ( ) ; ( e.hasMoreElements ( ) ) { String tag = ( String ) e.nextElement ( ) ; int count = ( ( Integer ) tags.get ( tag ) ) .intValue ( ) ; System.out.println ( `` Local Name \ '' '' + tag + `` \ '' occur `` + count + `` time '' ) ; } } private static String convertToFileURL ( String filename ) { // ... } // ... } This code define application parser encounter start end point document parse . The ContentHandler interface 's startDocument ( ) method create java.util.Hashtable instance , Element Events populate XML elements parser find document . When parser reach end document , endDocument ( ) method invoke , get name count element contain hash table , print message onscreen tell user many incidence element find . Both ContentHandler method throw SAXExceptions . You learn SAX exception Setting Error Handling . Element Events As mention Document Events , hash table create startDocument method need populate various element parser find document . The following code process start-element end-element event : public void startDocument ( ) throw SAXException { tag = new Hashtable ( ) ; } public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throw SAXException { String key = localName ; Object value = tags.get ( key ) ; ( value == null ) { tags.put ( key , new Integer ( 1 ) ) ; } else { int count = ( ( Integer ) value ) .intValue ( ) ; count++ ; tags.put ( key , new Integer ( count ) ) ; } } public void endDocument ( ) throw SAXException { // ... } This code process element tag , include attribute define start tag , obtain namespace universal resource identifier ( URI ) , local name qualified name element . The startElement ( ) method populate hash map create startDocument ( ) local name count thereof , type element . Note startElement ( ) method invoke , namespace processing enable , local name element attribute could turn empty string . The code handle case use qualified name whenever simple name empty string . Character Events The JAXP SAX API also allow handle character parser delivers application , use ContentHandler.characters ( ) method . Note - Character event demonstrate SAXLocalNameCount example , brief description include section , completeness . Parsers require return particular number character one time . A parser return anything single character time several thousand still standard-conforming implementation . So application need process character see , wise character ( ) method accumulate character java.lang.StringBuffer operate sure find . You finish parse text element end , normally perform character processing point . But might also want process text element start . This necessary document-style data , contain XML element intermix text . For example , consider document fragment : < para > This paragraph contain < bold > important < /bold > ideas. < /para > The initial text , This paragraph contain , terminate start < bold > element . The text important terminate end tag , < /bold > , final text , ideas. , terminate end tag , < /para > . To strictly accurate , character handler scan ampersand character ( & ) left-angle bracket character ( < ) replace string & amp ; & lt ; , appropriate . This explain next section . Handling Special Characters In XML , entity XML structure ( plain text ) name . Referencing entity name cause insert document place entity reference . To create entity reference , surround entity name ampersand semicolon : & entityName ; When handle large block XML HTML include many special character , use CDATA section . A CDATA section work like < code > ... < /code > HTML , : white space CDATA section significant , character interpret XML . A CDATA section start < ! [ [ CDATA [ end ] ] > . An example CDATA section , take sample XML file install-dir/jaxp-1_4_2-release-date/samples/data/REC-xml-19980210.xml , show . < p > < termdef id= '' dt-cdsection '' term= '' CDATA Section '' < < term > CDATA section < /term > may occur anywhere character data may occur ; use escape block text containing character would otherwise recognize markup . CDATA section begin string `` < code > & lt ; ! [ CDATA [ < /code > '' end string `` < code > ] ] & gt ; < /code > '' Once parse , text would display follow : CDATA section may occur anywhere character data may occur ; use escape block text containing character would otherwise recognize markup . CDATA section begin string `` < ! [ CDATA [ `` end string `` ] ] > '' . The existence CDATA make proper echoing XML bit tricky . If text output CDATA section , angle bracket , ampersand , special character text replace appropriate entity reference . ( Replacing leave angle bracket ampersand important , character interpret properly without mislead parser . ) But output text CDATA section , substitution occur , result text like early example . In simple program SAXLocalNameCount application , particularly serious . But many XML-filtering application want keep track whether text appear CDATA section , treat special character properly . Setting Parser The following code set parser get start : static public void main ( String [ ] args ) throw Exception { // Code parse command-line argument // ( show ) // ... SAXParserFactory spf = SAXParserFactory.newInstance ( ) ; spf.setNamespaceAware ( true ) ; SAXParser saxParser = spf.newSAXParser ( ) ; } These line code create SAXParserFactory instance , determine setting javax.xml.parsers.SAXParserFactory system property . The factory create set support XML namespaces set setNamespaceAware true , SAXParser instance obtain factory invoke newSAXParser ( ) method . Note - The javax.xml.parsers.SAXParser class wrapper define number convenience method . It wrap ( somewhat less friendly ) org.xml.sax.Parser object . If need , obtain parser use getParser ( ) method SAXParser class . You need implement XMLReader parser must implement . The XMLReader use application tell SAX parser process perform document question . The XMLReader implement following code main method . // ... SAXParser saxParser = spf.newSAXParser ( ) ; XMLReader xmlReader = saxParser.getXMLReader ( ) ; xmlReader.setContentHandler ( new SAXLocalNameCount ( ) ) ; xmlReader.parse ( convertToFileURL ( filename ) ) ; Here , obtain XMLReader instance parser invoke SAXParser instance 's getXMLReader ( ) method . The XMLReader register SAXLocalNameCount class content handler , action perform parser startDocument ( ) , startElement ( ) , endDocument ( ) method show Handling Content Events . Finally , XMLReader tell parser document parse pass location XML file question , form File URL generate convertToFileURL ( ) method define Setting Up I/O . Setting Error Handling You could start use parser , safe implement error handling . The parser generate three kind error : fatal error , error , warning . When fatal error occur , parser continue . So application generate exception , default error-event handler generate one . But nonfatal error warning , exception never generate default error handler , message display . As show Document Events , application 's event handle method throw SAXException . For example , signature startDocument ( ) method ContentHandler interface define return SAXException . public void startDocument ( ) throw SAXException { /* ... */ } A SAXException construct use message , another exception , . Because default parser generates exception fatal error , information error provide default parser somewhat limited , SAXLocalNameCount program define error handling , MyErrorHandler class . xmlReader.setErrorHandler ( new MyErrorHandler ( System.err ) ) ; // ... private static class MyErrorHandler implement ErrorHandler { private PrintStream ; MyErrorHandler ( PrintStream ) { this.out = ; } private String getParseExceptionInfo ( SAXParseException spe ) { String systemId = spe.getSystemId ( ) ; ( systemId == null ) { systemId = `` null '' ; } String info = `` URI= '' + systemId + `` Line= '' + spe.getLineNumber ( ) + `` : `` + spe.getMessage ( ) ; return info ; } public void warning ( SAXParseException spe ) throw SAXException { out.println ( `` Warning : `` + getParseExceptionInfo ( spe ) ) ; } public void error ( SAXParseException spe ) throw SAXException { String message = `` Error : `` + getParseExceptionInfo ( spe ) ; throw new SAXException ( message ) ; } public void fatalError ( SAXParseException spe ) throw SAXException { String message = `` Fatal Error : `` + getParseExceptionInfo ( spe ) ; throw new SAXException ( message ) ; } } In way Setting Parser , show XMLReader point correct content handler , XMLReader point new error handler call setErrorHandler ( ) method . The MyErrorHandler class implement standard org.xml.sax.ErrorHandler interface , define method obtain exception information provide SAXParseException instance generate parser . This method , getParseExceptionInfo ( ) , simply obtain line number error occur XML document identifier system run call standard SAXParseException method getLineNumber ( ) getSystemId ( ) . This exception information feed implementation basic SAX error handle method error ( ) , warn ( ) , fatalError ( ) , update send appropriate message nature location error document . Handling NonFatal Errors A nonfatal error occur XML document fail validity constraint . If parser find document valid , error event generate . Such error generate validate parser , give document type definition ( DTD ) schema , document invalid tag , tag find allow , ( case schema ) element contain invalid data . The important principle understand nonfatal error ignore default . But validation error occur document , probably want continue process . You probably want treat error fatal . To take error handling , override DefaultHandler method handle fatal error , nonfatal error , warning part ErrorHandler interface . As show code extract previous section , SAX parser deliver SAXParseException method , generate exception error occur simple throw back . Note - It instructive examine error-handling method define org.xml.sax.helpers.DefaultHandler . You see error ( ) warn ( ) method nothing , whereas fatalError ( ) throw exception . Of course , could always override fatalError ( ) method throw different exception . But code throw exception fatal error occur , SAX parser . The XML specification require . Handling Warnings Warnings , , ignore default . Warnings informative generate presence DTD schema . For example , element define twice DTD , warning generate . It illegal , cause problem , something might like know might intentional . Validating XML document DTD show section . Running SAX Parser Example without Validation As state beginning lesson , download instal source JAXP API JAXP source download area , sample program associated file need run find following location . The different Java archive ( JAR ) file example locate directory install-dir/jaxp-1_4_2-release-date/lib . The SAXLocalNameCount.java file find install-dir/jaxp-1_4_2-release-date/samples/sax . The XML file SAXLocalNameCount interact find install-dir/jaxp-1_4_2-release-date/samples/data . The following step explain run SAX parser example without validation . To Run SAXLocalNameCount Example without Validation Navigate sample directory. % cd install-dir/jaxp-1_4_2-release-date/samples . Compile example class. % javac sax/* Run SAXLocalNameCount program XML file . Choose one XML file data directory run SAXLocalNameCount program . Here , choose run program file rich_iii.xml . % java sax/SAXLocalNameCount data/rich_iii.xml The XML file rich_iii.xml contain XML version William Shakespeare 's play Richard III . When run SAXLocalNameCount , see following output . Local Name `` STAGEDIR '' occur 230 time Local Name `` PERSONA '' occur 39 time Local Name `` SPEECH '' occurs 1089 time Local Name `` SCENE '' occur 25 time Local Name `` ACT '' occur 5 time Local Name `` PGROUP '' occur 4 time Local Name `` PLAY '' occur 1 time Local Name `` PLAYSUBT '' occur 1 time Local Name `` FM '' occur 1 time Local Name `` SPEAKER '' occur 1091 time Local Name `` TITLE '' occur 32 time Local Name `` GRPDESCR '' occur 4 time Local Name `` P '' occur 4 time Local Name `` SCNDESCR '' occur 1 time Local Name `` PERSONAE '' occur 1 time Local Name `` LINE '' occurs 3696 time The SAXLocalNameCount program parse XML file , provide count number instance type XML tag contain . Open file data/rich_iii.xml text editor . To check error handling work , delete closing tag entry XML file , example closing tag < /PERSONA > , line 30 , show . 30 < PERSONA > EDWARD , Prince Wales , afterwards King Edward V. < /PERSONA > Run SAXLocalNameCount . This time , see following fatal error message . % java sax/SAXLocalNameCount data/rich_iii.xml Exception thread `` main '' org.xml.sax.SAXException : Fatal Error : URI=file : install-dir /JAXP_sources/jaxp-1_4_2-release-date/samples/data/rich_iii.xml Line=30 : The element type `` PERSONA '' must terminate matching end-tag `` < /PERSONA > '' . As see , error encounter , parser generate SAXParseException , subclass SAXException identify file location error occur .