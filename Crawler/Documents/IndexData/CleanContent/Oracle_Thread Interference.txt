Consider simple class call Counter class Counter { private int c = 0 ; public void increment ( ) { c++ ; } public void decrement ( ) { c -- ; } public int value ( ) { return c ; } } Counter design invocation increment add 1 c , invocation decrement subtract 1 c. However , Counter object reference multiple thread , interference thread may prevent happen expect . Interference happen two operation , run different thread , act data , interleave . This mean two operation consist multiple step , sequence step overlap . It might seem possible operation instance Counter interleave , since operation c single , simple statement . However , even simple statement translate multiple step virtual machine . We wo n't examine specific step virtual machine take â€” enough know single expression c++ decompose three step : Retrieve current value c. Increment retrieve value 1 . Store incremented value back c. The expression c -- decompose way , except second step decrement instead increment . Suppose Thread A invokes increment time Thread B invoke decrement . If initial value c 0 , interleaved action might follow sequence : Thread A : Retrieve c. Thread B : Retrieve c. Thread A : Increment retrieve value ; result 1 . Thread B : Decrement retrieve value ; result -1 . Thread A : Store result c ; c 1 . Thread B : Store result c ; c -1 . Thread A 's result lose , overwrite Thread B . This particular interleaving one possibility . Under different circumstance might Thread B 's result get lose , could error . Because unpredictable , thread interference bug difficult detect fix .