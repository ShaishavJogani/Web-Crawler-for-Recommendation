Capturing refers process obtain signal outside computer . A common application audio capture record , record microphone input sound file . However , capturing n't synonymous recording , record implies application always save sound data 's come . An application capture audio n't necessarily store audio . Instead might something data 's come — transcribe speech text — discard buffer audio soon 's finish buffer . As discuss Overview Sampled Package , typical audio-input system implementation Java Sound API consist : An input port , microphone port line-in port , feed incoming audio data : A mixer , place input data : One target data line , application retrieve data . Commonly , one input port open time , audio-input mixer mixes audio multiple port also possible . Another scenario consist mixer port instead get audio input network . The TargetDataLine interface introduce briefly The Line Interface Hierarchy . TargetDataLine directly analogous SourceDataLine interface , discuss extensively Playing Back Audio . Recall SourceDataLine interface consist : A write method send audio mixer An available method determine much data write buffer without block Similarly , TargetDataLine consist : A read method get audio mixer An available method determine much data read buffer without block Setting Up TargetDataLine The process obtain target data line describe Accessing Audio System Resources repeat convenience : TargetDataLine line ; DataLine.Info info = new DataLine.Info ( TargetDataLine.class , format ) ; // format AudioFormat object ( ! AudioSystem.isLineSupported ( info ) ) { // Handle error ... } // Obtain open line . try { line = ( TargetDataLine ) AudioSystem.getLine ( info ) ; line.open ( format ) ; } catch ( LineUnavailableException ex ) { // Handle error ... } You could instead invoke Mixer 's getLine method , rather AudioSystem 's . As show example , 've obtain target data line , reserve application 's use invoke SourceDataLine method open , exactly describe case source data line Playing Back Audio . The single-parameter version open method cause line 's buffer default size . You instead set buffer size accord application 's need invoke two-parameter version : void open ( AudioFormat format , int bufferSize ) Reading Data TargetDataLine Once line open , ready start capture data , n't active yet . To actually commence audio capture , use DataLine method start . This begin deliver input audio data line 's buffer application read . Your application invoke start 's ready begin read line ; otherwise lot processing waste fill capture buffer , overflow ( , discard data ) . To start retrieve data buffer , invoke TargetDataLine 's read method : int read ( byte [ ] b , int offset , int length ) This method attempt read length byte data array b , start byte position offset array . The method return number byte actually read . As SourceDataLine 's write method , request data actually fit buffer , method block requested amount data deliver , even request many buffer ' worth data . To avoid application hang recording , invoke read method within loop , 've retrieve audio input , example : // Assume TargetDataLine , line , already // obtain open . ByteArrayOutputStream = new ByteArrayOutputStream ( ) ; int numBytesRead ; byte [ ] data = new byte [ line.getBufferSize ( ) / 5 ] ; // Begin audio capture . line.start ( ) ; // Here , stop global boolean set another thread . ( ! stop ) { // Read next chunk data TargetDataLine . numBytesRead = line.read ( data , 0 , data.length ) ; // Save chunk data . out.write ( data , 0 , numBytesRead ) ; } Notice example , size byte array data read set one-fifth size line 's buffer . If instead make big line 's buffer try read entire buffer , need exact timing , data dump mixer need deliver data line read . By use fraction line 's buffer size , show , application successful share access line 's buffer mixer . The read method TargetDataLine take three argument : byte array , offset array , number byte input data would like read . In example , third argument simply length byte array . The read method return number byte actually read array . Typically , read data line loop , example . Within loop , chunk retrieve data process whatever way appropriate applicationâhere , 's write ByteArrayOutputStream . Not show use separate thread set boolean stop , terminate loop . This boolean 's value might set true user click Stop button , also listener receive CLOSE STOP event line . The listener necessary CLOSE event recommend STOP event . Otherwise , line get stop somehow without stop set true , loop capture zero byte iteration , run fast waste CPU cycle . A thorough code example would show loop re-entered capture become active . As source data line , 's possible drain flush target data line . For example , 're record input file , 'll probably want invoke drain method user click Stop button . The drain method cause mixer 's remain data get deliver target data line 's buffer . If n't drain data , capture sound might seem truncate prematurely end . There might case instead want flush data . In case , neither flush drain data , leave mixer . This mean capture recommences , leftover sound beginning new recording , might undesirable . It useful , , flush target data line restart capture . Monitoring Line 's Status Because TargetDataLine interface extend DataLine , target data line generate event way source data line . You register object receive event whenever target data line open , close , start , stop . For information , see previous discussion Monitoring Line 's Status . Processing Incoming Audio Like source data line , mixer ' target data line signal-processing control , gain , pan , reverb , sample-rate control . The input port might similar control , especially gain control . In next section , 'll learn determine whether line control , use .