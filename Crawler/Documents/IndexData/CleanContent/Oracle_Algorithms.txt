The polymorphic algorithm describe piece reusable functionality provide Java platform . All come Collections class , take form static method whose first argument collection operation perform . The great majority algorithm provide Java platform operate List instance , operate arbitrary Collection instance . This section briefly describe following algorithm : Sorting Shuffling Routine Data Manipulation Searching Composition Finding Extreme Values Sorting The sort algorithm reorder List element ascend order accord order relationship . Two form operation provide . The simple form take List sort accord element ' natural ordering . If 're unfamiliar concept natural ordering , read Object Ordering section . The sort operation use slightly optimize merge sort algorithm fast stable : Fast : It guarantee run n log ( n ) time run substantially faster nearly sort list . Empirical test show fast highly optimized quicksort . A quicksort generally consider fast merge sort n't stable n't guarantee n log ( n ) performance . Stable : It n't reorder equal element . This important sort list repeatedly different attribute . If user mail program sort inbox mail date sort sender , user naturally expect now-contiguous list message give sender ( still ) sort mail date . This guarantee second sort stable . The following trivial program print argument lexicographic ( alphabetical ) order . import java.util . * ; public class Sort { public static void main ( String [ ] args ) { List < String > list = Arrays.asList ( args ) ; Collections.sort ( list ) ; System.out.println ( list ) ; } } Let 's run program . % java Sort walk line The following output produce . [ , line , , walk ] The program include show algorithms really easy use appear . The second form sort take Comparator addition List sort element Comparator . Suppose want print anagram group early example reverse order size — large anagram group first . The example follow show achieve help second form sort method . Recall anagram group store value Map , form List instance . The revise printing code iterate Map 's value view , put every List pass minimum-size test List Lists . Then code sort List , use Comparator expect List instance , implement reverse size-ordering . Finally , code iterate sorted List , print element ( anagram group ) . The following code replace printing code end main method Anagrams example . // Make List anagram group size threshold . List < List < String > > winner = new ArrayList < List < String > > ( ) ; ( List < String > l : m.values ( ) ) ( l.size ( ) > = minGroupSize ) winners.add ( l ) ; // Sort anagram group accord size Collections.sort ( winner , new Comparator < List < String > > ( ) { public int compare ( List < String > o1 , List < String > o2 ) { return o2.size ( ) - o1.size ( ) ; } } ) ; // Print anagram group . ( List < String > l : winner ) System.out.println ( l.size ( ) + `` : `` + l ) ; Running program dictionary The Map Interface section , minimum anagram group size ( eight ) , produce following output . 12 : [ aper , apres , asper , pares , parse , pear , prase , presa , rape , reaps , spare , spear ] 11 : [ alert , alters , artels , estral , laster , ratel , salter , slater , staler , stelar , talers ] 10 : [ least , setal , slate , stale , steal , stela , tael , tale , teal , tesla ] 9 : [ estrin , inerts , insert , inters , niter , nitre , sinter , triens , trine ] 9 : [ caper , crape , escarp , pacer , parsec , recap , scrape , secpar , spacer ] 9 : [ palest , palets , pastel , petal , plate , pleat , septal , staple , tepal ] 9 : [ anestri , antsier , nasty , ratines , retains , retina , retsina , stainer , stearin ] 8 : [ lapse , leap , pale , peal , plea , salep , sepal , spale ] 8 : [ asper , par , passer , prases , repass , spare , sparse , spear ] 8 : [ enters , nester , renest , rente , resent , tenser , ternes , ï¿½ï¿½treens ] 8 : [ arles , earl , lares , laser , lear , rale , real , seral ] 8 : [ earings , erase , gainer , reagin , regains , regina , sear , seringa ] 8 : [ peri , pier , pry , prise , ripes , speir , spier , spire ] 8 : [ ate , east , eats , eta , sate , seat , seta , teas ] 8 : [ caret , carte , caster , caters , crate , reacts , recast , ï¿½ï¿½traces ] Shuffling The shuffle algorithm opposite sort , destroy trace order may present List . That , algorithm reorder List base input source randomness possible permutation occur equal likelihood , assume fair source randomness . This algorithm useful implement game chance . For example , could use shuffle List Card object represent deck . Also , 's useful generate test case . This operation two form : one take List use default source randomness , require caller provide Random object use source randomness . The code algorithm use example List section . Routine Data Manipulation The Collections class provide five algorithm routine data manipulation List object , pretty straightforward : reverse — reverse order element List . fill — overwrite every element List specify value . This operation useful reinitializing List . copy — take two argument , destination List source List , copy element source destination , overwrite content . The destination List must least long source . If longer , remain element destination List unaffected . swap — swap element specified position List . addAll — add specified element Collection . The element add may specify individually array . Searching The binarySearch algorithm search specified element sorted List . This algorithm two form . The first take List element search ( `` search key '' ) . This form assume List sort ascend order accord natural ordering element . The second form take Comparator addition List search key , assume List sort ascend order accord specify Comparator . The sort algorithm use sort List prior call binarySearch . The return value form . If List contain search key , index return . If , return value ( - ( insertion point ) - 1 ) , insertion point point value would insert List , index first element great value list.size ( ) element List less specified value . This admittedly ugly formula guarantee return value > = 0 search key find . It 's basically hack combine boolean ( find ) integer ( index ) single int return value . The following idiom , usable form binarySearch operation , look specify search key insert appropriate position 's already present . int po = Collections.binarySearch ( list , key ) ; ( pos < 0 ) l.add ( -pos-1 , key ) ; Composition The frequency disjoint algorithms test aspect composition one Collections : frequency — count number time specified element occur specified collection disjoint — determine whether two Collections disjoint ; , whether contain element common Finding Extreme Values The min max algorithms return , respectively , minimum maximum element contain specified Collection . Both operation come two form . The simple form take Collection return minimum ( maximum ) element accord element ' natural ordering . The second form take Comparator addition Collection return minimum ( maximum ) element accord specify Comparator .