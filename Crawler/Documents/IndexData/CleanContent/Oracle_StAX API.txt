The StAX API expose method iterative , event-based processing XML document . XML document treat filtered series event , infoset state store procedural fashion . Moreover , unlike SAX , StAX API bidirectional , enable reading writing XML document . The StAX API really two distinct API set : cursor API iterator API . These two API set explain great detail later lesson , main feature briefly describe . Cursor API As name implies , StAX cursor API represent cursor walk XML document begin end . This cursor point one thing time , always move forward , never backward , usually one infoset element time . The two main cursor interface XMLStreamReader XMLStreamWriter . XMLStreamReader include accessor method possible information retrievable XML Information model , include document encoding , element name , attribute , namespaces , text node , start tag , comment , process instruction , document boundary , forth ; example : public interface XMLStreamReader { public int next ( ) throw XMLStreamException ; public boolean hasNext ( ) throw XMLStreamException ; public String getText ( ) ; public String getLocalName ( ) ; public String getNamespaceURI ( ) ; // ... method show } You call method XMLStreamReader , getText getName , get data current cursor location . XMLStreamWriter provide method correspond StartElement EndElement event type ; example : public interface XMLStreamWriter { public void writeStartElement ( String localName ) throw XMLStreamException ; public void writeEndElement ( ) throw XMLStreamException ; public void writeCharacters ( String text ) throw XMLStreamException ; // ... method show } The cursor API mirror SAX many way . For example , method available directly access string character information , integer index use access attribute namespace information . As SAX , cursor API method return XML information string , minimize object allocation requirement . Iterator API The StAX iterator API represent XML document stream set discrete event object . These event pull application provide parser order read source XML document . The base iterator interface call XMLEvent , subinterfaces event type list XMLEvent table . The primary parser interface read iterator event XMLEventReader , primary interface write iterator event XMLEventWriter . The XMLEventReader interface contain five method , important nextEvent , return next event XML stream . XMLEventReader implement java.util.Iterator , mean return XMLEventReader cache pass routine work standard Java Iterator ; example : public interface XMLEventReader extend Iterator { public XMLEvent nextEvent ( ) throw XMLStreamException ; public boolean hasNext ( ) ; public XMLEvent peek ( ) throw XMLStreamException ; // ... } Similarly , output side iterator API , : public interface XMLEventWriter { public void flush ( ) throw XMLStreamException ; public void close ( ) throw XMLStreamException ; public void add ( XMLEvent e ) throw XMLStreamException ; public void add ( Attribute attribute ) throw XMLStreamException ; // ... } Iterator Event Types XMLEvent Types Defined Event Iterator API Event Type Description StartDocument Reports beginning set XML event , include encoding , XML version , standalone property . StartElement Reports start element , include attribute namespace declaration ; also provide access prefix , namespace URI , local name start tag . EndElement Reports end tag element . Namespaces go scope recall explicitly set corresponding StartElement . Characters Corresponds XML CData section CharacterData entity . Note ignorable white space significant white space also report Character event . EntityReference Character entity report discrete event , application developer choose resolve pass unresolved . By default , entity resolve . Alternatively , want report entity event , replacement text substitute report Characters . ProcessingInstruction Reports target data underlying processing instruction . Comment Returns text comment . EndDocument Reports end set XML event . DTD Reports java.lang.String information DTD , , associate stream , provide method return custom object find DTD . Attribute Attributes generally report part StartElement event . However , time desirable return attribute standalone Attribute event ; example , namespace return result XQuery XPath expression . Namespace As attribute , namespaces usually report part StartElement , time desirable report namespace discrete Namespace event . Note DTD , EntityDeclaration , EntityReference , NotationDeclaration , ProcessingInstruction event create document process contain DTD . Example Event Mapping As example event iterator API map XML stream , consider following XML document : < ? xml version= '' 1.0 '' ? > < BookCatalogue xmlns= '' http : //www.publishing.org '' > < Book > < Title > Yogasana Vijnana : Science Yoga < /Title > < ISBN > 81-40-34319-4 < /ISBN > < Cost currency= '' INR '' > 11.50 < /Cost > < /Book > < /BookCatalogue > This document would parse eighteen primary secondary event , show following table . Note secondary event , show curly brace ( { } ) , typically access primary event rather directly . Example Iterator API Event Mapping # Element/Attribute Event 1 version= '' 1.0 '' StartDocument 2 isCData = false data = `` \n '' IsWhiteSpace = true Characters 3 qname = BookCatalogue : http : //www.publishing.org attribute = null namespaces = { BookCatalogue '' - > http : //www.publishing.org '' } StartElement 4 qname = Book attribute = null namespaces = null StartElement 5 qname = Title attribute = null namespaces = null StartElement 6 isCData = false data = `` Yogasana Vijnana : Science Yoga\n\t '' IsWhiteSpace = false Characters 7 qname = Title namespaces = null EndElement 8 qname = ISBN attribute = null namespaces = null StartElement 9 isCData = false data = `` 81-40-34319-4\n\t '' IsWhiteSpace = false Characters 10 qname = ISBN namespaces = null EndElement 11 qname = Cost attribute = { `` currency '' - > INR } namespaces = null StartElement 12 isCData = false data = `` 11.50\n\t '' IsWhiteSpace = false Characters 13 qname = Cost namespaces = null EndElement 14 isCData = false data = `` \n '' IsWhiteSpace = true Characters 15 qname = Book namespaces = null EndElement 16 isCData = false data = `` \n '' IsWhiteSpace = true Characters 17 qname = BookCatalogue : http : //www.publishing.org namespaces = { BookCatalogue '' - > http : //www.publishing.org '' } EndElement 18 EndDocument There several important thing note example : The event create order corresponding XML element encounter document , include nesting element , open closing element , attribute order , document start document end , forth . As proper XML syntax , container element correspond start end event ; example , every StartElement corresponding EndElement , even empty element . Attribute event treat secondary event , access corresponding StartElement event . Similar Attribute event , Namespace event treat secondary , appear twice accessible twice event stream , first corresponding StartElement corresponding EndElement . Character event specify element , even element character data . Similarly , Character event split across event . The StAX parser maintain namespace stack , hold information XML namespaces define current element ancestor . The namespace stack , expose javax.xml.namespace.NamespaceContext interface , access namespace prefix URI . Choosing Cursor Iterator APIs It reasonable ask point , “ What API I choose ? Should I create instance XMLStreamReader XMLEventReader ? Why two kind APIs anyway ? ” Development Goals The author StAX specification target three type developer : Library infrastructure developer : Create application server , JAXM , JAXB , JAX-RPC similar implementation ; need highly efficient , low-level APIs minimal extensibility requirement . Java ME developer : Need small , simple , pull-parsing library , minimal extensibility need . Java Platform , Enterprise Edition ( Java EE ) Java Platform , Standard Edition ( Java SE ) developer : Need clean , efficient pull-parsing library , plus need flexibility read write XML stream , create new event type , extend XML document element attribute . Given wide-ranging development category , StAX author felt useful define two small , efficient APIs rather overload one large necessarily complex API . Comparing Cursor Iterator APIs Before choose cursor iterator APIs , note thing iterator API cursor API : Objects create XMLEvent subclass immutable , use array , list , map , pass application even parser move subsequent event . You create subtypes XMLEvent either completely new information item extension exist item additional method . You add remove event XML event stream much simpler way cursor API . Similarly , keep general recommendation mind make choice : If program particularly memory-constrained environment , like Java ME , make small , efficient code cursor API . If performance high priority—for example , create low-level library infrastructure—the cursor API efficient . If want create XML process pipeline , use iterator API . If want modify event stream , use iterator API . If want application able handle pluggable processing event stream , use iterator API . In general , strong preference one way , use iterator API recommend flexible extensible , thereby “ future-proofing ” application .