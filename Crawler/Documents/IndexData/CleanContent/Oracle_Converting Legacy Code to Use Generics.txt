Earlier , show new legacy code interoperate . Now , 's time look harder problem `` generifying '' old code . If decide convert old code use generic , need think carefully modify API . You need make certain generic API unduly restrictive ; must continue support original contract API . Consider example java.util.Collection . The pre-generic API look like : interface Collection { public boolean containsAll ( Collection c ) ; public boolean addAll ( Collection c ) ; } A naive attempt generify would following : interface Collection < E > { public boolean containsAll ( Collection < E > c ) ; public boolean addAll ( Collection < E > c ) ; } While certainly type safe , n't live API 's original contract . The containsAll ( ) method work kind incoming collection . It succeed incoming collection really contain instance E , : The static type incoming collection might differ , perhaps caller n't know precise type collection pass , perhaps Collection < S > , S subtype E. It 's perfectly legitimate call containsAll ( ) collection different type . The routine work , return false . In case addAll ( ) , able add collection consist instance subtype E. We saw handle situation correctly section Generic Methods . You also need ensure revise API retain binary compatibility old client . This imply erasure API must original , ungenerified API . In case , fall naturally , subtle case . We 'll examine one subtle case 've encounter , method Collections.max ( ) . As saw section More Fun Wildcards , plausible signature max ( ) : public static < T extend Comparable < ? super T > > T max ( Collection < T > coll ) This fine , except erasure signature : public static Comparable max ( Collection coll ) different original signature max ( ) : public static Object max ( Collection coll ) One could certainly specify signature max ( ) , , old binary class file call Collections.max ( ) depend signature return Object . We force erasure different , explicitly specify superclass bound formal type parameter T. public static < T extend Object & Comparable < ? super T > > T max ( Collection < T > coll ) This example give multiple bound type parameter , use syntax T1 & T2 ... & Tn . A type variable multiple bound know subtype type list bound . When multiple bound use , first type mention bound use erasure type variable . Finally , recall max read input collection , applicable collection subtype T. This bring u actual signature use JDK : public static < T extend Object & Comparable < ? super T > > T max ( Collection < ? extends T > coll ) It 's rare anything involved come practice , expert library designer prepare think carefully convert exist APIs . Another issue watch covariant return , , refine return type method subclass . You take advantage feature old API . To see , let 's look example . Assume original API form : public class Foo { // Factory . Should create instance // whatever class declare . public Foo create ( ) { ... } } public class Bar extend Foo { // Actually create Bar . public Foo create ( ) { ... } } Taking advantage covariant return , modify : public class Foo { // Factory . Should create instance // whatever class declare . public Foo create ( ) { ... } } public class Bar extend Foo { // Actually create Bar . public Bar create ( ) { ... } } Now , assume third party client code write following : public class Baz extend Bar { // Actually create Baz . public Foo create ( ) { ... } } The Java virtual machine directly support override method different return type . This feature support compiler . Consequently , unless class Baz recompiled , properly override create ( ) method Bar . Furthermore , Baz modify , since code reject write -- return type create ( ) Baz subtype return type create ( ) Bar .