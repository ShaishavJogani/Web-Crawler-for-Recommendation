A class may declare one modifier affect runtime behavior : Access modifier : public , protect , private Modifier require override : abstract Modifier restrict one instance : static Modifier prohibit value modification : final Modifier force strict float point behavior : strictfp Annotations Not modifier allow class , example interface final enum abstract . java.lang.reflect.Modifier contains declaration possible modifier . It also contain method may use decode set modifier return Class.getModifiers ( ) . The ClassDeclarationSpy example show obtain declaration component class include modifier , generic type parameter , implement interface , inheritance path . Since Class implement java.lang.reflect.AnnotatedElement interface also possible query runtime annotation . import java.lang.annotation.Annotation ; import java.lang.reflect.Modifier ; import java.lang.reflect.Type ; import java.lang.reflect.TypeVariable ; import java.util.Arrays ; import java.util.ArrayList ; import java.util.List ; import static java.lang.System.out ; public class ClassDeclarationSpy { public static void main ( String ... args ) { try { Class < ? > c = Class.forName ( args [ 0 ] ) ; out.format ( `` Class : % n % % n % n '' , c.getCanonicalName ( ) ) ; out.format ( `` Modifiers : % n % % n % n '' , Modifier.toString ( c.getModifiers ( ) ) ) ; out.format ( `` Type Parameters : % n '' ) ; TypeVariable [ ] tv = c.getTypeParameters ( ) ; ( tv.length ! = 0 ) { out.format ( `` `` ) ; ( TypeVariable : tv ) out.format ( `` % `` , t.getName ( ) ) ; out.format ( `` % n % n '' ) ; } else { out.format ( `` -- No Type Parameters -- % n % n '' ) ; } out.format ( `` Implemented Interfaces : % n '' ) ; Type [ ] intfs = c.getGenericInterfaces ( ) ; ( intfs.length ! = 0 ) { ( Type intf : intfs ) out.format ( `` % % n '' , intf.toString ( ) ) ; out.format ( `` % n '' ) ; } else { out.format ( `` -- No Implemented Interfaces -- % n % n '' ) ; } out.format ( `` Inheritance Path : % n '' ) ; List < Class > l = new ArrayList < Class > ( ) ; printAncestor ( c , l ) ; ( l.size ( ) ! = 0 ) { ( Class < ? > cl : l ) out.format ( `` % % n '' , cl.getCanonicalName ( ) ) ; out.format ( `` % n '' ) ; } else { out.format ( `` -- No Super Classes -- % n % n '' ) ; } out.format ( `` Annotations : % n '' ) ; Annotation [ ] ann = c.getAnnotations ( ) ; ( ann.length ! = 0 ) { ( Annotation : ann ) out.format ( `` % % n '' , a.toString ( ) ) ; out.format ( `` % n '' ) ; } else { out.format ( `` -- No Annotations -- % n % n '' ) ; } // production code handle exception gracefully } catch ( ClassNotFoundException x ) { x.printStackTrace ( ) ; } } private static void printAncestor ( Class < ? > c , List < Class > l ) { Class < ? > ancestor = c.getSuperclass ( ) ; ( ancestor ! = null ) { l.add ( ancestor ) ; printAncestor ( ancestor , l ) ; } } } A sample output follow . User input italic . $ java ClassDeclarationSpy java.util.concurrent.ConcurrentNavigableMap Class : java.util.concurrent.ConcurrentNavigableMap Modifiers : public abstract interface Type Parameters : K V Implemented Interfaces : java.util.concurrent.ConcurrentMap < K , V > java.util.NavigableMap < K , V > Inheritance Path : -- No Super Classes -- Annotations : -- No Annotations -- This actual declaration java.util.concurrent.ConcurrentNavigableMap source code : public interface ConcurrentNavigableMap < K , V > extend ConcurrentMap < K , V > , NavigableMap < K , V > Note since interface , implicitly abstract . The compiler add modifier every interface . Also , declaration contain two generic type parameter , K V. The example code simply print name parameter , possible retrieve additional information use method java.lang.reflect.TypeVariable . Interfaces may also implement interface show . $ java ClassDeclarationSpy `` [ Ljava.lang.String ; '' Class : java.lang.String [ ] Modifiers : public abstract final Type Parameters : -- No Type Parameters -- Implemented Interfaces : interface java.lang.Cloneable interface java.io.Serializable Inheritance Path : java.lang.Object Annotations : -- No Annotations -- Since array runtime object , type information define Java virtual machine . In particular , arrays implement Cloneable java.io.Serializable direct superclass always Object . $ java ClassDeclarationSpy java.io.InterruptedIOException Class : java.io.InterruptedIOException Modifiers : public Type Parameters : -- No Type Parameters -- Implemented Interfaces : -- No Implemented Interfaces -- Inheritance Path : java.io.IOException java.lang.Exception java.lang.Throwable java.lang.Object Annotations : -- No Annotations -- From inheritance path , may deduce java.io.InterruptedIOException checked exception RuntimeException present . $ java ClassDeclarationSpy java.security.Identity Class : java.security.Identity Modifiers : public abstract Type Parameters : -- No Type Parameters -- Implemented Interfaces : interface java.security.Principal interface java.io.Serializable Inheritance Path : java.lang.Object Annotations : @ java.lang.Deprecated ( ) This output show java.security.Identity , deprecated API , possess annotation java.lang.Deprecated . This may use reflective code detect deprecated APIs . Note : Not annotation available via reflection . Only java.lang.annotation.RetentionPolicy RUNTIME accessible . Of three annotation pre-defined language @ Deprecated , @ Override , @ SuppressWarnings @ Deprecated available runtime .