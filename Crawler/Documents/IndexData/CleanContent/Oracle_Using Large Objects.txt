An important feature Blob , Clob , NClob Java object manipulate without bring data database server client computer . Some implementation represent instance type locator ( logical pointer ) object database instance represent . Because BLOB , CLOB , NCLOB SQL object may large , use locator make performance significantly faster . However , implementation fully materialize large object client computer . If want bring data BLOB , CLOB , NCLOB SQL value client computer , use method Blob , Clob , NClob Java interface provide purpose . These large object type object materialize data object represent stream . The following topic cover : Adding Large Object Type Objects Databases Retrieving CLOB Values Adding Retrieving BLOB Objects Releasing Resources Held Large Objects Adding Large Object Type Object Database The following excerpt ClobSample.addRowToCoffeeDescriptions add CLOB SQL value table COFFEE_DESCRIPTIONS . The Clob Java object myClob contain content file specify fileName . public void addRowToCoffeeDescriptions ( String coffeeName , String fileName ) throw SQLException { PreparedStatement pstmt = null ; try { Clob myClob = this.con.createClob ( ) ; Writer clobWriter = myClob.setCharacterStream ( 1 ) ; String str = this.readFile ( fileName , clobWriter ) ; System.out.println ( `` Wrote following : `` + clobWriter.toString ( ) ) ; ( this.settings.dbms.equals ( `` mysql '' ) ) { System.out.println ( `` MySQL , set String Clob `` + `` object setString method '' ) ; myClob.setString ( 1 , str ) ; } System.out.println ( `` Length Clob : `` + myClob.length ( ) ) ; String sql = `` INSERT INTO COFFEE_DESCRIPTIONS `` + `` VALUES ( ? , ? ) '' ; pstmt = this.con.prepareStatement ( sql ) ; pstmt.setString ( 1 , coffeeName ) ; pstmt.setClob ( 2 , myClob ) ; pstmt.executeUpdate ( ) ; } catch ( SQLException sqlex ) { JDBCTutorialUtilities.printSQLException ( sqlex ) ; } catch ( Exception ex ) { System.out.println ( `` Unexpected exception : `` + ex.toString ( ) ) ; } finally { ( pstmt ! = null ) pstmt.close ( ) ; } } The following line create Clob Java object : Clob myClob = this.con.createClob ( ) ; The following line retrieve stream ( case Writer object name clobWriter ) use write stream character Clob Java object myClob . The method ClobSample.readFile write stream character ; stream file specify String fileName . The method argument 1 indicate Writer object start write stream character beginning Clob value : Writer clobWriter = myClob.setCharacterStream ( 1 ) ; The ClobSample.readFile method read file line-by-line specify file fileName write Writer object specify writerArg : private String readFile ( String fileName , Writer writerArg ) throw FileNotFoundException , IOException { BufferedReader br = new BufferedReader ( new FileReader ( fileName ) ) ; String nextLine = `` '' ; StringBuffer sb = new StringBuffer ( ) ; ( ( nextLine = br.readLine ( ) ) ! = null ) { System.out.println ( `` Writing : `` + nextLine ) ; writerArg.write ( nextLine ) ; sb.append ( nextLine ) ; } // Convert content string String clobData = sb.toString ( ) ; // Return data . return clobData ; } The following excerpt create PreparedStatement object pstmt insert Clob Java object myClob COFFEE_DESCRIPTIONS : PreparedStatement pstmt = null ; // ... String sql = `` INSERT INTO COFFEE_DESCRIPTIONS VALUES ( ? , ? ) '' ; pstmt = this.con.prepareStatement ( sql ) ; pstmt.setString ( 1 , coffeeName ) ; pstmt.setClob ( 2 , myClob ) ; pstmt.executeUpdate ( ) ; Retrieving CLOB Values The method ClobSample.retrieveExcerpt retrieve CLOB SQL value store COF_DESC column COFFEE_DESCRIPTIONS row whose column value COF_NAME equal String value specify coffeeName parameter : public String retrieveExcerpt ( String coffeeName , int numChar ) throw SQLException { String description = null ; Clob myClob = null ; PreparedStatement pstmt = null ; try { String sql = `` select COF_DESC `` + `` COFFEE_DESCRIPTIONS `` + `` COF_NAME = ? `` ; pstmt = this.con.prepareStatement ( sql ) ; pstmt.setString ( 1 , coffeeName ) ; ResultSet rs = pstmt.executeQuery ( ) ; ( rs.next ( ) ) { myClob = rs.getClob ( 1 ) ; System.out.println ( `` Length retrieve Clob : `` + myClob.length ( ) ) ; } description = myClob.getSubString ( 1 , numChar ) ; } catch ( SQLException sqlex ) { JDBCTutorialUtilities.printSQLException ( sqlex ) ; } catch ( Exception ex ) { System.out.println ( `` Unexpected exception : `` + ex.toString ( ) ) ; } finally { ( pstmt ! = null ) pstmt.close ( ) ; } return description ; } The following line retrieve Clob Java value ResultSet object r : myClob = rs.getClob ( 1 ) ; The following line retrieve substring myClob object . The substring begin first character value myClob number consecutive character specify numChar , numChar integer . description = myClob.getSubString ( 1 , numChar ) ; Adding Retrieving BLOB Objects Adding retrieve BLOB SQL object similar add retrieve CLOB SQL object . Use Blob.setBinaryStream method retrieve OutputStream object write BLOB SQL value Blob Java object ( call method ) represent . Releasing Resources Held Large Objects Blob , Clob , NClob Java object remain valid least duration transaction create . This could potentially result application run resource long running transaction . Applications may release Blob , Clob , NClob resource invoke free method . In following excerpt , method Clob.free call release resource hold previously create Clob object : Clob aClob = con.createClob ( ) ; int numWritten = aClob.setString ( 1 , val ) ; aClob.free ( ) ;