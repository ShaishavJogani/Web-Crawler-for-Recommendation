As know , Java Sound API include two package , javax.sound.sampled.spi javax.sound.midi.spi , define abstract class use developer sound service . By implement instal subclass one abstract class , service provider register new service , extend functionality runtime system . This page tell go use javax.sound.sampled.spi package provide new service handle sampled audio . There four abstract class javax.sound.sampled.spi package , represent four different type service provide sampled-audio system : AudioFileWriter provide sound file-writing service . These service make possible application program write stream audio data file particular type . AudioFileReader provide file-reading service . These service enable application program ascertain sound file 's characteristic , obtain stream file 's audio data read . FormatConversionProvider provide service convert audio data format . These service allow application program translate audio stream one data format another . MixerProvider provide management particular kind mixer . This mechanism allow application program obtain information , access instance , give kind mixer . To recapitulate early discussion , service provider extend functionality runtime system . A typical SPI class two type method : one respond query type service available particular provider , one either perform new service directly , return instance object actually provide service . The runtime environment 's service-provider mechanism provide registration installed service audio system , management new service provider class . In essence double isolation service instance application developer . An application program never directly create instance service object , mixer format converter , need audio processing task . Nor program even directly request object SPI class administer . The application program make request AudioSystem object javax.sound.sampled package , AudioSystem turn use SPI object process query service request . The existence new audio service might completely transparent user application programmer . All application reference standard object javax.sound.sampled package , primarily AudioSystem , special handling new service might provide often completely hidden . In discussion , 'll continue previous convention refer new SPI subclass name like AcmeMixer AcmeMixerProvider . Providing Audio File-Writing Services Let 's start AudioFileWriter , one simpler SPI class . A subclass implement method AudioFileWriter must provide implementation set method handle query file format file type support class , well provide method actually write supplied audio data stream File OutputStream . AudioFileWriter include two method concrete implementation base class : boolean isFileTypeSupported ( AudioFileFormat.Type fileType ) boolean isFileTypeSupported ( AudioFileFormat.Type fileType , AudioInputStream stream ) The first method inform caller whether file writer write sound file specify type . This method general inquiry , return true file writer write kind file , assume file writer hand appropriate audio data . However , ability write file depend format specific audio data 's hand file writer . A file writer might support every audio data format , constraint might impose file format . ( Not kind audio data write kind sound file . ) The second method specific , , ask whether particular AudioInputStream write particular type file . Generally , wo n't need override two concrete method . Each simply wrapper invoke one two query method iterate result return . These two query method abstract therefore need implement subclass : abstract AudioFileFormat.Type [ ] getAudioFileTypes ( ) abstract AudioFileFormat.Type [ ] getAudioFileTypes ( AudioInputStream stream ) These method correspond directly previous two . Each return array support file types-all support general , case first method , support specific audio stream , case second method . A typical implementation first method might simply return array file writer 's constructor initializes . An implementation second method might test stream 's AudioFormat object see whether 's data format requested type file support . The final two method AudioFileWriter actual file-writing work : abstract int write ( AudioInputStream stream , AudioFileFormat.Type fileType , java.io.File ) abstract int write ( AudioInputStream stream , AudioFileFormat.Type fileType , java.io.OutputStream ) These method write stream byte represent audio data stream file specify third argument . The detail depend structure specified type file . The write method must write file 's header audio data manner prescribe sound file format ( whether 's standard type sound file new , possibly proprietary one ) . Providing Audio File-Reading Services The AudioFileReader class consist six abstract method subclass need implement-actually , two different overload method , take File , URL , InputStream argument . The first overload method accepts query file format specify file : abstract AudioFileFormat getAudioFileFormat ( java.io.File file ) abstract AudioFileFormat getAudioFileFormat ( java.io.InputStream stream ) abstract AudioFileFormat getAudioFileFormat ( java.net.URL url ) A typical implementation getAudioFileFormat method read parse sound file 's header ascertain file format . See description AudioFileFormat class see field need read header , refer specification particular file type figure parse header . Because caller provide stream argument method expect stream unaltered method , file reader generally start mark stream . After read end header , reset stream original position . The overloaded AudioFileReader method provide file-reading service , return AudioInputStream file 's audio data read : abstract AudioInputStream getAudioInputStream ( java.io.File file ) abstract AudioInputStream getAudioInputStream ( java.io.InputStream stream ) abstract AudioInputStream getAudioInputStream ( java.net.URL url ) Typically , implementation getAudioInputStream return AudioInputStream wound beginning file 's data chunk ( header ) , ready reading . It would conceivable , though , file reader return AudioInputStream whose audio format represent stream data way decode contain file . The important thing method return formatted stream audio data contain file read . The AudioFormat encapsulate returned AudioInputStream object inform caller stream 's data format , usually , necessarily , data format file . Generally , returned stream instance AudioInputStream ; 's unlikely would ever need subclass AudioInputStream . Providing Format-Conversion Services A FormatConversionProvider subclass transform AudioInputStream one audio data format one another format . The former ( input ) stream refer source stream , latter ( output ) stream refer target stream . Recall AudioInputStream contain AudioFormat , AudioFormat turn contain particular type data encode , represent AudioFormat.Encoding object . The format encoding source stream call source format source encoding , target stream likewise call target format target encoding . The work conversion perform overloaded abstract method FormatConversionProvider call getAudioInputStream . The class also abstract query method learn support target source format encoding . There concrete wrapper method query specific conversion . The two variant getAudioInputStream : abstract AudioInputStream getAudioInputStream ( AudioFormat.Encoding targetEncoding , AudioInputStream sourceStream ) abstract AudioInputStream getAudioInputStream ( AudioFormat targetFormat , AudioInputStream sourceStream ) These differ first argument , accord whether caller specify complete target format format 's encoding . A typical implementation getAudioInputStream work return new subclass AudioInputStream wrap around original ( source ) AudioInputStream apply data format conversion data whenever read method invoke . For example , consider case new FormatConversionProvider subclass call AcmeCodec , work new AudioInputStream subclass call AcmeCodecStream . The implementation AcmeCodec 's second getAudioInputStream method might : public AudioInputStream getAudioInputStream ( AudioFormat outputFormat , AudioInputStream stream ) { AudioInputStream c = null ; AudioFormat inputFormat = stream.getFormat ( ) ; ( inputFormat.matches ( outputFormat ) ) { cs = stream ; } else { c = ( AudioInputStream ) ( new AcmeCodecStream ( stream , outputFormat ) ) ; tempBuffer = new byte [ tempBufferSize ] ; } return c ; } The actual format conversion take place new read method returned AcmeCodecStream , subclass AudioInputStream . Again , application program access return AcmeCodecStream simply operate AudioInputStream , n't need know detail implementation . The method FormatConversionProvider permit query input output encoding format object support . The following four method , abstract , need implement : abstract AudioFormat.Encoding [ ] getSourceEncodings ( ) abstract AudioFormat.Encoding [ ] getTargetEncodings ( ) abstract AudioFormat.Encoding [ ] getTargetEncodings ( AudioFormat sourceFormat ) abstract AudioFormat [ ] getTargetFormats ( AudioFormat.Encoding targetEncoding , AudioFormat sourceFormat ) As query method AudioFileReader class discuss , query typically handle check private data object , latter two method , compare argument ( ) . The remain four FormatConversionProvider method concrete generally n't need overridden : boolean isConversionSupported ( AudioFormat.Encoding targetEncoding , AudioFormat sourceFormat ) boolean isConversionSupported ( AudioFormat targetFormat , AudioFormat sourceFormat ) boolean isSourceEncodingSupported ( AudioFormat.Encoding sourceEncoding ) boolean isTargetEncodingSupported ( AudioFormat.Encoding targetEncoding ) As AudioFileWriter.isFileTypeSupported ( ) , default implementation method essentially wrapper invoke one query method iterate result return . Providing New Types Mixers As name implies , MixerProvider supply instance mixer . Each concrete MixerProvider subclass act factory Mixer object use application program . Of course , define new MixerProvider make sense one new implementation Mixer interface also define . As FormatConversionProvider example , getAudioInputStream method return subclass AudioInputStream perform conversion , new class AcmeMixerProvider method getMixer return instance another new class implement Mixer interface . We 'll call latter class AcmeMixer . Particularly mixer implement hardware , provider might support one static instance requested device . If , return static instance response invocation getMixer . Since AcmeMixer support Mixer interface , application program n't require additional information access basic functionality . However , AcmeMixer support functionality define Mixer interface , vendor want make extended functionality accessible application program , mixer course define public class additional , well-documented public method , program wish make use extended functionality import AcmeMixer cast object return getMixer type . The two method MixerProvider : abstract Mixer.Info [ ] getMixerInfo ( ) boolean isMixerSupported ( Mixer.Info info ) These method allow audio system determine whether particular provider class produce device application program need . In word , AudioSystem object iterate installed MixerProviders see one , , supply device application program request AudioSystem . The getMixerInfo method return array object contain information kind mixer available provider object . The system pass information object , along provider , application program . A single MixerProvider provide one kind mixer . When system invoke MixerProvider 's getMixerInfo method , get list information object identify different kind mixer provider support . The system invoke MixerProvider.getMixer ( Mixer.Info ) obtain mixer interest . Your subclass need implement getMixerInfo , 's abstract . The isMixerSupported method concrete n't generally need overridden . The default implementation simply compare provided Mixer.Info one array return getMixerInfo .