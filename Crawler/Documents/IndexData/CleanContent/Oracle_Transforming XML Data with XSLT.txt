The Extensible Stylesheet Language Transformations ( XSLT ) APIs use many purpose . For example , sufficiently intelligent stylesheet , could generate PDF PostScript output XML data . But generally , XSLT use generate formatted HTML output , create alternative XML representation data . In section , XSLT transform use translate XML input data HTML output . Note - The XSLT specification large complex , tutorial scratch surface . It give little background understand simple XSLT processing task , examine detail write XSLT transform , rather concentrate use JAXP 's XSLT transform API . For thorough grounding XSLT , consult good reference manual , Michael Kay 's XSLT 2.0 XPath 2.0 : Programmer 's Reference ( Wrox , 2008 ) . Defining Simple Document Type Start define simple document type use write article . Our article document contain structure tag : < TITLE > : The title article < SECT > : A section , consist heading body < PARA > : A paragraph < LIST > : A list < ITEM > : An entry list < NOTE > : An aside , offset main text The slightly unusual aspect structure create separate element tag section heading . Such element commonly create distinguish heading text ( tag contain ) body section ( , structure elements underneath heading ) . Instead , allow heading merge seamlessly body section . That arrangement add complexity stylesheet , give u chance explore XSLT 's template-selection mechanism . It also match intuitive expectation document structure , text heading follow directly structure element , arrangement simplify outline-oriented editing . Note - This kind structure easily validate , XML 's mixed-content model allow text anywhere section , whereas want confine text inline element appear first structure element body section . The assertion-based validator , schema mechanism . So dispense define DTD document type . In structure , section nest . The depth nesting determine kind HTML format use section heading ( example , h1 h2 ) . Using plain SECT tag ( instead numbered section ) also useful outline-oriented editing , let move section around without worry change number affected section . For list , use type attribute specify whether list entry unordered ( bulleted ) , alpha ( enumerate lowercase letter ) , ALPHA ( enumerate uppercase letter ) , number . We also allow inline tag change appearance text . < B > : Bold < I > : Italics < U > : Underline < DEF > : Definition < LINK > : Link URL Note - An inline tag generate line break , style change cause inline tag affect flow text page ( although affect appearance text ) . A structure tag , hand , demarcate new segment text , minimum always generate line break addition format change . The < DEF > tag use term define text . Such term display italic , way ordinarily document . But use special tag XML allow index program find definition add index , along keywords heading . In preceding Note , example , definition inline tag structure tag could mark < DEF > tag future indexing . Finally , LINK tag serve two purpose . First , let u create link URL without put URL twice ; code < link > http// ... < /link > instead < href= '' http// ... '' > http// ... < /a > . Of course , also want allow form look like < link target= '' ... '' > ... name ... < /link > . That lead second reason < link > tag . It give u opportunity play conditional expression XSLT . Note - Although article structure exceedingly simple ( consist eleven tag ) , raise enough interesting problem give u good view XSLT 's basic capability . But still leave large area specification untouched . In What Else Can XSLT Do ? , point major feature skip . Creating Test Document Here , create simple test document use nested < SECT > element , < PARA > element , < NOTE > element , < LINK > , < LIST type= '' unordered '' > . The idea create document one everything explore interesting translation mechanism . Note - The code discuss section article1.xml , find xslt/data directory unzip XSLT example install-dir/jaxp-1_4_2-release-date/samples directory . To make test document , create file call article.xml enter following XML data . < ? xml version= '' 1.0 '' ? > < ARTICLE > < TITLE > A Sample Article < /TITLE > < SECT > The First Major Section < PARA > This section introduce subsection. < /PARA > < SECT > The Subsection Heading < PARA > This text subsection . < /PARA > < /SECT > < /SECT > < /ARTICLE > Note XML file , subsection totally contain within major section . ( In HTML , hand , heading contain body section ) . The result outline structure hard edit plain text form , like , much easy edit outline-oriented editor . Someday , give tree-oriented XML editor understand inline tag < B > < I > , possible edit article kind outline form , without require complicated stylesheet . ( Such editor would allow writer focus structure article , leave layout much later process ) . In editor , article fragment would look something like : < ARTICLE > < TITLE > A Sample Article < SECT > The First Major Section < PARA > This section introduce subsection . < SECT > The Subheading < PARA > This text subsection . Note ... Note - At moment , tree-structured editor exist , treat inline tag < B > < I > way treat structure tag , make `` outline '' bit difficult read . Writing XSLT Transform Now time begin write XSLT transform convert XML article render HTML . Note - The code discuss section article1a.xsl , find xslt/data directory unzip XSLT example install-dir/jaxp-1_4_2-release-date/samples directory . Start create normal XML document : < ? xml version= '' 1.0 '' encoding= '' ISO-8859-1 '' ? > Then add following highlighted line create XSL stylesheet : < ? xml version= '' 1.0 '' encoding= '' ISO-8859-1 '' ? > < xsl : stylesheet xmlns : xsl= `` http : //www.w3.org/1999/XSL/Transform '' version= '' 1.0 '' > < /xsl : stylesheet > Now set produce HTML-compatible output . < xsl : stylesheet [ ... ] > < xsl : output method= '' html '' / > [ ... ] < /xsl : stylesheet > We get detailed reason entry later section . For , note want output anything well-formed XML , need < xsl : output > tag like one show , specify either text html . ( The default value xml ) . Note - When specify XML output , add indent attribute produce nicely indented XML output . The specification look like : < xsl : output method= '' xml '' indent= '' yes '' / > . Processing Basic Structure Elements You start filling stylesheet process element go create table content : root element , title element , heading . You also process PARA element define test document . Note - If first reading skip section discuss XPath address mechanism , How XPath Works , good time go back review section . Begin add main instruction process root element : < xsl : template match= '' / '' > < html > < body > < xsl : apply-templates/ > < /body > < /html > < /xsl : template > < /xsl : stylesheet > The new XSL command show bold . ( Note define xsl namespace ) . The instruction < xsl : apply-templates > process child current node . In case , current node root node . Despite simplicity , example illustrate number important idea , worth understand thoroughly . The first concept stylesheet contain number template , define < xsl : template > tag . Each template contain match attribute , use XPath address mechanism describe How XPath Works select element template apply . Within template , tag start xsl : namespace prefix simply copy . The newlines whitespace follow also copy , help make result output readable . Note - When newline present , whitespace generally ignore . To include whitespace output case , include text , use < xsl : text > tag . Basically , XSLT stylesheet expect process tag . So everything see need either < xsl : .. > tag , tag , whitespace . In case , non-XSL tag HTML tag . So root tag match , XSLT output HTML start tag , process template apply child root , output HTML end tag . Process < TITLE > Element Next , add template process article title : < xsl : template match= '' /ARTICLE/TITLE '' > < h1 align= '' center '' > < xsl : apply-templates/ > < /h1 > < /xsl : template > < /xsl : stylesheet > In case , specify complete path TITLE element output HTML make text title large , center heading . In case , apply-templates tag ensure title contain inline tag italic , link , underline , also process . More importantly , apply-templates instruction cause text title process . Like DOM data model , XSLT data model base concept text node contain element node ( , turn , contain element node , ) . That hierarchical structure constitute source tree . There also result tree , contain output . XSLT work transform source tree result tree . To visualize result XSLT operation , helpful understand structure tree , content . ( For subject , see XSLT/XPath Data Model ) . Process Headings To continue process basic structure element , add template process top-level heading : < xsl : template match= `` /ARTICLE/SECT '' > < h2 > < xsl : apply-templates select= '' text ( ) |B|I|U|DEF|LINK '' / > < /h2 > < xsl : apply-templates select= `` SECT|PARA|LIST|NOTE '' / > < /xsl : template > < /xsl : stylesheet > Here , specify path topmost SECT element . But time , apply template two stage use select attribute . For first stage , select text node , well inline tag bold italic , use XPath text ( ) function . ( The vertical pipe ( | ) use match multiple item : text bold tag italics tag , etc ) . In second stage , select structure element contain file , section , paragraph , list , note . Using select attribute let put text inline element < h2 > ... < /h2 > tag , make sure structure tag section process afterward . In word , make sure nesting heading XML document reflect HTML formatting , distinction important HTML output . In general , use select clause let apply template subset information available current context . As another example , template select attribute current node : < xsl : apply-templates select= '' @ * '' / > < /attributes > Next , add virtually identical template process subheading nested one level deeper : < xsl : template match= `` /ARTICLE/SECT/SECT '' > < h3 > < xsl : apply-templates select= '' text ( ) |B|I|U|DEF|LINK '' / > < /h3 > < xsl : apply-templates select= `` SECT|PARA|LIST|NOTE '' / > < /xsl : template > < /xsl : stylesheet > Generate Runtime Message You could add template deep heading , , point must stop , HTML go five level . For example , stop two level section heading . But XML input happen contain third level , want deliver error message user . This section show . Note - We could continue process SECT element far , select expression /SECT/SECT//SECT . The // select SECT element , depth , define XPath addressing mechanism . But instead take opportunity play messaging . Add following template generate error section encounter nest deep : < xsl : template match= `` /ARTICLE/SECT/SECT/SECT '' > < xsl : message terminate= '' yes '' > Error : Sections nest 2 deep . < /xsl : message > < /xsl : template > < /xsl : stylesheet > The terminate= '' yes '' clause cause transformation process stop message generate . Without , processing could still go , everything section ignore . As additional exercise , could expand stylesheet handle section nest four section deep , generate < h2 > ... < h5 > tag . Generate error section nest five level deep . Finally , finish stylesheet add template process PARA tag : < xsl : template match= '' PARA '' > < p > < xsl : apply-templates/ > < /p > < /xsl : template > < /xsl : stylesheet > Writing Basic Program Now modify program use XSLT echo XML file unchanged , change use stylesheet . Note - The code discuss section Stylizer.java , find xslt directory unzip XSLT example install-dir/jaxp-1_4_2-release-date/samples directory . The result stylizer1a.html , find xslt/data . The Stylizer example adapt TransformationApp02 , parse XML file write System.out . The main difference two program describe . Firstly , Stylizer use stylesheet create Transformer object . // ... import javax.xml.transform.dom.DOMSource ; import javax.xml.transform.stream.StreamSource ; import javax.xml.transform.stream.StreamResult ; // ... public class Stylizer { // ... public static void main ( String argv [ ] ) { // ... try { File stylesheet = new File ( argv [ 0 ] ) ; File datafile = new File ( argv [ 1 ] ) ; DocumentBuilder builder = factory.newDocumentBuilder ( ) ; document = builder.parse ( datafile ) ; // ... StreamSource stylesource = new StreamSource ( stylesheet ) ; Transformer transformer = Factory.newTransformer ( stylesource ) ; } } } This code use file create StreamSource object pass source object factory class get transformer . Note - You simplify code somewhat eliminate DOMSource class . Instead create DOMSource object XML file , create StreamSource object , well stylesheet . Running Stylizer Sample Navigate sample directory . % cd install-dir/jaxp-1_4_2-release-date/samples . Download XSLT example click link unzip install-dir/jaxp-1_4_2-release-date/samples directory . Navigate xslt directory . cd xslt Compile Stylizer sample . Type following command : % javac Stylizer.java Run Stylizer sample article1.xml use stylesheet article1a.xsl . % java Stylizer data/article1a.xsl data/article1.xml You see following output : < html > < body > < h1 align= '' center '' > A Sample Article < /h1 > < h2 > The First Major Section < /h2 > < p > This section introduce subsection. < /p > < h3 > The Subsection Heading < /h3 > < p > This text subsection . < /p > < /body > < /html > At point , quite bit excess whitespace output . In next section , see eliminate . Trimming Whitespace Recall look structure DOM , many text node contain nothing ignorable whitespace . Most excess whitespace output come node . Fortunately , XSL give way eliminate . ( For node structure , see XSLT/XPath Data Model ) . Note - The stylesheet discuss section article1b.xsl , find xslt/data directory unzip XSLT example install-dir/jaxp-1_4_2-release-date/samples directory . The result stylizer1b.html , find xslt/data . To remove excess whitespace , add following highlighted line stylesheet . < xsl : stylesheet ... > < xsl : output method= '' html '' / > < xsl : strip-space elements= '' SECT '' / > [ ... ] This instruction tell XSL remove text node SECT elements contain nothing whitespace . Nodes contain text whitespace affect , kind node . Running Stylizer Sample Trimmed Whitespace Navigate sample directory . % cd install-dir/jaxp-1_4_2-release-date/samples . Download XSLT example click link unzip install-dir/jaxp-1_4_2-release-date/samples directory . Navigate xslt directory . cd xslt Compile Stylizer sample . Type following command : % javac Stylizer.java Run Stylizer sample article1.xml use stylesheet article1b.xsl . % java Stylizer data/article1b.xsl data/article1.xml You see following output : < html > < body > < h1 align= '' center '' > A Sample Article < /h1 > < h2 > The First Major Section < /h2 > < p > This section introduce subsection. < /p > < h3 > The Subsection Heading < /h3 > < p > This text subsection . < /p > < /body > < /html > That quite improvement . There still newline character whitespace heading , come way XML write : < SECT > The First Major Section ____ < PARA > This section introduce subsection. < /PARA > ^^^^ Here , see section head end newline indentation space , PARA entry start . That big worry , browser process HTML compress ignore excess space routinely . But still one formatting tool disposal . Removing Last Whitespace Note - The stylesheet discuss section article1c.xsl , find xslt/data directory unzip XSLT example install-dir/jaxp-1_4_2-release-date/samples directory . The result stylizer1c.html , find xslt/data . That last little bit whitespace dispose add follow stylesheet : < xsl : template match= '' text ( ) '' > < xsl : value-of select= '' normalize-space ( ) '' / > < /xsl : template > < /xsl : stylesheet > Running Stylizer stylesheet remove remain whitespace . Running Stylizer Sample All Whitespace Trimmed Navigate sample directory . % cd install-dir/jaxp-1_4_2-release-date/samples . Download XSLT example click link unzip install-dir/jaxp-1_4_2-release-date/samples directory . Navigate xslt directory . cd xslt Compile Stylizer sample . Type following command : % javac Stylizer.java Run Stylizer sample article1.xml use stylesheet article1c.xsl . % java Stylizer data/article1c.xsl data/article1.xml The output look like : < html > < body > < h1 align= '' center '' > A Sample Article < /h1 > < h2 > The First Major Section < /h2 > < p > This section introduce subsection . < /p > < h3 > The Subsection Heading < /h3 > < p > This text subsection . < /p > < /body > < /html > That quite bit well . Of course , would nicer indent , turn somewhat hard expect . Here possible avenue attack , along difficulty : Indent option Unfortunately , indent= '' yes '' option apply XML output available HTML output . Even option available , would help , HTML element rarely nested ! Although HTML source frequently indent show implied structure , HTML tag nest way create real structure . Indent variables The < xsl : text > function let add text want , include whitespace . So could conceivably use output indentation space . The problem vary amount indentation space . XSLT variable seem like good idea , work . The reason assign value variable template , value know within template ( statically , compile time ) . Even variable define globally , assigned value store way let dynamically know template runtime . When < apply-templates/ > invoke template , template unaware variable setting make elsewhere . Parameterized template Using parameterized template another way modify template 's behavior . But determine amount indentation space pass parameter remain crux problem . At moment , , appear good way control indentation HTML format output . That would inconvenient need display edit HTML plain text . But problem edit XML form , use HTML version display browser . ( When view stylizer1c.html , example , see result expect ) . Processing Remaining Structure Elements In section , process LIST NOTE element , add structure article . Note - The sample document describe section article2.xml , stylesheet use manipulate article2.xsl . The result stylizer2.html . These file find xslt/data directory unzip XSLT example install-dir/jaxp-1_4_2-release-date/samples directory . Start add test data sample document : < ? xml version= '' 1.0 '' ? > < ARTICLE > < TITLE > A Sample Article < /TITLE > < SECT > The First Major Section ... < /SECT > < SECT > The Second Major Section < PARA > This section add LIST NOTE . < PARA > Here LIST : < LIST type= '' order '' > < ITEM > Pears < /ITEM > < ITEM > Grapes < /ITEM > < /LIST > < /PARA > < PARA > And NOTE : < NOTE > Do n't forget go hardware store way grocery ! < /NOTE > < /PARA > < /SECT > < /ARTICLE > Note - Although list note XML file contain respective paragraph , really make difference whether contain ; generate HTML either way . But contain make easy deal outline-oriented editor . Modify < PARA > Handling Next , modify PARA template account fact allow structure elements embed paragraph : < xsl : template match= '' PARA '' > < p > < xsl : apply-templates select= `` text ( ) |B|I|U|DEF|LINK '' / > < /p > < xsl : apply-templates select= `` PARA|LIST|NOTE '' / > < /xsl : template > This modification use technique use section heading . The difference SECT element expect within paragraph . ( However , paragraph could easily exist inside another paragraph-for example , quote material ) . Process < LIST > < ITEM > Elements Now 're ready add template process LIST element : < xsl : template match= '' LIST '' > < xsl : test= '' @ type='ordered ' '' > < ol > < xsl : apply-templates/ > < /ol > < /xsl : > < xsl : test= '' @ type='unordered ' '' > < ul > < xsl : apply-templates/ > < /ul > < /xsl : > < /xsl : template > < /xsl : stylesheet > The < xsl : > tag use test= '' '' attribute specify Boolean condition . In case , value type attribute test , list generate change depend whether value order unordered . Note two important thing example : There else clause , return exit statement , take two < xsl : > tag cover two option . ( Or < xsl : choose > tag could use , provide case-statement functionality ) . Single quote require around attribute value . Otherwise , XSLT processor attempt interpret word order XPath function instead string . Now finish LIST processing handle ITEM element : < xsl : template match= '' ITEM '' > < li > < xsl : apply-templates/ > < /li > < /xsl : template > < /xsl : stylesheet > Ordering Templates Stylesheet By , idea template independent one another , generally matter occur file . So point , show template need add . ( For sake comparison , 're always add end example stylesheet ) . Order make difference two template apply node . In case , one define last one find process . For example , change ordering indented list use lowercase alphabetics , could specify template pattern look like : //LIST//LIST . In template , would use HTML option generate alphabetic enumeration , instead numeric one . But element could also identify pattern //LIST . To make sure proper processing , template specify //LIST would appear template specify //LIST//LIST . Process < NOTE > Elements The last remaining structure element NOTE element . Add following template handle . < xsl : template match= '' NOTE '' > < blockquote > < b > Note : < /b > < br/ > < xsl : apply-templates/ > < /p > < /blockquote > < /xsl : template > < /xsl : stylesheet > This code bring interesting issue result inclusion < br/ > tag . For file well-formed XML , tag must specify stylesheet < br/ > , tag recognize many browser . And although browser recognize sequence < br > < /br > , treat like paragraph break instead single line break . In word , transformation must generate < br > tag , stylesheet must specify < br/ > . That bring u major reason special output tag add early stylesheet : < xsl : stylesheet ... > < xsl : output method= '' html '' / > [ ... ] < /xsl : stylesheet > That output specification convert empty tag < br/ > HTML form , < br > , output . That conversion important , browser recognize empty tag . Here list affected tag : area frame isindex base hr link basefont img meta br input param col To summarize , default XSLT produce well-formed XML output . And XSL stylesheet well-formed XML start , easily put tag < br > middle . The < xsl : output method= '' html '' / > tag solve problem code < br/ > stylesheet get < br > output . The major reason specify < xsl : output method= '' html '' / > , specification < xsl : output method= '' text '' / > , generate text escape . For example , stylesheet include < entity reference , appear < character generated text . When XML generate , hand , < entity reference stylesheet would unchanged , would appear < generated text . Note - If actually want < generate part HTML output , need encode & lt ; . That sequence become < output , & convert & character . Running Stylizer Sample With LIST NOTE Elements Defined Navigate sample directory . % cd install-dir/jaxp-1_4_2-release-date/samples . Download XSLT example click link unzip install-dir/jaxp-1_4_2-release-date/samples directory . Navigate xslt directory . cd xslt Compile Stylizer sample . Type following command : % javac Stylizer.java Run Stylizer sample article2.xml use stylesheet article2.xsl . % java Stylizer data/article2.xsl data/article2.xml Here HTML generate second section run program : ... < h2 > The Second Major Section < /h2 > < p > This section add LIST NOTE . < /p > < p > Here LIST : < /p > < ol > < li > Pears < /li > < li > Grapes < /li > < /ol > < p > And NOTE : < /p > < blockquote > < b > Note : < /b > < br > Do forget go hardware store way grocery ! < /blockquote > Process Inline ( Content ) Elements The remain tag ARTICLE type inline tags-the one create line break output , instead integrate stream text part . Inline element different structure element inline element part content tag . If think element node document tree , node content structure . The content compose text inline tag contain . The structure consist element ( structure element ) tag . Note - The sample document describe section article3.xml , stylesheet use manipulate article3.xsl . The result stylizer3.html . Start add one bit test data sample document : < ? xml version= '' 1.0 '' ? > < ARTICLE > < TITLE > A Sample Article < /TITLE > < SECT > The First Major Section [ ... ] < /SECT > < SECT > The Second Major Section [ ... ] < /SECT > < SECT > The < > Third < /i > Major Section < PARA > In addition inline tag heading , section define term < DEF > inline < /DEF > , literally mean `` line break '' . It also add simple link main page Java platform ( < LINK > http : //java.sun.com < /LINK > ) , well link < LINK target= '' http : //java.sun.com/xml '' > XML < /LINK > page . < /PARA > < /SECT > < /ARTICLE > Now process inline < DEF > element paragraph , rename HTML italic tag : < xsl : template match= '' DEF '' > < > < xsl : apply-templates/ > < /i > < /xsl : template > Next , comment text-node normalization . It serve purpose , point need preserve important space : < ! -- < xsl : template match= '' text ( ) '' > < xsl : value-of select= '' normalize-space ( ) '' / > < /xsl : template > -- > This modification keep u lose space tag < I > < DEF > . ( Try program without modification see result ) . Now process basic inline HTML element < B > , < I > , < U > bold , italic , underlining . < xsl : template match= '' B|I|U '' > < xsl : element name= '' { name ( ) } '' > < xsl : apply-templates/ > < /xsl : element > < /xsl : template > The < xsl : element > tag let compute element want generate . Here , generate appropriate inline tag use name current element . In particular , note use curly brace ( { } ) name= '' .. '' expression . Those curly brace cause text inside quote process XPath expression instead interpret literal string . Here , cause XPath name ( ) function return name current node . Curly brace recognize anywhere attribute value template occur . ( Attribute value template define section 7.6.2 XSLT specification , appear several place template definition ) . In expression , curly brace also use refer value attribute , { @ foo } , content element { foo } . Note - You also generate attribute use < xsl : attribute > . For information , see section 7.1.3 XSLT Specification . The last remaining element LINK tag . The easy way process tag set name template drive parameter : < xsl : template name= '' htmLink '' > < xsl : param name= '' dest '' select= '' UNDEFINED '' / > < xsl : element name= '' '' > < xsl : attribute name= '' href '' > < xsl : value-of select= '' '' / > < /xsl : attribute > < xsl : apply-templates/ > < /xsl : element > < /xsl : template > The major difference template , instead specify match clause , give template name use name= '' '' clause . So template get execute invoke . Within template , also specify parameter name use < xsl : param > tag . For bit error checking , use select clause give parameter default value UNDEFINED . To reference variable < xsl : value-of > tag , specify . Note - Recall entry quote interpret expression unless far enclose single quote . That single quote need earlier `` @ type='ordered ' '' make sure order interpret string . The < xsl : element > tag generate element . Previously , able simply specify element want cod something like < html > . But dynamically generate content HTML anchor ( < > ) body < xsl : element > tag . And dynamically generate href attribute anchor use < xsl : attribute > tag . The last important part template < apply-templates > tag , insert text text node LINK element . Without , would text generated HTML link . Next , add template LINK tag , call name template within : < xsl : template match= '' LINK '' > < xsl : test= '' @ target '' > < ! -- Target attribute specified. -- > < xsl : call-template name= '' htmLink '' > < xsl : with-param name= '' dest '' select= '' @ target '' / > < /xsl : call-template > < /xsl : > < /xsl : template > < xsl : template name= '' htmLink '' > [ ... ] The test= '' @ target '' clause return true target attribute exist LINK tag . So < xsl-if > tag generate HTML link text link target define different . The < xsl : call-template > tag invoke named template , whereas < xsl : with-param > specify parameter use name clause specify value use select clause . As last step stylesheet construction process , add < xsl-if > tag process LINK tag target attribute . < xsl : template match= '' LINK '' > < xsl : test= '' @ target '' > [ ... ] < /xsl : > < xsl : test= '' ( @ target ) '' > < xsl : call-template name= '' htmLink '' > < xsl : with-param name= '' dest '' > < xsl : apply-templates/ > < /xsl : with-param > < /xsl : call-template > < /xsl : > < /xsl : template > The ( ... ) clause invert previous test ( remember , else clause ) . So part template interpret target attribute specify . This time , parameter value come select clause , content < xsl : with-param > element . Note - Just make explicit : Parameters variable ( discuss moment What Else Can XSLT Do ? value specify either select clause , let use XPath expression , content element , let use XSLT tag . In case , content parameter generate < xsl : apply-templates/ > tag , insert content text node LINK element . Running Stylizer Sample With Inline Elements Defined Navigate sample directory . % cd install-dir/jaxp-1_4_2-release-date/samples . Download XSLT example click link unzip install-dir/jaxp-1_4_2-release-date/samples directory . Navigate xslt directory. < cd xslt Compile Stylizer sample . Type following command : % javac Stylizer.java Run Stylizer sample article3.xml use stylesheet article3.xsl . % java Stylizer data/article3.xsl data/article3.xml When run program , result look something like : [ ... ] < h2 > The < > Third < /i > Major Section < /h2 > < p > In addition inline tag heading , section define term < > inline < /i > , literally mean `` line break '' . It also add simple link main page Java platform ( < href= '' http : //java.sun.com '' > http : //java.sun.com < /a > ) , well link < href= '' http : //java.sun.com/xml '' > XML < /a > page. < /p > Good work ! You convert rather complex XML file HTML . ( As simple appear first , certainly provide lot opportunity exploration ) . Printing HTML You convert XML file HTML . One day , someone produce HTML-aware printing engine able find use Java Printing Service API . At point , ability print arbitrary XML file generate HTML . All set stylesheet use browser . What Else Can XSLT Do ? As lengthy section , scratch surface XSLT 's capability . Many additional possibility await XSLT specification . Here thing look : import ( Section 2.6.2 ) include ( section 2.6.1 ) rt ( Section 2.6.2 ) include ( section 2.6.1 ) Use statement modularize combine XSLT stylesheets . The include statement simply insert definition include file . The import statement let override definition import file definition stylesheet . for-each loop ( section 8 ) Loop collection item process one turn . choose ( case statement ) conditional processing ( section 9.2 ) Branch one multiple process path depend input value . Generating number ( section 7.7 ) Dynamically generate numbered section , numbered element , numeric literal . XSLT provide three number mode : Single : Numbers item single heading , like ordered list HTML Multiple : Produces multilevel number `` A.1.3 '' Any : Consecutively number item wherever appear , footnote lesson . Formatting number ( section 12.3 ) Control enumeration format get numerics ( format= '' 1 '' ) , uppercase alphabetics ( format= '' A '' ) , lowercase alphabetics ( format= '' '' ) , compound number , like `` A.1 , '' well number currency amount suit specific international locale . Sorting output ( section 10 ) Produce output desired sorting order . Mode-based template ( section 5.7 ) Process element multiple time , time different `` mode . '' You add mode attribute template specify < apply-templates mode= '' ... '' > apply template matching mode . Combine < apply-templates select= '' ... '' > attribute apply mode-based processing subset input data . Variables ( section 11 ) Variables something like method parameter , let control template 's behavior . But valuable might think . The value variable know within scope current template < xsl : > tag ( example ) define . You pass value one template another , even enclosed part template another part template . These statement true even `` global '' variable . You change value template , change apply template . And expression use define global variable evaluate , evaluation take place context structure 's root node . In word , global variable essentially runtime constant . Those constant useful change behavior template , especially couple include import statement . But variable general-purpose data-management mechanism . The Trouble Variables It tempt create single template set variable destination link , rather go trouble set parameterized template call two different way . The idea set variable default value ( say , text LINK tag ) , target attribute exists , set destination variable value target attribute . That would good idea-if work . But , issue variable know scope within define . So code < xsl : > tag change value variable , value know within context < xsl : > tag . Once < /xsl : > encounter , change variable 's setting lose . A similarly tempting idea possibility replace text ( ) |B|I|U|DEF|LINK specification variable ( ) . But value variable determine define , value global inline variable consists text node , < B > node , , happen exist root level . In word , value variable , case , null .