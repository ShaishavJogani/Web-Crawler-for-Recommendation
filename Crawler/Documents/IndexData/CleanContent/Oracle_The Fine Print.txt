A Generic Class Shared All Its Invocations What following code fragment print ? List < String > l1 = new ArrayList < String > ( ) ; List < Integer > l2 = new ArrayList < Integer > ( ) ; System.out.println ( l1.getClass ( ) == l2.getClass ( ) ) ; You might tempt say false , 'd wrong . It print true , instance generic class run-time class , regardless actual type parameter . Indeed , make class generic fact behavior possible type parameter ; class view many different type . As consequence , static variable method class also share among instance . That illegal refer type parameter type declaration static method initializer , declaration initializer static variable . Casts InstanceOf Another implication fact generic class share among instance , usually make sense ask instance instance particular invocation generic type : Collection c = new ArrayList < String > ( ) ; // Illegal . ( cs instanceof Collection < String > ) { ... } similarly , cast // Unchecked warning , Collection < String > cstr = ( Collection < String > ) c ; give unchecked warning , since n't something runtime system go check . The true type variable // Unchecked warning . < T > T badCast ( T , Object ) { return ( T ) ; } Type variable n't exist run time . This mean entail performance overhead either time space , nice . Unfortunately , also mean ca n't reliably use cast . Arrays The component type array object may type variable parameterized type , unless ( unbounded ) wildcard type.You declare array type whose element type type variable parameterized type , array object . This annoy , sure . This restriction necessary avoid situation like : // Not really allow . List < String > [ ] lsa = new List < String > [ 10 ] ; Object = lsa ; Object [ ] oa = ( Object [ ] ) ; List < Integer > li = new ArrayList < Integer > ( ) ; li.add ( new Integer ( 3 ) ) ; // Unsound , pass run time store check oa [ 1 ] = li ; // Run-time error : ClassCastException . String = lsa [ 1 ] .get ( 0 ) ; If array parameterized type allow , previous example would compile without unchecked warning , yet fail run-time . We 've type-safety primary design goal generic . In particular , language design guarantee entire application compile without unchecked warning use javac -source 1.5 , type safe . However , still use wildcard array . The following variation previous code forgo use array object array type whose element type parameterized . As result , cast explicitly get String array . // OK , array unbounded wildcard type . List < ? > [ ] lsa = new List < ? > [ 10 ] ; Object = lsa ; Object [ ] oa = ( Object [ ] ) ; List < Integer > li = new ArrayList < Integer > ( ) ; li.add ( new Integer ( 3 ) ) ; // Correct . oa [ 1 ] = li ; // Run time error , cast explicit . String = ( String ) lsa [ 1 ] .get ( 0 ) ; In next variation , cause compile-time error , refrain create array object whose element type parameterized , still use array type parameterized element type . // Error . List < String > [ ] lsa = new List < ? > [ 10 ] ; Similarly , attempt create array object whose element type type variable cause compile-time error : < T > T [ ] makeArray ( T ) { return new T [ 100 ] ; // Error. } Since type variable n't exist run time , way determine actual array type would . The way work around kind limitation use class literal run time type token , describe next section , Class Literals Runtime-Type Tokens .