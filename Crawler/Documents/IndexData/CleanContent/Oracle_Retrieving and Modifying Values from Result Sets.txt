The following method , CoffeesTable.viewTable output content COFFEES table , demonstrate use ResultSet object cursor : public static void viewTable ( Connection con , String dbName ) throw SQLException { Statement stmt = null ; String query = `` select COF_NAME , SUP_ID , PRICE , `` + `` SALES , TOTAL `` + `` `` + dbName + `` .COFFEES '' ; try { stmt = con.createStatement ( ) ; ResultSet rs = stmt.executeQuery ( query ) ; ( rs.next ( ) ) { String coffeeName = rs.getString ( `` COF_NAME '' ) ; int supplierID = rs.getInt ( `` SUP_ID '' ) ; float price = rs.getFloat ( `` PRICE '' ) ; int sale = rs.getInt ( `` SALES '' ) ; int total = rs.getInt ( `` TOTAL '' ) ; System.out.println ( coffeeName + `` \t '' + supplierID + `` \t '' + price + `` \t '' + sale + `` \t '' + total ) ; } } catch ( SQLException e ) { JDBCTutorialUtilities.printSQLException ( e ) ; } finally { ( stmt ! = null ) { stmt.close ( ) ; } } } A ResultSet object table data represent database result set , usually generate execute statement query database . For example , CoffeeTables.viewTable method create ResultSet , r , execute query Statement object , stmt . Note ResultSet object create object implement Statement interface , include PreparedStatement , CallableStatement , RowSet . You access data ResultSet object cursor . Note cursor database cursor . This cursor pointer point one row data ResultSet . Initially , cursor position first row . The method ResultSet.next move cursor next row . This method return false cursor position last row . This method repeatedly call ResultSet.next method loop iterate data ResultSet . This page cover following topic : ResultSet Interface Retrieving Column Values Rows Cursors Updating Rows ResultSet Objects Using Statement Objects Batch Updates Inserting Rows ResultSet Objects ResultSet Interface The ResultSet interface provide method retrieve manipulate result executed query , ResultSet object different functionality characteristic . These characteristic type , concurrency , cursor holdability . ResultSet Types The type ResultSet object determine level functionality two area : way cursor manipulate , concurrent change make underlie data source reflect ResultSet object . The sensitivity ResultSet object determine one three different ResultSet type : TYPE_FORWARD_ONLY : The result set scroll ; cursor move forward , first row last row . The row contain result set depend underlying database generate result . That , contain row satisfy query either time query execute row retrieve . TYPE_SCROLL_INSENSITIVE : The result scroll ; cursor move forward backward relative current position , move absolute position . The result set insensitive change make underlie data source open . It contain row satisfy query either time query execute row retrieve . TYPE_SCROLL_SENSITIVE : The result scroll ; cursor move forward backward relative current position , move absolute position . The result set reflect change make underlie data source result set remain open . The default ResultSet type TYPE_FORWARD_ONLY . Note : Not database JDBC driver support ResultSet type . The method DatabaseMetaData.supportsResultSetType return true specify ResultSet type support false otherwise . ResultSet Concurrency The concurrency ResultSet object determine level update functionality support . There two concurrency level : CONCUR_READ_ONLY : The ResultSet object update use ResultSet interface . CONCUR_UPDATABLE : The ResultSet object update use ResultSet interface . The default ResultSet concurrency CONCUR_READ_ONLY . Note : Not JDBC driver database support concurrency . The method DatabaseMetaData.supportsResultSetConcurrency return true specified concurrency level support driver false otherwise . The method CoffeesTable.modifyPrices demonstrate use ResultSet object whose concurrency level CONCUR_UPDATABLE . Cursor Holdability Calling method Connection.commit close ResultSet object create current transaction . In case , however , may desired behavior . The ResultSet property holdability give application control whether ResultSet object ( cursor ) close commit call . The following ResultSet constant may supply Connection method createStatement , prepareStatement , prepareCall : HOLD_CURSORS_OVER_COMMIT : ResultSet cursor close ; holdable : hold open method commit call . Holdable cursor might ideal application use mostly read-only ResultSet object . CLOSE_CURSORS_AT_COMMIT : ResultSet object ( cursor ) close commit method call . Closing cursor method call result good performance application . The default cursor holdability vary depend DBMS . Note : Not JDBC driver database support holdable non-holdable cursor . The following method , JDBCTutorialUtilities.cursorHoldabilitySupport , output default cursor holdability ResultSet object whether HOLD_CURSORS_OVER_COMMIT CLOSE_CURSORS_AT_COMMIT support : public static void cursorHoldabilitySupport ( Connection conn ) throw SQLException { DatabaseMetaData dbMetaData = conn.getMetaData ( ) ; System.out.println ( `` ResultSet.HOLD_CURSORS_OVER_COMMIT = `` + ResultSet.HOLD_CURSORS_OVER_COMMIT ) ; System.out.println ( `` ResultSet.CLOSE_CURSORS_AT_COMMIT = `` + ResultSet.CLOSE_CURSORS_AT_COMMIT ) ; System.out.println ( `` Default cursor holdability : `` + dbMetaData.getResultSetHoldability ( ) ) ; System.out.println ( `` Supports HOLD_CURSORS_OVER_COMMIT ? `` + dbMetaData.supportsResultSetHoldability ( ResultSet.HOLD_CURSORS_OVER_COMMIT ) ) ; System.out.println ( `` Supports CLOSE_CURSORS_AT_COMMIT ? `` + dbMetaData.supportsResultSetHoldability ( ResultSet.CLOSE_CURSORS_AT_COMMIT ) ) ; } Retrieving Column Values Rows The ResultSet interface declare getter method ( example , getBoolean getLong ) retrieve column value current row . You retrieve value use either index number column alias name column . The column index usually efficient . Columns number 1 . For maximum portability , result set column within row read left-to-right order , column read . For example , following method , CoffeesTable.alternateViewTable , retrieve column value number : public static void alternateViewTable ( Connection con ) throw SQLException { Statement stmt = null ; String query = `` select COF_NAME , SUP_ID , PRICE , `` + `` SALES , TOTAL COFFEES '' ; try { stmt = con.createStatement ( ) ; ResultSet rs = stmt.executeQuery ( query ) ; ( rs.next ( ) ) { String coffeeName = rs.getString ( 1 ) ; int supplierID = rs.getInt ( 2 ) ; float price = rs.getFloat ( 3 ) ; int sale = rs.getInt ( 4 ) ; int total = rs.getInt ( 5 ) ; System.out.println ( coffeeName + `` \t '' + supplierID + `` \t '' + price + `` \t '' + sale + `` \t '' + total ) ; } } catch ( SQLException e ) { JDBCTutorialUtilities.printSQLException ( e ) ; } finally { ( stmt ! = null ) { stmt.close ( ) ; } } } Strings use input getter method case-insensitive . When getter method call string one column alias name string , value first matching column return . The option use string oppose integer design use column alias name use SQL query generate result set . For column explicitly name query ( example , select * COFFEES ) best use column number . If column name use , developer guarantee uniquely refer intend column use column alias . A column alias effectively rename column result set . To specify column alias , use SQL AS clause SELECT statement . The getter method appropriate type retrieve value column . For example , method CoffeeTables.viewTable , first column row ResultSet r COF_NAME , store value SQL type VARCHAR . The method retrieve value SQL type VARCHAR getString . The second column row store value SQL type INTEGER , method retrieve value type getInt . Note although method getString recommend retrieve SQL type CHAR VARCHAR , possible retrieve basic SQL type . Getting value getString useful , also limitation . For instance , use retrieve numeric type , getString convert numeric value Java String object , value convert back numeric type operate number . In case value treat string anyway , drawback . Furthermore , want application retrieve value standard SQL type SQL3 type , use getString method . Cursors As mention previously , access data ResultSet object cursor , point one row ResultSet object . However , ResultSet object first create , cursor position first row . The method CoffeeTables.viewTable move cursor call ResultSet.next method . There method available move cursor : next : Moves cursor forward one row . Returns true cursor position row false cursor position last row . previous : Moves cursor backward one row . Returns true cursor position row false cursor position first row . first : Moves cursor first row ResultSet object . Returns true cursor position first row false ResultSet object contain row . last : : Moves cursor last row ResultSet object . Returns true cursor position last row false ResultSet object contain row . beforeFirst : Positions cursor start ResultSet object , first row . If ResultSet object contain row , method effect . afterLast : Positions cursor end ResultSet object , last row . If ResultSet object contain row , method effect . relative ( int row ) : Moves cursor relative current position . absolute ( int row ) : Positions cursor row specify parameter row . Note default sensitivity ResultSet TYPE_FORWARD_ONLY , mean scroll ; call method move cursor , except next , ResultSet scroll . The method CoffeesTable.modifyPrices , describe following section , demonstrate move cursor ResultSet . Updating Rows ResultSet Objects You update default ResultSet object , move cursor forward . However , create ResultSet object scroll ( cursor move backwards move absolute position ) update . The following method , CoffeesTable.modifyPrices , multiply PRICE column row argument percentage : public void modifyPrices ( float percentage ) throw SQLException { Statement stmt = null ; try { stmt = con.createStatement ( ) ; stmt = con.createStatement ( ResultSet.TYPE_SCROLL_SENSITIVE , ResultSet.CONCUR_UPDATABLE ) ; ResultSet uprs = stmt.executeQuery ( `` SELECT * FROM `` + dbName + `` .COFFEES '' ) ; ( uprs.next ( ) ) { float f = uprs.getFloat ( `` PRICE '' ) ; uprs.updateFloat ( `` PRICE '' , f * percentage ) ; uprs.updateRow ( ) ; } } catch ( SQLException e ) { JDBCTutorialUtilities.printSQLException ( e ) ; } finally { ( stmt ! = null ) { stmt.close ( ) ; } } } The field ResultSet.TYPE_SCROLL_SENSITIVE create ResultSet object whose cursor move forward backward relative current position absolute position . The field ResultSet.CONCUR_UPDATABLE create ResultSet object update . See ResultSet Javadoc field specify modify behavior ResultSet object . The method ResultSet.updateFloat update specified column ( example , PRICE specify float value row cursor position . ResultSet contain various updater method enable update column value various data type . However , none updater method modify database ; must call method ResultSet.updateRow update database . Using Statement Objects Batch Updates Statement , PreparedStatement CallableStatement object list command associate . This list may contain statement update , insert , delete row ; may also contain DDL statement CREATE TABLE DROP TABLE . It , however , contain statement would produce ResultSet object , SELECT statement . In word , list contain statement produce update count . The list , associate Statement object creation , initially empty . You add SQL command list method addBatch empty method clearBatch . When finish add statement list , call method executeBatch send database execute unit , batch . For example , following method CoffeesTable.batchUpdate add four row COFFEES table batch update : public void batchUpdate ( ) throw SQLException { Statement stmt = null ; try { this.con.setAutoCommit ( false ) ; stmt = this.con.createStatement ( ) ; stmt.addBatch ( `` INSERT INTO COFFEES `` + `` VALUES ( 'Amaretto ' , 49 , 9.99 , 0 , 0 ) '' ) ; stmt.addBatch ( `` INSERT INTO COFFEES `` + `` VALUES ( 'Hazelnut ' , 49 , 9.99 , 0 , 0 ) '' ) ; stmt.addBatch ( `` INSERT INTO COFFEES `` + `` VALUES ( 'Amaretto_decaf ' , 49 , `` + `` 10.99 , 0 , 0 ) '' ) ; stmt.addBatch ( `` INSERT INTO COFFEES `` + `` VALUES ( 'Hazelnut_decaf ' , 49 , `` + `` 10.99 , 0 , 0 ) '' ) ; int [ ] updateCounts = stmt.executeBatch ( ) ; this.con.commit ( ) ; } catch ( BatchUpdateException b ) { JDBCTutorialUtilities.printBatchUpdateException ( b ) ; } catch ( SQLException ex ) { JDBCTutorialUtilities.printSQLException ( ex ) ; } finally { ( stmt ! = null ) { stmt.close ( ) ; } this.con.setAutoCommit ( true ) ; } } The following line disable auto-commit mode Connection object con transaction automatically commit roll back method executeBatch call . this.con.setAutoCommit ( false ) ; To allow correct error handling , always disable auto-commit mode begin batch update . The method Statement.addBatch add command list command associate Statement object stmt . In example , command INSERT INTO statement , one add row consisting five column value . The value column COF_NAME PRICE name coffee price , respectively . The second value row 49 identification number supplier , Superior Coffee . The last two value , entry column SALES TOTAL , start zero sale yet . ( SALES number pound row 's coffee sell current week ; TOTAL total cumulative sale coffee . ) The following line send four SQL command add list command database execute batch : int [ ] updateCounts = stmt.executeBatch ( ) ; Note stmt use method executeBatch send batch insertion , method executeUpdate , send one command return single update count . The DBMS execute command order add list command , first add row value Amaretto , add row Hazelnut , Amaretto decaf , finally Hazelnut decaf . If four command execute successfully , DBMS return update count command order execute . The update count indicate many row affect command store array updateCounts . If four command batch execute successfully , updateCounts contain four value , 1 insertion affect one row . The list command associate stmt empty four command add previously send database stmt call method executeBatch . You time explicitly empty list command method clearBatch . The Connection.commit method make batch update COFFEES table permanent . This method need call explicitly auto-commit mode connection disable previously . The following line enable auto-commit mode current Connection object . this.con.setAutoCommit ( true ) ; Now statement example automatically commit execute , longer need invoke method commit . Performing Parameterized Batch Update It also possible parameterized batch update , show following code fragment , con Connection object : con.setAutoCommit ( false ) ; PreparedStatement pstmt = con.prepareStatement ( `` INSERT INTO COFFEES VALUES ( `` + `` ? , ? , ? , ? , ? ) '' ) ; pstmt.setString ( 1 , `` Amaretto '' ) ; pstmt.setInt ( 2 , 49 ) ; pstmt.setFloat ( 3 , 9.99 ) ; pstmt.setInt ( 4 , 0 ) ; pstmt.setInt ( 5 , 0 ) ; pstmt.addBatch ( ) ; pstmt.setString ( 1 , `` Hazelnut '' ) ; pstmt.setInt ( 2 , 49 ) ; pstmt.setFloat ( 3 , 9.99 ) ; pstmt.setInt ( 4 , 0 ) ; pstmt.setInt ( 5 , 0 ) ; pstmt.addBatch ( ) ; // ... new // type coffee int [ ] updateCounts = pstmt.executeBatch ( ) ; con.commit ( ) ; con.setAutoCommit ( true ) ; Handling Batch Update Exceptions You get BatchUpdateException call method executeBatch ( 1 ) one SQL statement add batch produce result set ( usually query ) ( 2 ) one SQL statement batch execute successfully reason . You add query ( SELECT statement ) batch SQL command method executeBatch , return array update count , expect update count SQL statement execute successfully . This mean command return update count ( command INSERT INTO , UPDATE , DELETE ) return 0 ( CREATE TABLE , DROP TABLE , ALTER TABLE ) successfully execute batch executeBatch method . A BatchUpdateException contain array update count similar array return method executeBatch . In case , update count order command produce . This tell many command batch execute successfully one . For example , five command execute successfully , array contain five number : first one update count first command , second one update count second command , . BatchUpdateException derive SQLException . This mean use method available SQLException object . The following method , JDBCTutorialUtilities.printBatchUpdateException print SQLException information plus update count contain BatchUpdateException object . Because BatchUpdateException.getUpdateCounts return array int , code use loop print update count : public static void printBatchUpdateException ( BatchUpdateException b ) { System.err.println ( `` -- -- BatchUpdateException -- -- '' ) ; System.err.println ( `` SQLState : `` + b.getSQLState ( ) ) ; System.err.println ( `` Message : `` + b.getMessage ( ) ) ; System.err.println ( `` Vendor : `` + b.getErrorCode ( ) ) ; System.err.print ( `` Update count : `` ) ; int [ ] updateCounts = b.getUpdateCounts ( ) ; ( int = 0 ; < updateCounts.length ; i++ ) { System.err.print ( updateCounts [ ] + `` `` ) ; } } Inserting Rows ResultSet Objects Note : Not JDBC driver support insert new row ResultSet interface . If attempt insert new row JDBC driver database support feature , SQLFeatureNotSupportedException exception throw . The following method , CoffeesTable.insertRow , insert row COFFEES ResultSet object : public void insertRow ( String coffeeName , int supplierID , float price , int sale , int total ) throw SQLException { Statement stmt = null ; try { stmt = con.createStatement ( ResultSet.TYPE_SCROLL_SENSITIVE ResultSet.CONCUR_UPDATABLE ) ; ResultSet uprs = stmt.executeQuery ( `` SELECT * FROM `` + dbName + `` .COFFEES '' ) ; uprs.moveToInsertRow ( ) ; uprs.updateString ( `` COF_NAME '' , coffeeName ) ; uprs.updateInt ( `` SUP_ID '' , supplierID ) ; uprs.updateFloat ( `` PRICE '' , price ) ; uprs.updateInt ( `` SALES '' , sale ) ; uprs.updateInt ( `` TOTAL '' , total ) ; uprs.insertRow ( ) ; uprs.beforeFirst ( ) ; } catch ( SQLException e ) { JDBCTutorialUtilities.printSQLException ( e ) ; } finally { ( stmt ! = null ) { stmt.close ( ) ; } } } This example call Connection.createStatement method two argument , ResultSet.TYPE_SCROLL_SENSITIVE ResultSet.CONCUR_UPDATABLE . The first value enable cursor ResultSet object move forward backward . The second value , ResultSet.CONCUR_UPDATABLE , require want insert row ResultSet object ; specify updatable . The stipulation use string getter method also apply updater method . The method ResultSet.moveToInsertRow move cursor insert row . The insert row special row associate updatable result set . It essentially buffer new row construct call updater method prior insert row result set . For example , method call method ResultSet.updateString update insert row 's COF_NAME column Kona . The method ResultSet.insertRow insert content insert row ResultSet object database . Note : After insert row ResultSet.insertRow , move cursor row insert row . For example , example move first row result set method ResultSet.beforeFirst . Unexpected result occur another part application use result set cursor still point insert row .