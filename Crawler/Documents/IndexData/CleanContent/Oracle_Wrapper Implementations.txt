Wrapper implementation delegate real work specify collection add extra functionality top collection offer . For design pattern fan , example decorator pattern . Although may seem bit exotic , 's really pretty straightforward . These implementation anonymous ; rather provide public class , library provide static factory method . All implementation find Collections class , consist solely static method . Synchronization Wrappers The synchronization wrapper add automatic synchronization ( thread-safety ) arbitrary collection . Each six core collection interface — Collection , Set , List , Map , SortedSet , SortedMap — one static factory method . public static < T > Collection < T > synchronizedCollection ( Collection < T > c ) ; public static < T > Set < T > synchronizedSet ( Set < T > ) ; public static < T > List < T > synchronizedList ( List < T > list ) ; public static < K , V > Map < K , V > synchronizedMap ( Map < K , V > ) ; public static < T > SortedSet < T > synchronizedSortedSet ( SortedSet < T > ) ; public static < K , V > SortedMap < K , V > synchronizedSortedMap ( SortedMap < K , V > ) ; Each method return synchronized ( thread-safe ) Collection back specify collection . To guarantee serial access , access backing collection must accomplish return collection . The easy way guarantee keep reference backing collection . Create synchronized collection follow trick . List < Type > list = Collections.synchronizedList ( new ArrayList < Type > ( ) ) ; A collection create fashion every bit thread-safe normally synchronize collection , Vector . In face concurrent access , imperative user manually synchronize return collection iterating . The reason iteration accomplish via multiple call collection , must compose single atomic operation . The following idiom iterate wrapper-synchronized collection . Collection < Type > c = Collections.synchronizedCollection ( myCollection ) ; synchronize ( c ) { ( Type e : c ) foo ( e ) ; } If explicit iterator use , iterator method must call within synchronized block . Failure follow advice may result nondeterministic behavior . The idiom iterate Collection view synchronized Map similar . It imperative user synchronize synchronize Map iterate Collection view rather synchronize Collection view , show following example . Map < KeyType , ValType > = Collections.synchronizedMap ( new HashMap < KeyType , ValType > ( ) ) ; ... Set < KeyType > = m.keySet ( ) ; ... // Synchronizing , ! synchronize ( ) { ( KeyType k : ) foo ( k ) ; } One minor downside use wrapper implementation ability execute noninterface operation wrapped implementation . So , instance , preceding List example , call ArrayList 's ensureCapacity operation wrapped ArrayList . Unmodifiable Wrappers Unlike synchronization wrapper , add functionality wrap collection , unmodifiable wrapper take functionality away . In particular , take away ability modify collection intercept operation would modify collection throw UnsupportedOperationException . Unmodifiable wrapper two main us , follow : To make collection immutable build . In case , 's good practice maintain reference backing collection . This absolutely guarantee immutability . To allow certain client read-only access data structure . You keep reference backing collection hand reference wrapper . In way , client look modify , maintain full access . Like synchronization wrapper , six core Collection interface one static factory method . public static < T > Collection < T > unmodifiableCollection ( Collection < ? extends T > c ) ; public static < T > Set < T > unmodifiableSet ( Set < ? extends T > ) ; public static < T > List < T > unmodifiableList ( List < ? extends T > list ) ; public static < K , V > Map < K , V > unmodifiableMap ( Map < ? extends K , ? extends V > ) ; public static < T > SortedSet < T > unmodifiableSortedSet ( SortedSet < ? extends T > ) ; public static < K , V > SortedMap < K , V > unmodifiableSortedMap ( SortedMap < K , ? extends V > ) ; Checked Interface Wrappers The Collections.checked interface wrapper provide use generic collection . These implementation return dynamically type-safe view specify collection , throw ClassCastException client attempt add element wrong type . The generic mechanism language provide compile-time ( static ) type-checking , possible defeat mechanism . Dynamically type-safe view eliminate possibility entirely .