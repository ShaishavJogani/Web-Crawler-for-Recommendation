As example write simple Foo.java source : publicclassFoo { publicstaticvoidmain ( finalString [ ] args ) { System.out.println ( `` This simple example decompilation use javap '' ) ; ( ) ; b ( ) ; } publicstaticvoida ( ) { System.out.println ( `` Now call function ... '' ) ; } publicstaticvoidb ( ) { System.out.println ( `` ... call b '' ) ; } } Compile move Foo.java another directory delete wish . What javap Foo.class ? $ javap Foo produce result : Compiled `` Foo.java '' public class Foo extend java.lang.Object { public Foo ( ) ; public static void main ( java.lang.String [ ] ) ; public static void ( ) ; public static void b ( ) ; } As see javac compiler n't strip ( public ) variable name .class file . As result name function , parameter type return expose . ( This necessary order class access . ) Let 's bit , try : $ javap -c Foo Compiled `` Foo.java '' public class Foo extend java.lang.Object { public Foo ( ) ; Code : 0 : aload_0 1 : invokespecial # 1 ; //Method java/lang/Object . `` < init > '' : ( ) V 4 : return public static void main ( java.lang.String [ ] ) ; Code : 0 : getstatic # 2 ; //Field java/lang/System.out : Ljava/io/PrintStream ; 3 : ldc # 3 ; //String This simple example decompilation use javap 5 : invokevirtual # 4 ; //Method java/io/PrintStream.println : ( Ljava/lang/String ; ) V 8 : invokestatic # 5 ; //Method : ( ) V 11 : invokestatic # 6 ; //Method b : ( ) V 14 : return public static void ( ) ; Code : 0 : getstatic # 2 ; //Field java/lang/System.out : Ljava/io/PrintStream ; 3 : ldc # 7 ; //String Now call function ... 5 : invokevirtual # 4 ; //Method java/io/PrintStream.println : ( Ljava/lang/String ; ) V 8 : return public static void b ( ) ; Code : 0 : getstatic # 2 ; //Field java/lang/System.out : Ljava/io/PrintStream ; 3 : ldc # 8 ; //String ... call b 5 : invokevirtual # 4 ; //Method java/io/PrintStream.println : ( Ljava/lang/String ; ) V 8 : return }