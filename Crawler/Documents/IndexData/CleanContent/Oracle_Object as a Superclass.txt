The Object class , java.lang package , sits top class hierarchy tree . Every class descendant , direct indirect , Object class . Every class use write inherits instance method Object . You need use method , , choose , may need override code specific class . The method inherit Object discuss section : protected Object clone ( ) throw CloneNotSupportedException Creates return copy object . public boolean equal ( Object obj ) Indicates whether object `` equal '' one . protect void finalize ( ) throw Throwable Called garbage collector object garbage collection determine reference object public final Class getClass ( ) Returns runtime class object . public int hashCode ( ) Returns hash code value object . public String toString ( ) Returns string representation object . The notify , notifyAll , wait method Object play part synchronize activity independently run thread program , discuss late lesson wo n't cover . There five method : public final void notify ( ) public final void notifyAll ( ) public final void wait ( ) public final void wait ( long timeout ) public final void wait ( long timeout , int nanos ) Note : There subtle aspect number method , especially clone method . The clone ( ) Method If class , one superclass , implement Cloneable interface , use clone ( ) method create copy exist object . To create clone , write : aCloneableObject.clone ( ) ; Object 's implementation method check see whether object clone ( ) invoke implement Cloneable interface . If object , method throw CloneNotSupportedException exception . Exception handling cover late lesson . For moment , need know clone ( ) must declare protected Object clone ( ) throw CloneNotSupportedException : public Object clone ( ) throw CloneNotSupportedException go write clone ( ) method override one Object . If object clone ( ) invoke implement Cloneable interface , Object 's implementation clone ( ) method create object class original object initialize new object 's member variable value original object 's corresponding member variable . The simple way make class cloneable add implement Cloneable class 's declaration . object invoke clone ( ) method . For class , default behavior Object 's clone ( ) method work fine . If , however , object contain reference external object , say ObjExternal , may need override clone ( ) get correct behavior . Otherwise , change ObjExternal make one object visible clone also . This mean original object clone independent—to decouple , must override clone ( ) clone object ObjExternal . Then original object reference ObjExternal clone reference clone ObjExternal , object clone truly independent . The equal ( ) Method The equal ( ) method compare two object equality return true equal . The equal ( ) method provide Object class use identity operator ( == ) determine whether two object equal . For primitive data type , give correct result . For object , however , . The equal ( ) method provide Object test whether object reference equal—that , object compare exact object . To test whether two object equal sense equivalency ( contain information ) , must override equal ( ) method . Here example Book class override equal ( ) : public class Book { ... public boolean equal ( Object obj ) { ( obj instanceof Book ) return ISBN.equals ( ( Book ) obj.getISBN ( ) ) ; else return false ; } } Consider code test two instance Book class equality : // Swing Tutorial , 2nd edition Book firstBook = new Book ( `` 0201914670 '' ) ; Book secondBook = new Book ( `` 0201914670 '' ) ; ( firstBook.equals ( secondBook ) ) { System.out.println ( `` object equal '' ) ; } else { System.out.println ( `` object equal '' ) ; } This program display object equal even though firstBook secondBook reference two distinct object . They consider equal object compare contain ISBN number . You always override equal ( ) method identity operator appropriate class . Note : If override equal ( ) , must override hashCode ( ) well . The finalize ( ) Method The Object class provide callback method , finalize ( ) , may invoke object become garbage . Object 's implementation finalize ( ) nothing—you override finalize ( ) cleanup , freeing resource . The finalize ( ) method may call automatically system , call , even call , uncertain . Therefore , rely method cleanup . For example , n't close file descriptor code perform I/O expect finalize ( ) close , may run file descriptor . The getClass ( ) Method You override getClass . The getClass ( ) method return Class object , method use get information class , name ( getSimpleName ( ) ) , superclass ( getSuperclass ( ) ) , interface implement ( getInterfaces ( ) ) . For example , follow method get display class name object : void printClassName ( Object obj ) { System.out.println ( `` The object 's '' + `` class `` + obj.getClass ( ) .getSimpleName ( ) ) ; } The Class class , java.lang package , large number method ( 50 ) . For example , test see class annotation ( isAnnotation ( ) ) , interface ( isInterface ( ) ) , enumeration ( isEnum ( ) ) . You see object 's field ( getFields ( ) ) method ( getMethods ( ) ) , . The hashCode ( ) Method The value return hashCode ( ) object 's hash code , object 's memory address hexadecimal . By definition , two object equal , hash code must also equal . If override equal ( ) method , change way two object equate Object 's implementation hashCode ( ) longer valid . Therefore , override equal ( ) method , must also override hashCode ( ) method well . The toString ( ) Method You always consider override toString ( ) method class . The Object 's toString ( ) method return String representation object , useful debug . The String representation object depend entirely object , need override toString ( ) class . You use toString ( ) along System.out.println ( ) display text representation object , instance Book : System.out.println ( firstBook.toString ( ) ) ; would , properly overridden toString ( ) method , print something useful , like : ISBN : 0201914670 ; The Swing Tutorial ; A Guide Constructing GUIs , 2nd Edition