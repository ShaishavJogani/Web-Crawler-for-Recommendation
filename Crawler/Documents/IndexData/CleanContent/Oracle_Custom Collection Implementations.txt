Many programmer never need implement Collections class . You go pretty far use implementation describe preceding section chapter . However , someday might want write implementation . It fairly easy aid abstract implementation provide Java platform . Before discuss write implementation , let 's discuss might want write one . Reasons Write Implementation The following list illustrate sort custom Collections might want implement . It intend exhaustive : Persistent : All built-in Collection implementation reside main memory vanish program exit . If want collection still present next time program start , implement build veneer external database . Such collection might concurrently accessible multiple program . Application-specific : This broad category . One example unmodifiable Map contain real-time telemetry data . The key could represent location , value could read sensor location response get operation . High-performance , special-purpose : Many data structure take advantage restricted usage offer good performance possible general-purpose implementation . For instance , consider List contain long run identical element value . Such list , occur frequently text processing , run-length encoded — run represent single object contain repeat element number consecutive repetition . This example interesting trade two aspect performance : It require less space time ArrayList . High-performance , general-purpose : The Java Collections Framework 's designer try provide best general-purpose implementation interface , many , many data structure could use , new one invented every day . Maybe come something faster ! Enhanced functionality : Suppose need efficient bag implementation ( also know multiset ) : Collection offer constant-time containment check allow duplicate element . It 's reasonably straightforward implement collection atop HashMap . Convenience : You may want additional implementation offer convenience beyond offer Java platform . For instance , may frequently need List instance represent contiguous range Integers . Adapter : Suppose use legacy API ad hoc collection ' API . You write adapter implementation permit collection operate Java Collections Framework . An adapter implementation thin veneer wrap object one type make behave like object another type translate operation latter type operation former . How Write Custom Implementation Writing custom implementation surprisingly easy . The Java Collections Framework provide abstract implementation design expressly facilitate custom implementation . We 'll start following example implementation Arrays.asList . public static < T > List < T > asList ( T [ ] ) { return new MyArrayList < T > ( ) ; } private static class MyArrayList < T > extend AbstractList < T > { private final T [ ] ; MyArrayList ( T [ ] array ) { = array ; } public T get ( int index ) { return [ index ] ; } public T set ( int index , T element ) { T oldValue = [ index ] ; [ index ] = element ; return oldValue ; } public int size ( ) { return a.length ; } } Believe , close implementation contain java.util.Arrays . It 's simple ! You provide constructor get , set , size method , AbstractList rest . You get ListIterator , bulk operation , search operation , hash code computation , comparison , string representation free . Suppose want make implementation bit faster . The API documentation abstract implementation describe precisely method implement , 'll know method override get performance want . The precede implementation 's performance fine , improve bit . In particular , toArray method iterate List , copy one element time . Given internal representation , 's lot faster sensible clone array . public Object [ ] toArray ( ) { return ( Object [ ] ) a.clone ( ) ; } With addition override like , implementation exactly one found java.util.Arrays . In interest full disclosure , 's bit tough use abstract implementation write iterator , 's still difficult . The following list summarize abstract implementation : AbstractCollection — Collection neither Set List . At minimum , must provide iterator size method . AbstractSet — Set ; use identical AbstractCollection . AbstractList — List back random-access data store , array . At minimum , must provide positional access method ( get , optionally , set , remove , add ) size method . The abstract class take care listIterator ( iterator ) . AbstractSequentialList — List back sequential-access data store , link list . At minimum , must provide listIterator size method . The abstract class take care positional access method . ( This opposite AbstractList . ) AbstractQueue — minimum , must provide offer , peek , poll , size method iterator support remove . AbstractMap — Map . At minimum must provide entrySet view . This typically implement AbstractSet class . If Map modifiable , must also provide put method . The process write custom implementation follow : Choose appropriate abstract implementation class precede list . Provide implementation abstract method class . If custom collection modifiable , override one concrete method well . The API documentation abstract implementation class tell method override . Test , necessary , debug implementation . You working custom collection implementation . If concern performance , read API documentation abstract implementation class method whose implementation 're inherit . If seem slow , override . If override method , sure measure performance method override . How much effort put tweak performance function much use implementation get critical performance use . ( Often step best omit . )