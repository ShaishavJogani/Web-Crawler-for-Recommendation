A TemporalQuery use retrieve information temporal-based object . Predefined Queries The TemporalQueries class ( note plural ) provide several predefined query , include method useful application identify type temporal-based object . As adjuster , predefined query define static method design use static import statement . The precision query , example , return small ChronoUnit return particular temporal-based object . The following example use precision query several type temporal-based object : TemporalQueries query = TemporalQueries.precision ( ) ; System.out.printf ( `` LocalDate precision % % n '' , LocalDate.now ( ) .query ( query ) ) ; System.out.printf ( `` LocalDateTime precision % % n '' , LocalDateTime.now ( ) .query ( query ) ) ; System.out.printf ( `` Year precision % % n '' , Year.now ( ) .query ( query ) ) ; System.out.printf ( `` YearMonth precision % % n '' , YearMonth.now ( ) .query ( query ) ) ; System.out.printf ( `` Instant precision % % n '' , Instant.now ( ) .query ( query ) ) ; The output look like following : LocalDate precision Days LocalDateTime precision Nanos Year precision Years YearMonth precision Months Instant precision Nanos Custom Queries You also create custom query . One way create class implement TemporalQuery interface queryFrom ( TemporalAccessor ) method . The CheckDate example implement two custom query . The first custom query find FamilyVacations class , implement TemporalQuery interface . The queryFrom method compare passed-in date schedule vacation date return TRUE fall within date range . // Returns true passed-in date occur one // family vacation . Because query compare month day , // check succeed even Temporal type . public Boolean queryFrom ( TemporalAccessor date ) { int month = date.get ( ChronoField.MONTH_OF_YEAR ) ; int day = date.get ( ChronoField.DAY_OF_MONTH ) ; // Disneyland Spring Break ( ( month == Month.APRIL.getValue ( ) ) & & ( ( day > = 3 ) & & ( day < = 8 ) ) ) return Boolean.TRUE ; // Smith family reunion Lake Saugatuck ( ( month == Month.AUGUST.getValue ( ) ) & & ( ( day > = 8 ) & & ( day < = 14 ) ) ) return Boolean.TRUE ; return Boolean.FALSE ; } The second custom query implement FamilyBirthdays class . This class provide isFamilyBirthday method compare passed-in date several birthday return TRUE match . // Returns true passed-in date one // family birthday . Because query compare month day , // check succeed even Temporal type . public static Boolean isFamilyBirthday ( TemporalAccessor date ) { int month = date.get ( ChronoField.MONTH_OF_YEAR ) ; int day = date.get ( ChronoField.DAY_OF_MONTH ) ; // Angie 's birthday April 3. ( ( month == Month.APRIL.getValue ( ) ) & & ( day == 3 ) ) return Boolean.TRUE ; // Sue 's birthday June 18. ( ( month == Month.JUNE.getValue ( ) ) & & ( day == 18 ) ) return Boolean.TRUE ; // Joe 's birthday May 29. ( ( month == Month.MAY.getValue ( ) ) & & ( day == 29 ) ) return Boolean.TRUE ; return Boolean.FALSE ; } The FamilyBirthday class implement TemporalQuery interface use part lambda expression . The following code , CheckDate example , show invoke custom query . // Invoking query without use lambda expression . Boolean isFamilyVacation = date.query ( new FamilyVacations ( ) ) ; // Invoking query use lambda expression . Boolean isFamilyBirthday = date.query ( FamilyBirthdays : :isFamilyBirthday ) ; ( isFamilyVacation.booleanValue ( ) || isFamilyBirthday.booleanValue ( ) ) System.out.printf ( `` % important date ! % n '' , date ) ; else System.out.printf ( `` % important date. % n '' , date ) ;