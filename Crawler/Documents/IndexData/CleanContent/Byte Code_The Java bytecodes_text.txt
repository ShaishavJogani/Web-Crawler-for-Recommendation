See Oracle 's Java Virtual Machine Specification [ 1 ] detailed description The manipulation operand stack notate [ ] → [ ] , [ ] stack instruction execute [ ] stack instruction execute . A stack element 'b ' top element 'a ' top element denote 'a , b ' . MnemonicOpcode ( inhex ) Other bytesStack [ ] → [ ] DescriptionAaaload32arrayref , index → valueloads onto stack reference arrayaastore53arrayref , index , value →stores reference arrayaconst_null01→ nullpushes anullreference onto stackaload19index→ objectrefloads reference onto stack local variable # indexaload_02a→ objectrefloads reference onto stack local variable 0aload_12b→ objectrefloads reference onto stack local variable 1aload_22c→ objectrefloads reference onto stack local variable 2aload_32d→ objectrefloads reference onto stack local variable 3anewarraybdindexbyte1 , indexbyte2count → arrayrefcreates new array reference lengthcountand component type identify class referenceindex ( indexbyte1 < < 8 + indexbyte2 ) constant poolareturnb0objectref → [ empty ] return reference methodarraylengthbearrayref → lengthgets length arrayastore3aindexobjectref →stores reference local variable # indexastore_04bobjectref →stores reference local variable 0astore_14cobjectref →stores reference local variable 1astore_24dobjectref →stores reference local variable 2astore_34eobjectref →stores reference local variable 3athrowbfobjectref → [ empty ] , objectrefthrows error exception ( notice rest stack clear , leave reference Throwable ) Bbaload33arrayref , index → valueloads byte Boolean value arraybastore54arrayref , index , value →stores byte Boolean value arraybipush10byte→ valuepushes abyteonto stack integervalueCcaload34arrayref , index → valueloads char arraycastore55arrayref , index , value →stores char arraycheckcastc0indexbyte1 , indexbyte2objectref → objectrefchecks whether anobjectrefis certain type , class reference constant pool atindex ( indexbyte1 < < 8 + indexbyte2 ) Dd2f90value → resultconverts double floatd2i8evalue → resultconverts double intd2l8fvalue → resultconverts double longdadd63value1 , value2 → resultadds two doublesdaload31arrayref , index → valueloads double arraydastore52arrayref , index , value →stores double arraydcmpg98value1 , value2 → resultcompares two doublesdcmpl97value1 , value2 → resultcompares two doublesdconst_00e→ 0.0pushes constant0.0onto stackdconst_10f→ 1.0pushes constant1.0onto stackddiv6fvalue1 , value2 → resultdivides two doublesdload18index→ valueloads doublevaluefrom local variable # indexdload_026→ valueloads double local variable 0dload_127→ valueloads double local variable 1dload_228→ valueloads double local variable 2dload_329→ valueloads double local variable 3dmul6bvalue1 , value2 → resultmultiplies two doublesdneg77value → resultnegates doubledrem73value1 , value2 → resultgets remainder division two doublesdreturnafvalue → [ empty ] return double methoddstore39indexvalue →stores doublevalueinto local variable # indexdstore_047value →stores double local variable 0dstore_148value →stores double local variable 1dstore_249value →stores double local variable 2dstore_34avalue →stores double local variable 3dsub67value1 , value2 → resultsubtracts double anotherdup59value → value , valueduplicates value top stackdup_x15avalue2 , value1 → value1 , value2 , value1inserts copy top value stack two value topdup_x25bvalue3 , value2 , value1 → value1 , value3 , value2 , value1inserts copy top value stack two ( value2 double long take entry value3 , ) three value ( value2 neither double long ) topdup25c { value2 , value1 } → { value2 , value1 } , { value2 , value1 } duplicate top two stack word ( two value , value1 double long ; single value , value1 double long ) dup2_x15dvalue3 , { value2 , value1 } → { value2 , value1 } , value3 , { value2 , value1 } duplicate two word insert beneath third word ( see explanation ) dup2_x25e { value4 , value3 } , { value2 , value1 } → { value2 , value1 } , { value4 , value3 } , { value2 , value1 } duplicate two word insert beneath fourth wordFf2d8dvalue → resultconverts float doublef2i8bvalue → resultconverts float intf2l8cvalue → resultconverts float longfadd62value1 , value2 → resultadds two floatsfaload30arrayref , index → valueloads float arrayfastore51arreyref , index , value →stores float arrayfcmpg96value1 , value2 → resultcompares two floatsfcmpl95value1 , value2 → resultcompares two floatsfconst_00b→ 0.0fpushes0.0fon stackfconst_10c→ 1.0fpushes1.0fon stackfconst_20d→ 2.0fpushes2.0fon stackfdiv6evalue1 , value2 → resultdivides two floatsfload17index→ valueloads floatvaluefrom local variable # indexfload_022→ valueloads floatvaluefrom local variable 0fload_123→ valueloads floatvaluefrom local variable 1fload_224→ valueloads floatvaluefrom local variable 2fload_325→ valueloads floatvaluefrom local variable 3fmul6avalue1 , value2 → resultmultiplies two floatsfneg76value → resultnegates floatfrem72value1 , value2 → resultgets remainder division two floatsfreturnaevalue → [ empty ] return float methodfstore38indexvalue →stores floatvalueinto local variable # indexfstore_043value →stores floatvalueinto local variable 0fstore_144value →stores floatvalueinto local variable 1fstore_245value →stores floatvalueinto local variable 2fstore_346value →stores floatvalueinto local variable 3fsub66value1 , value2 → resultsubtracts two floatsGgetfieldb4index1 , index2objectref → valuegets fieldvalueof objectobjectref , field identify field reference constant poolindex ( index1 < < 8 + index2 ) getstaticb2index1 , index2→ valuegets static fieldvalueof class , field identify field reference constant poolindex ( index1 < < 8 + index2 ) gotoa7branchbyte1 , branchbyte2 [ change ] go another instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) goto_wc8branchbyte1 , branchbyte2 , branchbyte3 , branchbyte4 [ change ] go another instruction atbranchoffset ( sign int construct unsigned bytesbranchbyte1 < < 24 +branchbyte2 < < 16 +branchbyte3 < < 8 + branchbyte4 ) Ii2b91value → resultconverts int bytei2c92value → resultconverts int characteri2d87value → resultconverts int doublei2f86value → resultconverts int floati2l85value → resultconverts int longi2s93value → resultconverts int shortiadd60value1 , value2 → resultadds two ints togetheriaload2earrayref , index → valueloads int arrayiand7evalue1 , value2 → resultperforms logical two integersiastore4farrayref , index , value →stores int arrayiconst_m102→ -1loads int value -1 onto stackiconst_003→ 0loads int value 0 onto stackiconst_104→ 1loads int value 1 onto stackiconst_205→ 2loads int value 2 onto stackiconst_306→ 3loads int value 3 onto stackiconst_407→ 4loads int value 4 onto stackiconst_508→ 5loads int value 5 onto stackidiv6cvalue1 , value2 → resultdivides two integersif_acmpeqa5branchbyte1 , branchbyte2value1 , value2 →if reference equal , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) if_acmpnea6branchbyte1 , branchbyte2value1 , value2 →if reference equal , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) if_icmpeq9fbranchbyte1 , branchbyte2value1 , value2 →if ints equal , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) if_icmpnea0branchbyte1 , branchbyte2value1 , value2 →if ints equal , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) if_icmplta1branchbyte1 , branchbyte2value1 , value2 →ifvalue1is less thanvalue2 , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) if_icmpgea2branchbyte1 , branchbyte2value1 , value2 →ifvalue1is great equal tovalue2 , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) if_icmpgta3branchbyte1 , branchbyte2value1 , value2 →ifvalue1is great thanvalue2 , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) if_icmplea4branchbyte1 , branchbyte2value1 , value2 →ifvalue1is less equal tovalue2 , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) ifeq99branchbyte1 , branchbyte2value →ifvalueis 0 , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) ifne9abranchbyte1 , branchbyte2value →ifvalueis 0 , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) iflt9bbranchbyte1 , branchbyte2value →ifvalueis less 0 , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) ifge9cbranchbyte1 , branchbyte2value →ifvalueis great equal 0 , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) ifgt9dbranchbyte1 , branchbyte2value →ifvalueis great 0 , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) ifle9ebranchbyte1 , branchbyte2value →ifvalueis less equal 0 , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) ifnonnullc7branchbyte1 , branchbyte2value →ifvalueis null , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) ifnullc6branchbyte1 , branchbyte2value →ifvalueis null , branch instruction atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) iinc84index , const [ No change ] increment local variable # indexby sign byteconstiload15index→ valueloads intvaluefrom variable # indexiload_01a→ valueloads intvaluefrom variable 0iload_11b→ valueloads intvaluefrom variable 1iload_21c→ valueloads intvaluefrom variable 2iload_31d→ valueloads intvaluefrom variable 3imul68value1 , value2 → resultmultiply two integersineg74value → resultnegate intinstanceofc1indexbyte1 , indexbyte2objectref → resultdetermines objectobjectrefis give type , identify class referenceindexin constant pool ( indexbyte1 < < 8 + indexbyte2 ) invokeinterfaceb9indexbyte1 , indexbyte2 , count , 0objectref , [ arg1 , arg2 , ... ] →invokes interface method objectobjectref , interface method identify method referenceindexin constant pool ( indexbyte1 < < 8 + indexbyte2 ) andcountis number argument pop stack frame include object method call must always great equal 1invokespecialb7indexbyte1 , indexbyte2objectref , [ arg1 , arg2 , ... ] →invoke instance method objectobjectrefrequiring special handling ( instance initialization method , private method , superclass method ) , method identify method referenceindexin constant pool ( indexbyte1 < < 8 + indexbyte2 ) invokestaticb8indexbyte1 , indexbyte2 [ arg1 , arg2 , ... ] →invoke static method , method identify method referenceindexin constant pool ( indexbyte1 < < 8 + indexbyte2 ) invokevirtualb6indexbyte1 , indexbyte2objectref , [ arg1 , arg2 , ... ] →invoke virtual method objectobjectref , method identify method referenceindexin constant pool ( indexbyte1 < < 8 + indexbyte2 ) ior80value1 , value2 → resultlogical int orirem70value1 , value2 → resultlogical int remainderireturnacvalue → [ empty ] return integer methodishl78value1 , value2 → resultint shift leftishr7avalue1 , value2 → resultint shift rightistore36indexvalue →store intvalueinto variable # indexistore_03bvalue →store intvalueinto variable 0istore_13cvalue →store intvalueinto variable 1istore_23dvalue →store intvalueinto variable 2istore_33evalue →store intvalueinto variable 3isub64value1 , value2 → resultint subtractiushr7cvalue1 , value2 → resultint shift rightixor82value1 , value2 → resultint xorJjsra8branchbyte1 , branchbyte2→ addressjump subroutine atbranchoffset ( sign short construct unsigned bytesbranchbyte1 < < 8 + branchbyte2 ) place return address stackjsr_wc9branchbyte1 , branchbyte2 , branchbyte3 , branchbyte4→ addressjump subroutine atbranchoffset ( sign int construct unsigned bytesbranchbyte1 < < 24 + branchbyte2 < < 16 + branchbyte3 < < 8 + branchbyte4 ) place return address stackLl2d8avalue → resultconverts long doublel2f89value → resultconverts long floatl2i88value → resultconverts long intladd61value1 , value2 → resultadd two longslaload2farrayref , index → valueload long arrayland7fvalue1 , value2 → resultbitwise two longslastore50arrayref , index , value →store long arraylcmp94value1 , value2 → resultcompares two longs valueslconst_009→ 0Lpushes long 0 onto stacklconst_10a→ 1Lpushes long 1 onto stackldc12index→ valuepushes constant # indexfrom constant pool ( String , int , float class type ) onto stackldc_w13indexbyte1 , indexbyte2→ valuepushes constant # indexfrom constant pool ( String , int , float class type ) onto stack ( wideindexis construct asindexbyte1 < < 8 + indexbyte2 ) ldc2_w14indexbyte1 , indexbyte2→ valuepushes constant # indexfrom constant pool ( double long ) onto stack ( wideindexis construct asindexbyte1 < < 8 + indexbyte2 ) ldiv6dvalue1 , value2 → resultdivide two longslload16index→ valueload long value local variable # indexlload_01e→ valueload long value local variable 0lload_11f→ valueload long value local variable 1lload_220→ valueload long value local variable 2lload_321→ valueload long value local variable 3lmul69value1 , value2 → resultmultiplies two longslneg75value → resultnegates longlookupswitchab < 0-3 byte pad > , defaultbyte1 , defaultbyte2 , defaultbyte3 , defaultbyte4 , npairs1 , npairs2 , npairs3 , npairs4 , match-offset pair ... key →a target address look table use key execution continue instruction addresslor81value1 , value2 → resultbitwise two longslrem71value1 , value2 → resultremainder division two longslreturnadvalue → [ empty ] return long valuelshl79value1 , value2 → resultbitwise shift leave longvalue1byvalue2positionslshr7bvalue1 , value2 → resultbitwise shift right longvalue1byvalue2positionslstore37indexvalue →store longvaluein local variable # indexlstore_03fvalue →store longvaluein local variable 0lstore_140value →store longvaluein local variable 1lstore_241value →store longvaluein local variable 2lstore_342value →store longvaluein local variable 3lsub65value1 , value2 → resultsubtract two longslushr7dvalue1 , value2 → resultbitwise shift right longvalue1byvalue2positions , unsignedlxor83value1 , value2 → resultbitwise exclusive two longsMmonitorenterc2objectref →enter monitor object ( `` grab lock '' - start synchronized ( ) section ) monitorexitc3objectref →exit monitor object ( `` release lock '' - end synchronize ( ) section ) multianewarrayc5indexbyte1 , indexbyte2 , dimensionscount1 , [ count2 , ... ] → arrayrefcreate new array ofdimensionsdimensions element type identify class reference constant poolindex ( indexbyte1 < < 8 + indexbyte2 ) ; size dimension identify bycount1 , [ count2 , etc ] Nnewbbindexbyte1 , indexbyte2→ objectrefcreates new object type identify class reference constant poolindex ( indexbyte1 < < 8 + indexbyte2 ) newarraybcatypecount → arrayrefcreates new array withcountelements primitive type identify byatypenop00 [ No change ] performs operationPpop57value →discards top value stackpop258 { value2 , value1 } →discards top two value stack ( one value , double long ) putfieldb5indexbyte1 , indexbyte2objectref , value →set field tovaluein objectobjectref , field identify field referenceindexin constant pool ( indexbyte1 < < 8 + indexbyte2 ) putstaticb3indexbyte1 , indexbyte2value →set static field tovaluein class , field identify field referenceindexin constant pool ( indexbyte1 < < 8 + indexbyte2 ) Rreta9index [ No change ] continue execution address take local variable # index ( asymmetry jsr intentional ) returnb1→ [ empty ] return void methodSsaload35arrayref , index → valueload short arraysastore56arrayref , index , value →store short arraysipush11byte1 , byte2→ valuepushes sign integer ( byte1 < < 8 + byte2 ) onto stackswap5fvalue2 , value1 → value1 , value2swaps two top word stack ( note value1 value2 must double long ) Ttableswitchaa [ 0-3 byte pad ] , defaultbyte1 , defaultbyte2 , defaultbyte3 , defaultbyte4 , lowbyte1 , lowbyte2 , lowbyte3 , lowbyte4 , highbyte1 , highbyte2 , highbyte3 , highbyte4 , jump offset ... index →continue execution address table offsetindexWwidec4opcode , indexbyte1 , indexbyte2oriinc , indexbyte1 , indexbyte2 , countbyte1 , countbyte2 [ correspond instruction ] executeopcode , whereopcodeis either iload , fload , aload , lload , dload , istore , fstore , astore , lstore , dstore , ret , assume theindexis 16 bit ; execute iinc , theindexis 16 bit constant increment signed 16 bit shortUnusedbreakpointcareserved breakpoints Java debugger ; appear class fileimpdep1fereserved implementation-dependent operation within debugger ; appear class fileimpdep2ffreserved implementation-dependent operation within debugger ; appear class file ( name ) cb-fdthese value currently unassigned opcodes reserve future usexxxunusedxxxbathis opcode reserve `` historical reason ''