Every program set thread application logic begin . In standard program , 's one thread : thread invoke main method program class . In applet initial thread one construct applet object invoke init start method ; action may occur single thread , two three different thread , depend Java platform implementation . In lesson , call thread initial thread . In Swing program , initial thread n't lot . Their essential job create Runnable object initialize GUI schedule object execution event dispatch thread . Once GUI create , program primarily drive GUI event , cause execution short task event dispatch thread . Application code schedule additionals task event dispatch thread ( complete quickly , interfere event processing ) worker thread ( long-running task ) . An initial thread schedule GUI creation task invoke javax.swing.SwingUtilities.invokeLater javax.swing.SwingUtilities.invokeAndWait . Both method take single argument : Runnable define new task . Their difference indicate name : invokeLater simply schedule task return ; invokeAndWait wait task finish return . You see example throughout Swing tutorial : SwingUtilities.invokeLater ( new Runnable ( ) { public void run ( ) { createAndShowGUI ( ) ; } } ) ; In applet , GUI-creation task must launch init method use invokeAndWait ; otherwise , init may return GUI create , may cause problem web browser launch applet . In kind program , schedule GUI-creation task usually last thing initial thread , n't matter whether use invokeLater invokeAndWait . Why initial thread simply create GUI ? Because almost code create interacts Swing component must run event dispatch thread . This restriction discuss far next section .