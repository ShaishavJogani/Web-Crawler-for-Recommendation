Here small excerpt definition interface List Iterator package java.util : public interface List < E > { void add ( E x ) ; Iterator < E > iterator ( ) ; } public interface Iterator < E > { E next ( ) ; boolean hasNext ( ) ; } This code familiar , except stuff angle bracket . Those declaration formal type parameter interface List Iterator . Type parameter use throughout generic declaration , pretty much would use ordinary type ( though important restriction ; see section The Fine Print . In introduction , saw invocation generic type declaration List , List < Integer > . In invocation ( usually call parameterized type ) , occurrence formal type parameter ( E case ) replace actual type argument ( case , Integer ) . You might imagine List < Integer > stand version List E uniformly replace Integer : public interface IntegerList { void add ( Integer x ) ; Iterator < Integer > iterator ( ) ; } This intuition helpful , 's also misleading . It helpful , parameterized type List < Integer > indeed method look like expansion . It misleading , declaration generic never actually expand way . There n't multiple copy code -- source , binary , disk memory . If C++ programmer , 'll understand different C++ template . A generic type declaration compile , turn single class file , like ordinary class interface declaration . Type parameter analogous ordinary parameter use method constructor . Much like method formal value parameter describe kind value operate , generic declaration formal type parameter . When method invoke , actual argument substitute formal parameter , method body evaluate . When generic declaration invoke , actual type argument substitute formal type parameter . A note name convention . We recommend use pithy ( single character possible ) yet evocative name formal type parameter . It 's best avoid low case character name , make easy distinguish formal type parameter ordinary class interface . Many container type use E , element , example . We 'll see additional convention late example .