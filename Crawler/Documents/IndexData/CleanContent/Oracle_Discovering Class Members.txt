There two category method provide Class access field , method , constructor : method enumerate member method search particular member . Also distinct method access member declare directly class versus method search superinterfaces superclass inherited member . The following table provide summary member-locating method characteristic . Class Methods Locating Fields Class API List member ? Inherited member ? Private member ? getDeclaredField ( ) yes getField ( ) yes getDeclaredFields ( ) yes yes getFields ( ) yes yes Class Methods Locating Methods Class API List member ? Inherited member ? Private member ? getDeclaredMethod ( ) yes getMethod ( ) yes getDeclaredMethods ( ) yes yes getMethods ( ) yes yes Class Methods Locating Constructors Class API List member ? Inherited member ? Private member ? getDeclaredConstructor ( ) N/A1 yes getConstructor ( ) N/A1 getDeclaredConstructors ( ) yes N/A1 yes getConstructors ( ) yes N/A1 1 Constructors inherit . Given class name indication member interest , ClassSpy example use get*s ( ) method determine list public element , include inherit . import java.lang.reflect.Constructor ; import java.lang.reflect.Field ; import java.lang.reflect.Method ; import java.lang.reflect.Member ; import static java.lang.System.out ; enum ClassMember { CONSTRUCTOR , FIELD , METHOD , CLASS , ALL } public class ClassSpy { public static void main ( String ... args ) { try { Class < ? > c = Class.forName ( args [ 0 ] ) ; out.format ( `` Class : % n % % n % n '' , c.getCanonicalName ( ) ) ; Package p = c.getPackage ( ) ; out.format ( `` Package : % n % % n % n '' , ( p ! = null ? p.getName ( ) : `` -- No Package -- '' ) ) ; ( int = 1 ; < args.length ; i++ ) { switch ( ClassMember.valueOf ( args [ ] ) ) { case CONSTRUCTOR : printMembers ( c.getConstructors ( ) , `` Constructor '' ) ; break ; case FIELD : printMembers ( c.getFields ( ) , `` Fields '' ) ; break ; case METHOD : printMembers ( c.getMethods ( ) , `` Methods '' ) ; break ; case CLASS : printClasses ( c ) ; break ; case ALL : printMembers ( c.getConstructors ( ) , `` Constuctors '' ) ; printMembers ( c.getFields ( ) , `` Fields '' ) ; printMembers ( c.getMethods ( ) , `` Methods '' ) ; printClasses ( c ) ; break ; default : assert false ; } } // production code handle exception gracefully } catch ( ClassNotFoundException x ) { x.printStackTrace ( ) ; } } private static void printMembers ( Member [ ] mbrs , String ) { out.format ( `` % : % n '' , ) ; ( Member mbr : mbrs ) { ( mbr instanceof Field ) out.format ( `` % % n '' , ( ( Field ) mbr ) .toGenericString ( ) ) ; else ( mbr instanceof Constructor ) out.format ( `` % % n '' , ( ( Constructor ) mbr ) .toGenericString ( ) ) ; else ( mbr instanceof Method ) out.format ( `` % % n '' , ( ( Method ) mbr ) .toGenericString ( ) ) ; } ( mbrs.length == 0 ) out.format ( `` -- No % -- % n '' , ) ; out.format ( `` % n '' ) ; } private static void printClasses ( Class < ? > c ) { out.format ( `` Classes : % n '' ) ; Class < ? > [ ] cl = c.getClasses ( ) ; ( Class < ? > cl : cl ) out.format ( `` % % n '' , cls.getCanonicalName ( ) ) ; ( clss.length == 0 ) out.format ( `` -- No member interface , class , enums -- % n '' ) ; out.format ( `` % n '' ) ; } } This example relatively compact ; however printMembers ( ) method slightly awkward due fact java.lang.reflect.Member interface exist since early implementation reflection could modify include useful getGenericString ( ) method generic introduce . The alternative test cast show , replace method printConstructors ( ) , printFields ( ) , printMethods ( ) , satisfy relatively spare result Member.getName ( ) . Samples output interpretation follow . User input italic . $ java ClassSpy java.lang.ClassCastException CONSTRUCTOR Class : java.lang.ClassCastException Package : java.lang Constructor : public java.lang.ClassCastException ( ) public java.lang.ClassCastException ( java.lang.String ) Since constructor inherit , exception chain mechanism constructor ( Throwable parameter ) define immediate super class RuntimeException super class find . $ java ClassSpy java.nio.channels.ReadableByteChannel METHOD Class : java.nio.channels.ReadableByteChannel Package : java.nio.channels Methods : public abstract int java.nio.channels.ReadableByteChannel.read ( java.nio.ByteBuffer ) throw java.io.IOException public abstract void java.nio.channels.Channel.close ( ) throw java.io.IOException public abstract boolean java.nio.channels.Channel.isOpen ( ) The interface java.nio.channels.ReadableByteChannel defines read ( ) . The remain method inherit super interface . This code could easily modify list method actually declare class replace get*s ( ) getDeclared*s ( ) . $ java ClassSpy ClassMember FIELD METHOD Class : ClassMember Package : -- No Package -- Fields : public static final ClassMember ClassMember.CONSTRUCTOR public static final ClassMember ClassMember.FIELD public static final ClassMember ClassMember.METHOD public static final ClassMember ClassMember.CLASS public static final ClassMember ClassMember.ALL Methods : public static ClassMember ClassMember.valueOf ( java.lang.String ) public static ClassMember [ ] ClassMember.values ( ) public final int java.lang.Enum.hashCode ( ) public final int java.lang.Enum.compareTo ( E ) public int java.lang.Enum.compareTo ( java.lang.Object ) public final java.lang.String java.lang.Enum.name ( ) public final boolean java.lang.Enum.equals ( java.lang.Object ) public java.lang.String java.lang.Enum.toString ( ) public static < T > T java.lang.Enum.valueOf ( java.lang.Class < T > , java.lang.String ) public final java.lang.Class < E > java.lang.Enum.getDeclaringClass ( ) public final int java.lang.Enum.ordinal ( ) public final native java.lang.Class < ? > java.lang.Object.getClass ( ) public final native void java.lang.Object.wait ( long ) throw java.lang.InterruptedException public final void java.lang.Object.wait ( long , int ) throw java.lang.InterruptedException public final void java.lang.Object.wait ( ) hrows java.lang.InterruptedException public final native void java.lang.Object.notify ( ) public final native void java.lang.Object.notifyAll ( ) In field portion result , enum constant list . While technically field , might useful distinguish field . This example could modify use java.lang.reflect.Field.isEnumConstant ( ) purpose . The EnumSpy example late section trail , Examining Enums , contain possible implementation . In method section output , observe method name include name declare class . Thus , toString ( ) method implement Enum , inherit Object . The code could amend make obvious use Field.getDeclaringClass ( ) . The following fragment illustrate part potential solution . ( mbr instanceof Field ) { Field f = ( Field ) mbr ; out.format ( `` % % n '' , f.toGenericString ( ) ) ; out.format ( `` -- declare : % % n '' , f.getDeclaringClass ( ) ) ; }