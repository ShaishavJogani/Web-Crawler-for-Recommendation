With JTable class display table data , optionally allow user edit data . JTable contain cache data ; simply view data . Here picture typical table display within scroll pane : The rest section show accomplish common table-related task . Here topic section cover : Creating Simple Table Adding Table Container Setting Changing Column Widths User Selections Creating Table Model Listening Data Changes Firing Data Change Events Concepts : Editors Renderers Using Custom Renderers Specifying Tool Tips Cells Specifying Tool Tips Column Headers Sorting Filtering Using Combo Box Editor Using Other Editors Using Editor Validate User-Entered Text Printing Examples Use Tables Creating Simple Table Try : Click Launch button run SimpleTableDemo use Java™ Web Start ( download JDK 7 later ) . Or , compile run example , consult example index . Click cell contain `` Snowboarding '' . The entire first row select , indicate select Kathy Smith 's data . A special highlight indicate `` Snowboarding '' cell editable . Generally , begin edit text cell double-clicking . Position cursor `` First Name '' . Now press mouse button drag right . As see , user rearrange column table . Position cursor right column header . Now press mouse button drag right leave . The column change size , column adjust fill remain space . Resize window contain table 's big necessary display whole table . All table cell become wider , expand fill extra horizontal space . The table SimpleTableDemo.java declare column name String array : String [ ] columnNames = { `` First Name '' , `` Last Name '' , `` Sport '' , `` # Years '' , `` Vegetarian '' } ; Its data initialized store two-dimensional Object array : Object [ ] [ ] data = { { `` Kathy '' , `` Smith '' , `` Snowboarding '' , new Integer ( 5 ) , new Boolean ( false ) } , { `` John '' , `` Doe '' , `` Rowing '' , new Integer ( 3 ) , new Boolean ( true ) } , { `` Sue '' , `` Black '' , `` Knitting '' , new Integer ( 2 ) , new Boolean ( false ) } , { `` Jane '' , `` White '' , `` Speed reading '' , new Integer ( 20 ) , new Boolean ( true ) } , { `` Joe '' , `` Brown '' , `` Pool '' , new Integer ( 10 ) , new Boolean ( false ) } } ; Then Table construct use data columnNames : JTable table = new JTable ( data , columnNames ) ; There two JTable constructor directly accept data ( SimpleTableDemo use first ) : JTable ( Object [ ] [ ] rowData , Object [ ] columnNames ) JTable ( Vector rowData , Vector columnNames ) The advantage constructor easy use . However , constructor also disadvantage : They automatically make every cell editable . They treat data type ( string ) . For example , table column Boolean data , table display data check box . However , use either two JTable constructor list previously , Boolean data display string . You see difference Vegetarian column previous figure . They require put table 's data array vector , may appropriate data . For example , instantiate set object database , might want query object directly value , rather copy value array vector . If want get around restriction , need implement table model , describe Creating Table Model . Adding Table Container Here typical code create scroll pane serve container table : JScrollPane scrollPane = new JScrollPane ( table ) ; table.setFillsViewportHeight ( true ) ; The two line snippet following : The JScrollPane constructor invoke argument refer table object . This create scroll pane container table ; table automatically add container . JTable.setFillsViewportHeight invoke set fillsViewportHeight property . When property true table use entire height container , even table n't enough row use whole vertical space . This make easy use table drag-and-drop target . The scroll pane automatically place table header top viewport . The column names remain visible top view area table data scroll . If use table without scroll pane , must get table header component place . For example : container.setLayout ( new BorderLayout ( ) ) ; container.add ( table.getTableHeader ( ) , BorderLayout.PAGE_START ) ; container.add ( table , BorderLayout.CENTER ) ; Setting Changing Column Widths By default , column table start equal width , column automatically fill entire width table . When table become wide narrow ( might happen user resize window contain table ) , column width change appropriately . When user resize column drag right border , either column must change size , table 's size must change . By default , table 's size remain , column right drag point resize accommodate space add remove column left drag point . To customize initial column width , invoke setPreferredWidth table 's column . This set preferred width column approximate relative width . For example , add following code SimpleTableDemo make third column big column : TableColumn column = null ; ( int = 0 ; < 5 ; i++ ) { column = table.getColumnModel ( ) .getColumn ( ) ; ( == 2 ) { column.setPreferredWidth ( 100 ) ; //third column big } else { column.setPreferredWidth ( 50 ) ; } } As precede code show , column table represent TableColumn object . TableColumn supply getter setter method minimum , prefer , maximum width column , well method get current width . For example set cell width base approximation space need draw cell ' content , see initColumnSizes method TableRenderDemo.java . When user explicitly resize column , column ' preferred width set user-specified size become column ' new current width . However , table resize — typically window resize — ; column ' preferred width change . Instead , exist preferred width use calculate new column width fill available space . You change table 's resize behavior invoke setAutoResizeMode . User Selections In default configuration , table support selection consist one row . The user select contiguous range row arbitrary set row . The last cell user indicate get special indication ; Metal look feel , cell outline . This cell know lead selection ; sometimes call `` cell focus '' `` current cell '' . The user use mouse and/or keyboard make selection , describe following table : Operation Mouse Action Keyboard Action Select single row . Click . Up Arrow Down Arrow . Extend contiguous selection . Shift-Click Drag row . Shift-Up Arrow Shift-Down Arrow . Add row selection/toggle row selection . Control-Click Move lead selection Control-Up Arrow Control-Down Arrow , use Space Bar add selection Control-Space Bar toggle row selection . To see selection work , click Launch button run TableSelectionDemo use Java™ Web Start ( download JDK 7 later ) . Or , compile run example , consult example index . This example program present familiar table , allow user manipulate certain JTable option . There also text pane log selection event . In screenshot , user run program , click first row , control-clicked third row . Notice outline around last cell click ; Metal look feel highlight lead selection . Under `` Selection Mode '' set radio button . Click one label `` Single Selection '' . Now select one row time . If click `` Single Interval Selection '' radio button , select set row must contiguous . All radio button `` Selection Mode '' invoke JTable.setSelectionMode . This method take single argument , must one following constant define javax.swing.ListSelectionModel : MULTIPLE_INTERVAL_SELECTION , SINGLE_INTERVAL_SELECTION , SINGLE_SELECTION . Returning TableSelectionDemo , notice three option checkboxes `` Selection Options . '' Each checkbox control state boolean bound variable define JTable : '' Row Selection '' control rowSelectionAllowed setter method setRowSelectionAllowed getter method getRowSelectionAllowed . When bound property true ( columnSelectionAllowed property false ) , user select row . `` Column Selection '' control columnSelectionAllowed setter method setColumnSelectionAllowed getter method getColumnSelectionAllowed . When bound property true ( rowSelectionAllowed bound property false ) , user select column . `` Cell Selection '' control cellSelectionEnabled , setter method setCellSelectionEnabled getter method getCellSelectionEnabled . When bound property true , user select single cell rectangular block cell . NOTE : JTable use simple concept selection , manage intersection row column . It design handle fully independent cell selection . If clear three check box ( set three bound property false ) , selection ; lead selection show . You may notice `` Cell Selection '' checkbox disable multiple interval selection mode . This cell selection support mode demo . You specify selection cell multiple interval selection mode , result table produce useful selection . You may also notice change three selection option affect others . This allow row selection column selection exactly enable cell selection . JTable automatically update three bound variable necessary keep consistent . NOTE : Setting cellSelectionEnabled value side effect also set rowSelectionEnabled columnSelectionEnabled value . Setting rowSelectionEnabled columnSelectionEnabled value side effect also set cellSelectionEnabled value . Setting rowSelectionEnabled columnSelectionEnabled different value side effect also set cellSelectionEnabled false . To retrieve current selection , use JTable.getSelectedRows return array row index , JTable.getSelectedColumns return array column index . To retrieve coordinate lead selection , refer selection model table table 's column model . The following code format string contain row column lead selection : String.format ( `` Lead Selection : % , % . `` , table.getSelectionModel ( ) .getLeadSelectionIndex ( ) , table.getColumnModel ( ) .getSelectionModel ( ) .getLeadSelectionIndex ( ) ) ; User selection generate number event . For information , refer How Write List Selection Listener Writing Event Listeners lesson . NOTE : Selection data actually describe select cell `` view '' ( table data appear sorting filter ) rather table model . This distinction matter unless view data rearrange sort , filtering , user manipulation column . In case , must convert selection coordinate use conversion method describe Sorting Filtering . Creating Table Model Every table object use table model object manage actual table data . A table model object must implement TableModel interface . If programmer provide table model object , JTable automatically create instance DefaultTableModel . This relationship illustrate . The JTable constructor use SimpleTableDemo create table model code like : new AbstractTableModel ( ) { public String getColumnName ( int col ) { return columnNames [ col ] .toString ( ) ; } public int getRowCount ( ) { return rowData.length ; } public int getColumnCount ( ) { return columnNames.length ; } public Object getValueAt ( int row , int col ) { return rowData [ row ] [ col ] ; } public boolean isCellEditable ( int row , int col ) { return true ; } public void setValueAt ( Object value , int row , int col ) { rowData [ row ] [ col ] = value ; fireTableCellUpdated ( row , col ) ; } } As precede code show , implement table model simple . Generally , implement table model subclass AbstractTableModel class . Your model might hold data array , vector , hash map , might get data outside source database . It might even generate data execution time . This table different SimpleTableDemo table following way : TableDemo 's custom table model , even though simple , easily determine data 's type , help JTable display data best format . SimpleTableDemo 's automatically create table model , hand , know # Years column contain number ( generally right align particular format ) . It also know Vegetarian column contains boolean value , represent check box . The custom table model implement TableDemo let edit name column ; , however , let edit column . In SimpleTableDemo , cell editable . See code take TableDemo.java different SimpleTableDemo.java . Bold font indicate code make table 's model different table model define automatically SimpleTableDemo . public TableDemo ( ) { ... JTable table = new JTable ( new MyTableModel ( ) ) ; ... } class MyTableModel extend AbstractTableModel { private String [ ] columnNames = ... //same ... private Object [ ] [ ] data = ... //same ... public int getColumnCount ( ) { return columnNames.length ; } public int getRowCount ( ) { return data.length ; } public String getColumnName ( int col ) { return columnNames [ col ] ; } public Object getValueAt ( int row , int col ) { return data [ row ] [ col ] ; } public Class getColumnClass ( int c ) { return getValueAt ( 0 , c ) .getClass ( ) ; } /* * Do n't need implement method unless table's * editable . */ public boolean isCellEditable ( int row , int col ) { //Note data/cell address constant , //no matter cell appear onscreen . ( col < 2 ) { return false ; } else { return true ; } } /* * Do n't need implement method unless table's * data change . */ public void setValueAt ( Object value , int row , int col ) { data [ row ] [ col ] = value ; fireTableCellUpdated ( row , col ) ; } ... } Listening Data Changes A table model set listener notify whenever table data change . Listeners instance TableModelListener . In following example code , SimpleTableDemo extend include listener . New code bold . import javax.swing.event . * ; import javax.swing.table.TableModel ; public class SimpleTableDemo ... implement TableModelListener { ... public SimpleTableDemo ( ) { ... table.getModel ( ) .addTableModelListener ( ) ; ... } public void tableChanged ( TableModelEvent e ) { int row = e.getFirstRow ( ) ; int column = e.getColumn ( ) ; TableModel model = ( TableModel ) e.getSource ( ) ; String columnName = model.getColumnName ( column ) ; Object data = model.getValueAt ( row , column ) ; ... // Do something data ... } ... } Firing Data Change Events In order fire data change event table model must know construct TableModelEvent object . This complex procedure , already implement DefaultTableModel . You either allow JTable use default instance DefaultTableModel , create custom subclass DefaultTableModel . If DefaultTableModel suitable base class custom table model class , consider subclassing AbstractTableModel . This class implement simple framework construct TableModelEvent object . Your custom class simply need invoke one following AbstractTableModel method time table data change external source . Method Change fireTableCellUpdated Update specify cell . fireTableRowsUpdated Update specified row fireTableDataChanged Update entire table ( data ) . fireTableRowsInserted New row insert . fireTableRowsDeleted Existing row Deleted fireTableStructureChanged Invalidate entire table , data structure . Concepts : Editors Renderers Before go next task , need understand table draw cell . You might expect cell table component . However , performance reason , Swing table implement differently . Instead , single cell renderer generally use draw cell contain type data . You think renderer configurable ink stamp table use stamp appropriately format data onto cell . When user start edit cell 's data , cell editor take cell , control cell 's edit behavior . For example , cell # Years column TableDemo contains Number data — specifically , Integer object . By default , cell renderer Number-containing column use single JLabel instance draw appropriate number , right-aligned , column 's cell . If user begin edit one cell , default cell editor use right-aligned JTextField control cell editing . To choose renderer display cell column , table first determine whether specify renderer particular column . If , table invoke table model 's getColumnClass method , get data type column 's cell . Next , table compare column 's data type list data type cell renderers register . This list initialize table , add change . Currently , table put following type data list : Boolean — render check box . Number — render right-aligned label . Double , Float — Number , object-to-text translation perform NumberFormat instance ( use default number format current locale ) . Date — render label , object-to-text translation perform DateFormat instance ( use short style date time ) . ImageIcon , Icon — render centered label . Object — render label display object 's string value . Cell editor choose use similar algorithm . Remember let table create model , use Object type every column . To specify precise column type , table model must define getColumnClass method appropriately , demonstrate TableDemo.java . Keep mind although renderers determine cell column header look specify tool tip text , renderer handle event . If need pick event take place inside table , technique use varies sort event interested : Situation How Get Events To detect event cell edit ... Use cell editor ( register listener cell editor ) . To detect row/column/cell selection deselections ... Use selection listener describe Detecting User Selections . To detect mouse event column header ... Register appropriate type mouse listener table 's JTableHeader object . ( See TableSorter.java example . ) To detect event ... Register appropriate listener JTable object . The next section tell customize display editing specify renderers editor . You specify cell renderers editor either column data type . Using Custom Renderers This section tell create specify cell renderer . You set type-specific cell renderer use JTable method setDefaultRenderer . To specify cell particular column use renderer , use TableColumn method setCellRenderer . You even specify cell-specific renderer create JTable subclass . It easy customize text image render default renderer , DefaultTableCellRenderer . You create subclass implement setValue method invoke setText setIcon appropriate string image . For example , default date renderer implement : static class DateRenderer extend DefaultTableCellRenderer { DateFormat formatter ; public DateRenderer ( ) { super ( ) ; } public void setValue ( Object value ) { ( formatter==null ) { formatter = DateFormat.getDateInstance ( ) ; } setText ( ( value == null ) ? `` '' : formatter.format ( value ) ) ; } } If extend DefaultTableCellRenderer insufficient , build renderer use another superclass . The easy way create subclass exist component , make subclass implement TableCellRenderer interface . TableCellRenderer require one method : getTableCellRendererComponent . Your implementation method set render component reflect passed-in state , return component . In snapshot TableDialogEditDemo , renderer use Favorite Color cell subclass JLabel call ColorRenderer . Here excerpt ColorRenderer.java show implement . public class ColorRenderer extend JLabel implement TableCellRenderer { ... public ColorRenderer ( boolean isBordered ) { this.isBordered = isBordered ; setOpaque ( true ) ; //MUST background show up. } public Component getTableCellRendererComponent ( JTable table , Object color , boolean isSelected , boolean hasFocus , int row , int column ) { Color newColor = ( Color ) color ; setBackground ( newColor ) ; ( isBordered ) { ( isSelected ) { ... //selectedBorder solid border color //table.getSelectionBackground ( ) . setBorder ( selectedBorder ) ; } else { ... //unselectedBorder solid border color //table.getBackground ( ) . setBorder ( unselectedBorder ) ; } } setToolTipText ( ... ) ; //Discussed following section return ; } } Here code TableDialogEditDemo.java register ColorRenderer instance default renderer Color data : table.setDefaultRenderer ( Color.class , new ColorRenderer ( true ) ) ; To specify cell-specific renderer , need define JTable subclass override getCellRenderer method . For example , following code make first cell first column table use custom renderer : TableCellRenderer weirdRenderer = new WeirdRenderer ( ) ; table = new JTable ( ... ) { public TableCellRenderer getCellRenderer ( int row , int column ) { ( ( row == 0 ) & & ( column == 0 ) ) { return weirdRenderer ; } // else ... return super.getCellRenderer ( row , column ) ; } } ; Specifying Tool Tips Cells By default , tool tip text display table cell determine cell 's renderer . However , sometimes simpler specify tool tip text override JTable 's implementation getToolTipText ( MouseEvent ) method . This section show use technique . To add tool tip cell use renderer , first need get create cell renderer . Then , make sure rendering component JComponent , invoke setToolTipText method . An example set tool tip cell TableRenderDemo . Click Launch button run use Java™ Web Start ( download JDK 7 later ) . Or , compile run example , consult example index . The source code TableRenderDemo.java . It add tool tip cell Sport column following code : //Set tool tip sport cell . DefaultTableCellRenderer renderer = new DefaultTableCellRenderer ( ) ; renderer.setToolTipText ( `` Click combo box '' ) ; sportColumn.setCellRenderer ( renderer ) ; Although tool tip text previous example static , also implement tool tip whose text change depend state cell program . Here couple way : Add bit code renderer 's implementation getTableCellRendererComponent method . Override JTable method getToolTipText ( MouseEvent ) . An example add code cell renderer TableDialogEditDemo . Click Launch button run use Java™ Web Start ( download JDK 7 later ) . Or , compile run example , consult example index . TableDialogEditDemo use renderer color , implement ColorRenderer.java , set tool tip text use boldface code following snippet : public class ColorRenderer extend JLabel implement TableCellRenderer { ... public Component getTableCellRendererComponent ( JTable table , Object color , boolean isSelected , boolean hasFocus , int row , int column ) { Color newColor = ( Color ) color ; ... setToolTipText ( `` RGB value : `` + newColor.getRed ( ) + `` , `` + newColor.getGreen ( ) + `` , `` + newColor.getBlue ( ) ) ; return ; } } Here example tool tip look like : You specify tool tip text override JTable 's getToolTipText ( MouseEvent ) method . The program TableToolTipsDemo show . Click Launch button run use Java™ Web Start ( download JDK 7 later ) . Or , compile run example , consult example index . The cell tool tip Sport Vegetarian column . Here picture tool tip : Here code TableToolTipsDemo.java implement tool tip cell Sport Vegetarian column : JTable table = new JTable ( new MyTableModel ( ) ) { //Implement table cell tool tip . public String getToolTipText ( MouseEvent e ) { String tip = null ; java.awt.Point p = e.getPoint ( ) ; int rowIndex = rowAtPoint ( p ) ; int colIndex = columnAtPoint ( p ) ; int realColumnIndex = convertColumnIndexToModel ( colIndex ) ; ( realColumnIndex == 2 ) { //Sport column tip = `` This person 's favorite sport `` + `` participate : `` + getValueAt ( rowIndex , colIndex ) ; } else ( realColumnIndex == 4 ) { //Veggie column TableModel model = getModel ( ) ; String firstName = ( String ) model.getValueAt ( rowIndex,0 ) ; String lastName = ( String ) model.getValueAt ( rowIndex,1 ) ; Boolean veggie = ( Boolean ) model.getValueAt ( rowIndex,4 ) ; ( Boolean.TRUE.equals ( veggie ) ) { tip = firstName + `` `` + lastName + `` vegetarian '' ; } else { tip = firstName + `` `` + lastName + `` vegetarian '' ; } } else { //another column //You omit part know n't //have renderers supply tool //tips . tip = super.getToolTipText ( e ) ; } return tip ; } ... } The code fairly straightforward , except perhaps call convertColumnIndexToModel . That call necessary user move column around , view 's index column match model 's index column . For example , user might drag Vegetarian column ( model considers index 4 ) display first column — view index 0 . Since prepareRenderer provide view index , need translate view index model index sure intended column select . Specifying Tool Tips Column Headers You add tool tip column header set tool tip text table 's JTableHeader . Often , different column header require different tool tip text . You change text override table header 's getToolTipText method . Alternately , invoke TableColumn.setHeaderRenderer provide custom renderer header . An example use tool tip text column header TableSorterDemo.java . Here set tool tip text : table.getTableHeader ( ) .setToolTipText ( `` Click sort ; Shift-Click sort reverse order '' ) ; TableToolTipsDemo.java example implement column header tool tip vary column . If run TableToolTipsDemo ( click Launch button ) use Java™ Web Start ( download JDK 7 later ) . Or , compile run example , consult example index . You see tool tip mouse column header except first two . No tool tip supple name column since seem self-explanatory . Here picture one column header tool tip : The following code implement tool tip . Basically , create subclass JTableHeader override getToolTipText ( MouseEvent ) method return text current column . To associate revise table header table , JTable method createDefaultTableHeader override return instance JTableHeader subclass . protect String [ ] columnToolTips = { null , // `` First Name '' assume obvious null , // `` Last Name '' assume obvious `` The person 's favorite sport participate '' , `` The number year person play sport '' , `` If check , person eat meat '' } ; ... JTable table = new JTable ( new MyTableModel ( ) ) { ... //Implement table header tool tip . protect JTableHeader createDefaultTableHeader ( ) { return new JTableHeader ( columnModel ) { public String getToolTipText ( MouseEvent e ) { String tip = null ; java.awt.Point p = e.getPoint ( ) ; int index = columnModel.getColumnIndexAtX ( p.x ) ; int realIndex = columnModel.getColumn ( index ) .getModelIndex ( ) ; return columnToolTips [ realIndex ] ; } } ; } } ; Sorting Filtering Table sorting filtering manage sorter object . The easy way provide sorter object set autoCreateRowSorter bound property true : JTable table = new JTable ( ) ; table.setAutoCreateRowSorter ( true ) ; This action define row sorter instance javax.swing.table.TableRowSorter . This provide table simple locale-specific sort user click column header . This demonstrate TableSortDemo.java , see screen shot : To control sorting , construct instance TableRowSorter specify sorter object table . TableRowSorter < TableModel > sorter = new TableRowSorter < TableModel > ( table.getModel ( ) ) ; table.setRowSorter ( sorter ) ; TableRowSorter use java.util.Comparator object sort row . A class implement interface must provide method call compare define two object compare purpose sort . For example , following code create Comparator sort set string last word string : Comparator < String > comparator = new Comparator < String > ( ) { public int compare ( String s1 , String s2 ) { String [ ] strings1 = s1.split ( `` \\s '' ) ; String [ ] strings2 = s2.split ( `` \\s '' ) ; return strings1 [ strings1.length - 1 ] .compareTo ( strings2 [ strings2.length - 1 ] ) ; } } ; This example fairly simplistic ; typically , Comparator implementation subclass java.text.Collator . You define subclass , use factory method Collator obtain Comparator specific locale , use java.text.RuleBasedCollator . To determine Comparator use column , TableRowSorter attempt apply following rule turn . Rules follow order list ; first rule provide sorter Comparator use , remainining rule ignore . If comparator specify invoke setComparator , use comparator . If table model report column data consists string ( TableModel.getColumnClass return String.class column ) , use comparator sort string base current locale . If column class return TableModel.getColumnClass implement Comparable , use comparator sort string base value return Comparable.compareTo . If string convertor specify table invoke setStringConverter , use comparator sort result string representation base current locale . If none previous rule apply , use comparator invoke toString column data sort result string base current locale . For sophisticated kind sort , subclass TableRowSorter parent class javax.swing.DefaultRowSorter . To specify sort order sort precedence column , invoke setSortKeys . Here example sort table use example first two column . The precedence column sort indicate order sort key sort key list . In case , second column first sort key , row sort first name , last name . List < RowSorter.SortKey > sortKeys = new ArrayList < RowSorter.SortKey > ( ) ; sortKeys.add ( new RowSorter.SortKey ( 1 , SortOrder.ASCENDING ) ) ; sortKeys.add ( new RowSorter.SortKey ( 0 , SortOrder.ASCENDING ) ) ; sorter.setSortKeys ( sortKeys ) ; In addition reorder result , table sorter also specify row display . This know filtering . TableRowSorter implement filter use javax.swing.RowFilter object . RowFilter implement several factory method create common kind filter . For example , regexFilter return RowFilter filter base regular expression . In following example code , explicitly create sorter object later use specify filter : MyTableModel model = new MyTableModel ( ) ; sorter = new TableRowSorter < MyTableModel > ( model ) ; table = new JTable ( model ) ; table.setRowSorter ( sorter ) ; Then filter base current value text field : private void newFilter ( ) { RowFilter < MyTableModel , Object > rf = null ; //If current expression n't parse , n't update . try { rf = RowFilter.regexFilter ( filterText.getText ( ) , 0 ) ; } catch ( java.util.regex.PatternSyntaxException e ) { return ; } sorter.setRowFilter ( rf ) ; } In subsequent example , newFilter ( ) invoke every time text field change . When user enters complicate regular expression , try ... catch prevent syntax exception interfere input . When table use sorter , data user see may different order specify data model , may include row specify data model . The data user actually see know view , set coordinate . JTable provide method convert model coordinate view coordinate — convertColumnIndexToView convertRowIndexToView — convert view coordinate model coordinate — convertColumnIndexToModel convertRowIndexToModel . NOTE : When use sorter , always remember translate cell coordinate . The following example bring together idea discuss section . TableFilterDemo.java add small number change TableDemo . These include code snippet earlier section , provide sorter main table , use text field supply filtering regular expression . The follow screen shot show TableFilterDemo sorting filtering . Notice row 3 model still row 3 view : If user click twice second column , fourth row become first row — view : As previously note , text user enters `` Filter Text '' text field define filter determine row show . As sorting , filter cause view coordinate diverge model coordinate : Here code update status field reflect current selection : table.getSelectionModel ( ) .addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent event ) { int viewRow = table.getSelectedRow ( ) ; ( viewRow < 0 ) { //Selection get filter away . statusText.setText ( `` '' ) ; } else { int modelRow = table.convertRowIndexToModel ( viewRow ) ; statusText.setText ( String.format ( `` Selected Row view : % d. `` + `` Selected Row model : % . `` , viewRow , modelRow ) ) ; } } } ) ; Using Combo Box Editor Setting combo box editor simple , following example show . The bold line code set combo box editor specific column . TableColumn sportColumn = table.getColumnModel ( ) .getColumn ( 2 ) ; ... JComboBox comboBox = new JComboBox ( ) ; comboBox.addItem ( `` Snowboarding '' ) ; comboBox.addItem ( `` Rowing '' ) ; comboBox.addItem ( `` Chasing toddler '' ) ; comboBox.addItem ( `` Speed reading '' ) ; comboBox.addItem ( `` Teaching high school '' ) ; comboBox.addItem ( `` None '' ) ; sportColumn.setCellEditor ( new DefaultCellEditor ( comboBox ) ) ; Here picture combo box editor use : The precede code TableRenderDemo.java . You run TableRenderDemo ( click Launch button ) use Java™ Web Start ( download JDK 7 later ) . Or , compile run example , consult example index . Using Other Editors Whether set editor single column cell ( use TableColumn setCellEditor method ) specific type data ( use JTable setDefaultEditor method ) , specify editor use argument adhere TableCellEditor interface . Fortunately , DefaultCellEditor class implement interface provide constructor let specify editing component JTextField , JCheckBox , JComboBox . Usually explicitly specify check box editor , since column Boolean data automatically use check box renderer editor . What want specify editor text field , check box , combo box ? As DefaultCellEditor support type component , must little work . You need create class implement TableCellEditor interface . The AbstractCellEditor class good superclass use . It implement TableCellEditor 's superinterface , CellEditor , save trouble implement event fire code necessary cell editor . Your cell editor class need define least two method — getCellEditorValue getTableCellEditorComponent . The getCellEditorValue method , require CellEditor , return cell 's current value . The getTableCellEditorComponent method , require TableCellEditor , configure return component want use editor . Here picture table dialog serve , indirectly , cell editor . When user begin edit cell Favorite Color column , button ( true cell editor ) appear bring dialog , user choose different color . You run TableDialogEditDemo ( click Launch button ) use Java™ Web Start ( download JDK 7 later ) . Or , compile run example , consult example index . Here code , take ColorEditor.java , implement cell editor . public class ColorEditor extend AbstractCellEditor implement TableCellEditor , ActionListener { Color currentColor ; JButton button ; JColorChooser colorChooser ; JDialog dialog ; protect static final String EDIT = `` edit '' ; public ColorEditor ( ) { button = new JButton ( ) ; button.setActionCommand ( EDIT ) ; button.addActionListener ( ) ; button.setBorderPainted ( false ) ; //Set dialog button bring . colorChooser = new JColorChooser ( ) ; dialog = JColorChooser.createDialog ( button , `` Pick Color '' , true , //modal colorChooser , , //OK button handler null ) ; //no CANCEL button handler } public void actionPerformed ( ActionEvent e ) { ( EDIT.equals ( e.getActionCommand ( ) ) ) { //The user click cell , //bring dialog . button.setBackground ( currentColor ) ; colorChooser.setColor ( currentColor ) ; dialog.setVisible ( true ) ; fireEditingStopped ( ) ; //Make renderer reappear. } else { //User press dialog 's `` OK '' button . currentColor = colorChooser.getColor ( ) ; } } //Implement one CellEditor method AbstractCellEditor n't . public Object getCellEditorValue ( ) { return currentColor ; } //Implement one method define TableCellEditor . public Component getTableCellEditorComponent ( JTable table , Object value , boolean isSelected , int row , int column ) { currentColor = ( Color ) value ; return button ; } } As see , code pretty simple . The part bit tricky call fireEditingStopped end editor button 's action handler . Without call , editor would remain active , even though modal dialog longer visible . The call fireEditingStopped let table know deactivate editor , let cell handle renderer . Using Editor Validate User-Entered Text If cell 's default editor allow text entry , get error check free cell 's type specify something String Object . The error checking side effect convert entered text object proper type . The automatic checking user-entered string occur default editor attempt create new instance class associate cell 's column . The default editor create instance use constructor take String argument . For example , column whose cell type Integer , user type `` 123 '' default editor create corresponding Integer use code equivalent new Integer ( `` 123 '' ) . If constructor throw exception , cell 's outline turn red refuse let focus move cell . If implement class use column data type , use default editor class supply constructor take single argument type String . If like text field editor cell , want customize — perhaps check user-entered text strictly react differently text invalid — change cell editor use formatted text field . The formatted text field check value either continuously user type user indicate end type ( press Enter ) . The following code , take demo name TableFTFEditDemo.java , set formatted text field editor limit integer value 0 100 . You run TableFTFEditDemo ( click Launch button ) use Java™ Web Start ( download JDK 7 later ) . Or , compile run example , consult example index . The following code make formatted text field editor column contain data type Integer . table.setDefaultEditor ( Integer.class , new IntegerEditor ( 0 , 100 ) ) ; The IntegerEditor class implement subclass DefaultCellEditor use JFormattedTextField instead JTextField DefaultCellEditor support . It accomplish first set formatted text field use integer format specify minimum maximum value , use API describe How Use Formatted Text Fields . It override DefaultCellEditor implementation getTableCellEditorComponent , getCellEditorValue , stopCellEditing method , add operation necessary formatted text field . The override getTableCellEditorComponent set formatted text field 's value property ( text property inherit JTextField ) editor show . The override getCellEditorValue keep cell value Integer , rather , say , Long value formatted text field 's parser tend return . Finally , override stopCellEditing let check whether text valid , possibly stop editor dismiss . If text n't valid , implementation stopCellEditing put dialog give user option continue edit revert last good value . The source code bit long include , find IntegerEditor.java . Printing JTable provide simple API print table . The easy way print table invoke JTable.print argument : try { ( ! table.print ( ) ) { System.err.println ( `` User cancel printing '' ) ; } } catch ( java.awt.print.PrinterException e ) { System.err.format ( `` Can print % % n '' , e.getMessage ( ) ) ; } Invoking print normal Swing application bring standard printing dialog box . ( On headless application , table simply printed . ) The return value indicate whether user go ahead print job cancel . JTable.print throw java.awt.print.PrinterException , checked exception ; 's example use try ... catch . JTable provide several overload print various option . The following code TablePrintDemo.java show define page header : MessageFormat header = new MessageFormat ( `` Page { 0 , number , integer } '' ) ; try { table.print ( JTable.PrintMode.FIT_WIDTH , header , null ) ; } catch ( java.awt.print.PrinterException e ) { System.err.format ( `` Can print % % n '' , e.getMessage ( ) ) ; } For sophisticated printing application , use JTable.getPrintable obtain Printable object table . For Printable , refer Printing lesson 2D Graphics trail . Examples Use Tables This table list example use JTable example describe . Example Where Described Notes SimpleTableDemo Creating Simple Table A basic table custom model . Does include code specify column width detect user editing . SimpleTable- SelectionDemo Detecting User Selections Adds single selection selection detection SimpleTableDemo . By modify program 's ALLOW_COLUMN_SELECTION ALLOW_ROW_SELECTION constant , experiment alternative table default allow row select . TableDemo Creating Table Model A basic table custom model . TableFTFEditDemo Using Editor Validate User-Entered Text Modifies TableDemo use custom editor ( format text field variant ) Integer data . TableRenderDemo Using Combo Box Editor Modifies TableDemo use custom editor ( combo box ) data Sport column . Also intelligently pick column size . Uses renderers display tool tip sport cell . TableDialogEditDemo Using Other Editors Modifies TableDemo cell renderer editor display color let choose new one , use color chooser dialog . TableToolTipsDemo Specifying Tool Tips Cells , Specifying Tool Tips Column Headers , Demonstrates use several technique set tool tip text cell column header . TableSortDemo Sorting Filtering Demonstrates default sorter , allow user sort column click header . TableFilterDemo Sorting Filtering Demonstrates sort filtering , cause view coordinate diverge model coordinate . TablePrintDemo Printing Demonstrates table printing . ListSelectionDemo How Write List Selection Listener Shows use list selection mode , use list selection listener 's share table list . SharedModelDemo Nowhere Builds ListSelectionDemo make data model share table list . If edit item first column table , new value reflect list .