In section , construct Document Object Model read exist XML file . Note - In Extensible Stylesheet Language Transformations , see write DOM XML file . ( You also see convert exist data file XML relative ease . ) Creating Program The Document Object Model provide APIs let create , modify , delete , rearrange node . Before try create DOM , helpful understand DOM structure . This series example make DOM internals visible via sample program call DOMEcho , find directory INSTALL_DIR/jaxp-version/samples/dom instal JAXP API . Create Skeleton First , build simple program read XML document DOM write back . Start normal basic logic application , check make sure argument supply command line : public class DOMEcho { static final String outputEncoding = `` UTF-8 '' ; private static void usage ( ) { // ... } public static void main ( String [ ] args ) throw Exception { String filename = null ; ( int = 0 ; < args.length ; i++ ) { ( ... ) { // ... } else { filename = args [ ] ; ( ! = args.length - 1 ) { usage ( ) ; } } } ( filename == null ) { usage ( ) ; } } } This code perform basic set operation . All output DOMEcho use UTF-8 encoding . The usage ( ) method call argument specify simply tell arguments DOMEcho expect , code show . A filename string also declare , name XML file parse DOM DOMEcho . Import Required Classes In section , class individually name see class come , case want reference API documentation . In sample file , import statement make shorter form , javax.xml.parsers.* . These JAXP APIs use DOMEcho : package dom ; import javax.xml.parsers.DocumentBuilder ; import javax.xml.parsers.DocumentBuilderFactory ; These class exception throw XML document parse : import org.xml.sax.ErrorHandler ; import org.xml.sax.SAXException ; import org.xml.sax.SAXParseException ; import org.xml.sax.helpers . * These class read sample XML file manage output : import java.io.File ; import java.io.OutputStreamWriter ; import java.io.PrintWriter ; Finally , import W3C definition DOM , DOM exception , entity node : import org.w3c.dom.Document ; import org.w3c.dom.DocumentType ; import org.w3c.dom.Entity ; import org.w3c.dom.NamedNodeMap ; import org.w3c.dom.Node ; Handle Errors Next , add error-handling logic . The important point JAXP-conformant document builder require report SAX exception trouble parse XML document . The DOM parser actually use SAX parser internally , SAX standard already , make sense use report error . As result , error-handling code DOM application similar SAX application : private static class MyErrorHandler implement ErrorHandler { private PrintWriter ; MyErrorHandler ( PrintWriter ) { this.out = ; } private String getParseExceptionInfo ( SAXParseException spe ) { String systemId = spe.getSystemId ( ) ; ( systemId == null ) { systemId = `` null '' ; } String info = `` URI= '' + systemId + `` Line= '' + spe.getLineNumber ( ) + `` : `` + spe.getMessage ( ) ; return info ; } public void warning ( SAXParseException spe ) throw SAXException { out.println ( `` Warning : `` + getParseExceptionInfo ( spe ) ) ; } public void error ( SAXParseException spe ) throw SAXException { String message = `` Error : `` + getParseExceptionInfo ( spe ) ; throw new SAXException ( message ) ; } public void fatalError ( SAXParseException spe ) throw SAXException { String message = `` Fatal Error : `` + getParseExceptionInfo ( spe ) ; throw new SAXException ( message ) ; } } As see , DomEcho class 's error handler generate output use PrintWriter instance . Instantiate Factory Next , add following code main ( ) method , obtain instance factory give u document builder . public static void main ( String [ ] args ) throw Exception { DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ( ) ; // ... } Get Parser Parse File Now , add following code main ( ) get instance builder , use parse specify file . DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ( ) ; DocumentBuilder db = dbf.newDocumentBuilder ( ) ; Document doc = db.parse ( new File ( filename ) ) ; The file parse provide filename variable declare beginning main ( ) method , pass DOMEcho argument program run . Configuring Factory By default , factory return non-validating parser know nothing name space . To get validating parser , one understand name space ( ) , configure factory set either option use following code . public static void main ( String [ ] args ) throw Exception { String filename = null ; boolean dtdValidate = false ; boolean xsdValidate = false ; String schemaSource = null ; ( int = 0 ; < args.length ; i++ ) { ( args [ ] .equals ( `` -dtd '' ) ) { dtdValidate = true ; } else ( args [ ] .equals ( `` -xsd '' ) ) { xsdValidate = true ; } else ( args [ ] .equals ( `` -xsdss '' ) ) { ( == args.length - 1 ) { usage ( ) ; } xsdValidate = true ; schemaSource = args [ ++i ] ; } else { filename = args [ ] ; ( ! = args.length - 1 ) { usage ( ) ; } } } ( filename == null ) { usage ( ) ; } DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ( ) ; dbf.setNamespaceAware ( true ) ; dbf.setValidating ( dtdValidate || xsdValidate ) ; // ... DocumentBuilder db = dbf.newDocumentBuilder ( ) ; Document doc = db.parse ( new File ( filename ) ) ; } As see , command line argument set inform DOMEcho perform validation either DTD XML Schema , factory configure name space aware perform whichever type validation user specifies . Note - JAXP-conformant parser require support combination option , even though reference parser . If specify invalid combination option , factory generate ParserConfigurationException attempt obtain parser instance . More information use name space validation provide Validating XML Schema , code miss extract describe . Handling Validation Errors The default response validation error , dictate SAX standard , nothing . The JAXP standard require throw SAX exception , use exactly error-handling mechanism use SAX application . In particular , use DocumentBuilder class 's setErrorHandler method supply object implement SAX ErrorHandler interface . Note - DocumentBuilder also setEntityResolver method use . The following code configure document builder use error handler define Handle Errors . DocumentBuilder db = dbf.newDocumentBuilder ( ) ; OutputStreamWriter errorWriter = new OutputStreamWriter ( System.err , outputEncoding ) ; db.setErrorHandler ( new MyErrorHandler ( new PrintWriter ( errorWriter , true ) ) ) ; Document doc = db.parse ( new File ( filename ) ) ; The code see far set document builder , configure perform validation upon request . Error handling also place . However , DOMEcho anything yet . In next section , see display DOM structure begin explore . For example , see entity reference CDATA section look like DOM . And perhaps importantly , see text node ( contain actual data ) reside element node DOM . Displaying DOM Nodes To create manipulate DOM , help clear idea node DOM structure . This section tutorial expose internal structure DOM , see contain . The DOMEcho example echo DOM node , print onscreen , appropriate indentation make node hierarchy apparent . The specification node type find DOM Level 2 Core Specification , specification Node . Table 3-1 adapt specification . Table 3-1 Node Types Node nodeName nodeValue Attributes Attr Name attribute Value attribute null CDATASection # cdata-section Content CDATA section null Comment # comment Content comment null Document # document null null DocumentFragment # documentFragment null null DocumentType Document Type name null null Element Tag name null null Entity Entity name null null EntityReference Name entity reference null null Notation Notation name null null ProcessingInstruction Target Entire content exclude target null Text # text Content text node null The information table extremely useful ; need work DOM , type intermix DOM tree . Obtaining Node Type Information The DOM node element type information obtain call various method org.w3c.dom.Node class . The node attribute expose DOMEcho echo following code . private void printlnCommon ( Node n ) { out.print ( `` nodeName=\ '' '' + n.getNodeName ( ) + `` \ '' '' ) ; String val = n.getNamespaceURI ( ) ; ( val ! = null ) { out.print ( `` uri=\ '' '' + val + `` \ '' '' ) ; } val = n.getPrefix ( ) ; ( val ! = null ) { out.print ( `` pre=\ '' '' + val + `` \ '' '' ) ; } val = n.getLocalName ( ) ; ( val ! = null ) { out.print ( `` local=\ '' '' + val + `` \ '' '' ) ; } val = n.getNodeValue ( ) ; ( val ! = null ) { out.print ( `` nodeValue= '' ) ; ( val.trim ( ) .equals ( `` '' ) ) { // Whitespace out.print ( `` [ WS ] '' ) ; } else { out.print ( `` \ '' '' + n.getNodeValue ( ) + `` \ '' '' ) ; } } out.println ( ) ; } Every DOM node least type , name , value , might might empty . In example , Node interface 's getNamespaceURI ( ) , getPrefix ( ) , getLocalName ( ) , getNodeValue ( ) method return print echoed node 's namespace URI , namespace prefix , local qualify name value . Note trim ( ) method call value return getNodeValue ( ) establish whether node 's value empty white space print message accordingly . For full list Node method different information return , see API documentation Node . Next , method define set indentation node print , node hierarchy easily visible . private void outputIndentation ( ) { ( int = 0 ; < indent ; i++ ) { out.print ( basicIndent ) ; } } The basicIndent constant define basic unit indentation use DOMEcho display node tree hierarchy , define add follow highlighted line DOMEcho constructor class . public class DOMEcho { static final String outputEncoding = `` UTF-8 '' ; private PrintWriter ; private int indent = 0 ; private final String basicIndent = `` `` ; DOMEcho ( PrintWriter ) { this.out = ; } } As case error handler define Handle Errors , DOMEcho program create output PrintWriter instance . Lexical Controls Lexical information information need reconstruct original syntax XML document . Preserving lexical information important edit application , want save document accurate reflection original-complete comment , entity reference , CDATA section may include outset . Most application , however , concern content XML structure . They afford ignore comment , care whether data cod CDATA section plain text , whether include entity reference . For application , minimum lexical information desirable , simplify number kind DOM node application must prepare examine . The following DocumentBuilderFactory method give control lexical information see DOM . setCoalescing ( ) To convert CDATA node Text node append adjacent Text node ( ) . setExpandEntityReferences ( ) To expand entity reference node . setIgnoringComments ( ) To ignore comment . setIgnoringElementContentWhitespace ( ) To ignore whitespace significant part element content . The default value property false , preserve lexical information necessary reconstruct incoming document original form . Setting true let construct simple possible DOM application focus data 's semantic content without worry lexical syntax detail . Table 3-2 summarize effect setting . Table 3-2 Lexical Control Settings API Preserve Lexical Info Focus Content setCoalescing ( ) False True setExpandEntityReferences ( ) False True setIgnoringComments ( ) False True setIgnoringElementContentWhitespace ( ) False True The implementation method main method DomEcho example show . // ... dbf.setIgnoringComments ( ignoreComments ) ; dbf.setIgnoringElementContentWhitespace ( ignoreWhitespace ) ; dbf.setCoalescing ( putCDATAIntoText ) ; dbf.setExpandEntityReferences ( ! createEntityRefs ) ; // ... The boolean variable ignoreComments , ignoreWhitespace , putCDATAIntoText , createEntityRefs declare beginning main method code , set command line argument DomEcho run . public static void main ( String [ ] args ) throw Exception { // ... boolean ignoreWhitespace = false ; boolean ignoreComments = false ; boolean putCDATAIntoText = false ; boolean createEntityRefs = false ; ( int = 0 ; < args.length ; i++ ) { ( ... ) { // Validation argument // ... } else ( args [ ] .equals ( `` -ws '' ) ) { ignoreWhitespace = true ; } else ( args [ ] .startsWith ( `` -co '' ) ) { ignoreComments = true ; } else ( args [ ] .startsWith ( `` -cd '' ) ) { putCDATAIntoText = true ; } else ( args [ ] .startsWith ( `` -e '' ) ) { createEntityRefs = true ; // ... } else { filename = args [ ] ; // Must last arg ( ! = args.length - 1 ) { usage ( ) ; } } } // ... } Printing DOM Tree Nodes The DomEcho application allow see structure DOM , demonstrate node make DOM arrange . Generally , vast majority node DOM tree Element Text node . Note - Text node exist element node DOM , data always store text node . Perhaps common error DOM processing navigate element node expect contain data store element . Not ! Even simple element node text node contain data . The code print DOM tree node appropriate indentation show . private void echo ( Node n ) { outputIndentation ( ) ; int type = n.getNodeType ( ) ; switch ( type ) { case Node.ATTRIBUTE_NODE : out.print ( `` ATTR : '' ) ; printlnCommon ( n ) ; break ; case Node.CDATA_SECTION_NODE : out.print ( `` CDATA : '' ) ; printlnCommon ( n ) ; break ; case Node.COMMENT_NODE : out.print ( `` COMM : '' ) ; printlnCommon ( n ) ; break ; case Node.DOCUMENT_FRAGMENT_NODE : out.print ( `` DOC_FRAG : '' ) ; printlnCommon ( n ) ; break ; case Node.DOCUMENT_NODE : out.print ( `` DOC : '' ) ; printlnCommon ( n ) ; break ; case Node.DOCUMENT_TYPE_NODE : out.print ( `` DOC_TYPE : '' ) ; printlnCommon ( n ) ; NamedNodeMap nodeMap = ( ( DocumentType ) n ) .getEntities ( ) ; indent += 2 ; ( int = 0 ; < nodeMap.getLength ( ) ; i++ ) { Entity entity = ( Entity ) nodeMap.item ( ) ; echo ( entity ) ; } indent -= 2 ; break ; case Node.ELEMENT_NODE : out.print ( `` ELEM : '' ) ; printlnCommon ( n ) ; NamedNodeMap atts = n.getAttributes ( ) ; indent += 2 ; ( int = 0 ; < atts.getLength ( ) ; i++ ) { Node att = atts.item ( ) ; echo ( att ) ; } indent -= 2 ; break ; case Node.ENTITY_NODE : out.print ( `` ENT : '' ) ; printlnCommon ( n ) ; break ; case Node.ENTITY_REFERENCE_NODE : out.print ( `` ENT_REF : '' ) ; printlnCommon ( n ) ; break ; case Node.NOTATION_NODE : out.print ( `` NOTATION : '' ) ; printlnCommon ( n ) ; break ; case Node.PROCESSING_INSTRUCTION_NODE : out.print ( `` PROC_INST : '' ) ; printlnCommon ( n ) ; break ; case Node.TEXT_NODE : out.print ( `` TEXT : '' ) ; printlnCommon ( n ) ; break ; default : out.print ( `` UNSUPPORTED NODE : `` + type ) ; printlnCommon ( n ) ; break ; } indent++ ; ( Node child = n.getFirstChild ( ) ; child ! = null ; child = child.getNextSibling ( ) ) { echo ( child ) ; } indent -- ; } This code first us switch statement print different node type possible child node , appropriate indentation . Node attribute include child DOM hierarchy . They instead obtain via Node interface 's getAttributes method . The DocType interface extension w3c.org.dom.Node . It define getEntities method , use obtain Entity node - node define entity . Like Attribute node , Entity node appear child DOM node . Node Operations This section take quick look operation might want apply DOM . Creating node Traversing node Searching node Obtaining node content Creating attribute Removing change node Inserting node Creating Nodes You create different type node use method Document interface . For example , createElement , createComment , createCDATAsection , createTextNode , . The full list method create different node provide API documentation org.w3c.dom.Document . Traversing Nodes The org.w3c.dom.Node interface define number method use traverse node , include getFirstChild , getLastChild , getNextSibling , getPreviousSibling , getParentNode . Those operation sufficient get anywhere tree location tree . Searching Nodes When search node particular name , bit take account . Although tempt get first child inspect see whether right one , search must account fact first child sub-list could comment processing instruction . If XML data validate , could even text node contain ignorable whitespace . In essence , need look list child node , ignore one concern examine one care . Here example kind routine need write search node DOM hierarchy . It present entirety ( complete comment ) use template application . /** * Find name subnode node 's sublist . * < ul > * < li > Ignores comment process instruction . * < li > Ignores TEXT node ( likely exist contain * ignorable whitespace , validate . * < li > Ignores CDATA node EntityRef node . * < li > Examines element node find one * specify name . * < /ul > * @ param name tag name element find * @ param node element node start search * @ return Node find */ public Node findSubNode ( String name , Node node ) { ( node.getNodeType ( ) ! = Node.ELEMENT_NODE ) { System.err.println ( `` Error : Search node element type '' ) ; System.exit ( 22 ) ; } ( ! node.hasChildNodes ( ) ) return null ; NodeList list = node.getChildNodes ( ) ; ( int i=0 ; < list.getLength ( ) ; i++ ) { Node subnode = list.item ( ) ; ( subnode.getNodeType ( ) == Node.ELEMENT_NODE ) { ( subnode.getNodeName ( ) .equals ( name ) ) return subnode ; } } return null ; } For deep explanation code , see Increasing Complexity When Use DOM . Note , , use APIs described Lexical Controls modify kind DOM parser construct . The nice thing code , though , work almost DOM . Obtaining Node Content When want get text node contain , need look list child node , ignore entry concern accumulate text find TEXT node , CDATA node , EntityRef node . Here example kind routine use process . /** * Return text node contain . This routine : * < ul > * < li > Ignores comment process instruction . * < li > Concatenates TEXT node , CDATA node , result * recursively process EntityRef node . * < li > Ignores element node sublist . * ( Other possible option recurse element * sublists throw exception . ) * < /ul > * @ param node DOM node * @ return String represent content */ public String getText ( Node node ) { StringBuffer result = new StringBuffer ( ) ; ( ! node.hasChildNodes ( ) ) return `` '' ; NodeList list = node.getChildNodes ( ) ; ( int i=0 ; < list.getLength ( ) ; i++ ) { Node subnode = list.item ( ) ; ( subnode.getNodeType ( ) == Node.TEXT_NODE ) { result.append ( subnode.getNodeValue ( ) ) ; } else ( subnode.getNodeType ( ) == Node.CDATA_SECTION_NODE ) { result.append ( subnode.getNodeValue ( ) ) ; } else ( subnode.getNodeType ( ) == Node.ENTITY_REFERENCE_NODE ) { // Recurse subtree text // ( ignore comment ) result.append ( getText ( subnode ) ) ; } } return result.toString ( ) ; } For deep explanation code , see Increasing Complexity When Use DOM . Again , simplify code use APIs describe Lexical Controls modify kind DOM parser construct . But nice thing code work almost DOM . Creating Attributes The org.w3c.dom.Element interface , extend Node , define setAttribute operation , add attribute node . ( A good name Java platform standpoint would addAttribute . The attribute property class , new object create . ) You also use Document 's createAttribute operation create instance Attribute use setAttributeNode method add . Removing Changing Nodes To remove node , use parent Node 's removeChild method . To change , use either parent node 's replaceChild operation node 's setNodeValue operation . Inserting Nodes The important thing remember create new node create element node , data specify name . In effect , node give hook hang thing . You hang item hook add list child node . For example , might add text node , CDATA node , attribute node . As build , keep mind structure see tutorial . Remember : Each node hierarchy extremely simple , contain one data element . Running DOMEcho Sample To run DOMEcho sample , follow step . Navigate sample directory. % cd install-dir/jaxp-1_4_2-release-date/samples . Compile example class. % javac dom/* Run DOMEcho program XML file . Choose one XML file data directory run DOMEcho program . Here , choose run program file personal-schema.xml . % java dom/DOMEcho data/personal-schema.xml The XML file personal-schema.xml contain personnel file small company . When run DOMEcho program , see following output . DOC : nodeName= '' # document '' ELEM : nodeName= '' personnel '' local= '' personnel '' TEXT : nodeName= '' # text '' nodeValue= [ WS ] ELEM : nodeName= '' person '' local= '' person '' ATTR : nodeName= '' id '' local= '' id '' nodeValue= '' Big.Boss '' TEXT : nodeName= '' # text '' nodeValue= [ WS ] ELEM : nodeName= '' name '' local= '' name '' ELEM : nodeName= '' family '' local= '' family '' TEXT : nodeName= '' # text '' nodeValue= '' Boss '' TEXT : nodeName= '' # text '' nodeValue= [ WS ] ELEM : nodeName= '' give '' local= '' give '' TEXT : nodeName= '' # text '' nodeValue= '' Big '' TEXT : nodeName= '' # text '' nodeValue= [ WS ] ELEM : nodeName= '' email '' local= '' email '' TEXT : nodeName= '' # text '' nodeValue= '' chief @ foo.example.com '' TEXT : nodeName= '' # text '' nodeValue= [ WS ] ELEM : nodeName= '' link '' local= '' link '' ATTR : nodeName= '' subordinate '' local= '' subordinate '' nodeValue= '' one.worker two.worker three.worker four.worker five.worker '' TEXT : nodeName= '' # text '' nodeValue= [ WS ] TEXT : nodeName= '' # text '' nodeValue= [ WS ] ELEM : nodeName= '' person '' local= '' person '' ATTR : nodeName= '' id '' local= '' id '' nodeValue= '' one.worker '' TEXT : nodeName= '' # text '' nodeValue= [ WS ] ELEM : nodeName= '' name '' local= '' name '' ELEM : nodeName= '' family '' local= '' family '' TEXT : nodeName= '' # text '' nodeValue= '' Worker '' TEXT : nodeName= '' # text '' nodeValue= [ WS ] ELEM : nodeName= '' give '' local= '' give '' TEXT : nodeName= '' # text '' nodeValue= '' One '' TEXT : nodeName= '' # text '' nodeValue= [ WS ] ELEM : nodeName= '' email '' local= '' email '' TEXT : nodeName= '' # text '' nodeValue= '' one @ foo.example.com '' TEXT : nodeName= '' # text '' nodeValue= [ WS ] ELEM : nodeName= '' link '' local= '' link '' ATTR : nodeName= '' manager '' local= '' manager '' nodeValue= '' Big.Boss '' TEXT : nodeName= '' # text '' nodeValue= [ WS ] [ ... ] As see , DOMEcho print node different element document , correct indentation show node hierarchy .