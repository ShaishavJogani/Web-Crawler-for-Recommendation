A Swing timer ( instance javax.swing.Timer ) fire one action event specified delay . Do confuse Swing timer general-purpose timer facility java.util package . This page describe Swing timer . In general , recommend use Swing timer rather general-purpose timer GUI-related task Swing timer share , pre-existing timer thread GUI-related task automatically execute event-dispatch thread . However , might use general-purpose timer n't plan touch GUI timer , need perform lengthy processing . You use Swing timer two way : To perform task , delay . For example , tool tip manager use Swing timer determine show tool tip hide . To perform task repeatedly . For example , might perform animation update component display progress toward goal . Swing timer easy use . When create timer , specify action listener notify timer `` go '' . The actionPerformed method listener contain code whatever task need perform . When create timer , also specify number millisecond timer firing . If want timer go , invoke setRepeats ( false ) timer . To start timer , call start method . To suspend , call stop . Note Swing timer 's task perform event dispatch thread . This mean task safely manipulate component , also mean task execute quickly . If task might take execute , consider use SwingWorker instead addition timer . See Concurrency Swing instruction use SwingWorker class information use Swing component multi-threaded program . Let 's look example use timer periodically update component . The TumbleItem applet use timer update display regular interval . ( To see applet running , go How Make Applets . This applet begin create start timer : timer = new Timer ( speed , ) ; timer.setInitialDelay ( pause ) ; timer.start ( ) ; The speed pause variable represent applet parameter ; configure page , 100 1900 respectively , first timer event occur approximately 1.9 second , recur every 0.1 second . By specify second argument Timer constructor , TumbleItem specify action listener timer event . After start timer , TumbleItem begin load series image background thread . Meanwhile , timer event begin occur , cause actionPerformed method execute : public void actionPerformed ( ActionEvent e ) { //If still load , ca n't animate . ( ! worker.isDone ( ) ) { return ; } loopslot++ ; ( loopslot > = nimgs ) { loopslot = 0 ; += offset ; ( < 0 ) { = width - maxWidth ; } else ( + maxWidth > width ) { = 0 ; } } animator.repaint ( ) ; ( loopslot == nimgs - 1 ) { timer.restart ( ) ; } } Until image load , worker.isDone return false , timer event effectively ignore . The first part event handle code simply set value employ animation control 's paintComponent method : loopslot ( index next graphic animation ) ( horizontal offset next graphic ) . Eventually , loopslot reach end image array start . When happen , code end actionPerformed restarts timer . Doing cause short delay animation sequence begin .