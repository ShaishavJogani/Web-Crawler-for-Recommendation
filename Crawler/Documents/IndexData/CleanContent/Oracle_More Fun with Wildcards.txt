In section , 'll consider advanced us wildcards . We 've see several example bound wildcards useful read data structure . Now consider inverse , write-only data structure . The interface Sink simple example sort . interface Sink < T > { flush ( T ) ; } We imagine use demonstrate code . The method writeAll ( ) design flush element collection coll sink snk , return last element flush . public static < T > T writeAll ( Collection < T > coll , Sink < T > snk ) { T last ; ( T : coll ) { last = ; snk.flush ( last ) ; } return last ; } ... Sink < Object > ; Collection < String > c ; String str = writeAll ( c , ) ; // Illegal call . As write , call writeAll ( ) illegal , valid type argument infer ; neither String Object appropriate type T , Collection element Sink element must type . We fix error modify signature writeAll ( ) show , use wildcard . public static < T > T writeAll ( Collection < ? extends T > , Sink < T > ) { ... } ... // Call OK , wrong return type . String str = writeAll ( c , ) ; The call legal , assignment erroneous , since return type infer Object T match element type , Object . The solution use form bounded wildcard n't see yet : wildcards low bound . The syntax ? super T denote unknown type supertype T ( T ; remember supertype relation reflexive ) . It dual bounded wildcards 've use , use ? extends T denote unknown type subtype T. public static < T > T writeAll ( Collection < T > coll , Sink < ? super T > snk ) { ... } String str = writeAll ( c , ) ; // Yes ! Using syntax , call legal , inferred type String , desire . Now let 's turn realistic example . A java.util.TreeSet < E > represent tree element type E order . One way construct TreeSet pass Comparator object constructor . That comparator use sort element TreeSet accord desire ordering . TreeSet ( Comparator < E > c ) The Comparator interface essentially : interface Comparator < T > { int compare ( T fst , T snd ) ; } Suppose want create TreeSet < String > pas suitable comparator , We need pass Comparator compare Strings . This Comparator < String > , Comparator < Object > well . However , wo n't able invoke constructor give Comparator < Object > . We use low bound wildcard get flexibility want : TreeSet ( Comparator < ? super E > c ) This code allow applicable comparator use . As final example use low bound wildcards , let look method Collections.max ( ) , return maximal element collection pass argument . Now , order max ( ) work , element collection pass must implement Comparable . Furthermore , must comparable . A first attempt generifying method signature yield : public static < T extend Comparable < T > > T max ( Collection < T > coll ) That , method take collection type T comparable , return element type . However , code turn restrictive . To see , consider type comparable arbitrary object : class Foo implement Comparable < Object > { ... } Collection < Foo > cf = ... ; Collections.max ( cf ) ; // Should work . Every element cf comparable every element cf , since every element Foo , comparable object , particular another Foo . However , use signature , find call reject . The inferred type must Foo , Foo implement Comparable < Foo > . It n't necessary T comparable exactly . All 's require T comparable one supertypes . This give u : public static < T extend Comparable < ? super T > > T max ( Collection < T > coll ) Note actual signature Collections.max ( ) involved . We return next section , Converting Legacy Code Use Generics . This reason applies almost usage Comparable intend work arbitrary type : You always want use Comparable < ? super T > . In general , API use type parameter T argument , us take advantage low bound wildcards ( ? super T ) . Conversely , API return T , 'll give client flexibility use upper bound wildcards ( ? extends T ) . Wildcard Capture It pretty clear give : Set < ? > unknownSet = new HashSet < String > ( ) ; ... /* Add element Set s. */ public static < T > void addToSet ( Set < T > , T ) { ... } The call illegal . addToSet ( unknownSet , `` abc '' ) ; // Illegal . It make difference actual set pass set string ; matter expression pass argument set unknown type , guarantee set string , type particular . Now , consider following code : class Collections { ... < T > public static Set < T > unmodifiableSet ( Set < T > set ) { ... } } ... Set < ? > = Collections.unmodifiableSet ( unknownSet ) ; // This work ! Why ? It seem allow ; yet , look specific call , perfectly safe permit . After , unmodifiableSet ( ) work kind Set , regardless element type . Because situation arise relatively frequently , special rule allow code specific circumstance code prove safe . This rule , know wildcard capture , allow compiler infer unknown type wildcard type argument generic method .