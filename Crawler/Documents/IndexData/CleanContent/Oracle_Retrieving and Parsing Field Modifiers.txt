There several modifier may part field declaration : Access modifier : public , protect , private Field-specific modifier govern runtime behavior : transient volatile Modifier restrict one instance : static Modifier prohibit value modification : final Annotations The method Field.getModifiers ( ) use return integer represent set declared modifier field . The bit represent modifier integer define java.lang.reflect.Modifier . The FieldModifierSpy example illustrate search field give modifier . It also determine whether located field synthetic ( compiler-generated ) enum constant invoke Field.isSynthetic ( ) Field.isEnumCostant ( ) respectively . import java.lang.reflect.Field ; import java.lang.reflect.Modifier ; import static java.lang.System.out ; enum Spy { BLACK , WHITE } public class FieldModifierSpy { volatile int share ; int instance ; class Inner { } public static void main ( String ... args ) { try { Class < ? > c = Class.forName ( args [ 0 ] ) ; int searchMods = 0x0 ; ( int = 1 ; < args.length ; i++ ) { searchMods |= modifierFromString ( args [ ] ) ; } Field [ ] flds = c.getDeclaredFields ( ) ; out.format ( `` Fields Class ' % ' contain modifier : % % n '' , c.getName ( ) , Modifier.toString ( searchMods ) ) ; boolean find = false ; ( Field f : flds ) { int foundMods = f.getModifiers ( ) ; // Require requested modifier present ( ( foundMods & searchMods ) == searchMods ) { out.format ( `` % -8s [ synthetic= % -5b enum_constant= % -5b ] % n '' , f.getName ( ) , f.isSynthetic ( ) , f.isEnumConstant ( ) ) ; find = true ; } } ( ! find ) { out.format ( `` No matching field % n '' ) ; } // production code handle exception gracefully } catch ( ClassNotFoundException x ) { x.printStackTrace ( ) ; } } private static int modifierFromString ( String ) { int = 0x0 ; ( `` public '' .equals ( ) ) |= Modifier.PUBLIC ; else ( `` protect '' .equals ( ) ) |= Modifier.PROTECTED ; else ( `` private '' .equals ( ) ) |= Modifier.PRIVATE ; else ( `` static '' .equals ( ) ) |= Modifier.STATIC ; else ( `` final '' .equals ( ) ) |= Modifier.FINAL ; else ( `` transient '' .equals ( ) ) |= Modifier.TRANSIENT ; else ( `` volatile '' .equals ( ) ) |= Modifier.VOLATILE ; return ; } } Sample output follow : $ java FieldModifierSpy FieldModifierSpy volatile Fields Class 'FieldModifierSpy ' contain modifier : volatile share [ synthetic=false enum_constant=false ] $ java FieldModifierSpy Spy public Fields Class 'Spy ' contain modifier : public BLACK [ synthetic=false enum_constant=true ] WHITE [ synthetic=false enum_constant=true ] $ java FieldModifierSpy FieldModifierSpy\ $ Inner final Fields Class 'FieldModifierSpy $ Inner ' contain modifier : final $ 0 [ synthetic=true enum_constant=false ] $ java FieldModifierSpy Spy private static final Fields Class 'Spy ' contain modifier : private static final $ VALUES [ synthetic=true enum_constant=false ] Notice field report even though declare original code . This compiler generate synthetic field need runtime . To test whether field synthetic , example invoke Field.isSynthetic ( ) . The set synthetic field compiler-dependent ; however commonly use field include $ 0 inner class ( i.e . nested class static member class ) reference outermost enclose class $ VALUES use enums implement implicitly define static method value ( ) . The name synthetic class member specify may compiler implementation release . These synthetic field include array return Class.getDeclaredFields ( ) identify Class.getField ( ) since synthetic member typically public . Because Field implement interface java.lang.reflect.AnnotatedElement , possible retrieve runtime annotation java.lang.annotation.RetentionPolicy.RUNTIME . For example obtain annotation see section Examining Class Modifiers Types .