Quantifiers allow specify number occurrence match . For convenience , three section Pattern API specification describe greedy , reluctant , possessive quantifier present . At first glance may appear quantifier X ? , X ? ? X ? + exactly thing , since promise match `` X , '' . There subtle implementation difference explain near end section . Greedy Reluctant Possessive Meaning X ? X ? ? X ? + X , X* X* ? X*+ X , zero time X+ X+ ? X++ X , one time X { n } X { n } ? X { n } + X , exactly n time X { n , } X { n , } ? X { n , } + X , least n time X { n , } X { n , } ? X { n , } + X , least n time Let 's start look greedy quantifier create three different regular expression : letter `` '' follow either ? , * , + . Let 's see happen expression test empty input string `` '' : Enter regex : ? Enter input string search : I find text `` '' start index 0 end index 0 . Enter regex : a* Enter input string search : I find text `` '' start index 0 end index 0 . Enter regex : a+ Enter input string search : No match find . Zero-Length Matches In example , match successful first two case expression ? a* allow zero occurrence letter . You 'll also notice start end index zero , unlike example 've see far . The empty input string `` '' length , test simply match nothing index 0 . Matches sort know zero-length match . A zero-length match occur several case : empty input string , beginning input string , last character input string , two character input string . Zero-length match easily identifiable always start end index position . Let 's explore zero-length match example . Change input string single letter `` '' 'll notice something interesting : Enter regex : ? Enter input string search : I find text `` '' start index 0 end index 1 . I find text `` '' start index 1 end index 1 . Enter regex : a* Enter input string search : I find text `` '' start index 0 end index 1 . I find text `` '' start index 1 end index 1 . Enter regex : a+ Enter input string search : I find text `` '' start index 0 end index 1 . All three quantifier find letter `` '' , first two also find zero-length match index 1 ; , last character input string . Remember , matcher see character `` '' sit cell index 0 index 1 , test harness loop longer find match . Depending quantifier use , presence `` nothing '' index last character may may trigger match . Now change input string letter `` '' five time row 'll get following : Enter regex : ? Enter input string search : aaaaa I find text `` '' start index 0 end index 1 . I find text `` '' start index 1 end index 2 . I find text `` '' start index 2 end index 3 . I find text `` '' start index 3 end index 4 . I find text `` '' start index 4 end index 5 . I find text `` '' start index 5 end index 5 . Enter regex : a* Enter input string search : aaaaa I find text `` aaaaa '' start index 0 end index 5 . I find text `` '' start index 5 end index 5 . Enter regex : a+ Enter input string search : aaaaa I find text `` aaaaa '' start index 0 end index 5 . The expression ? find individual match character , since match `` '' appear zero one time . The expression a* find two separate match : letter `` '' 's first match , zero-length match last character index 5 . And finally , a+ match occurrence letter `` '' , ignore presence `` nothing '' last index . At point , might wonder result would first two quantifier encounter letter `` '' . For example , happen encounter letter `` b '' , `` ababaaaab '' ? Let 's find : Enter regex : ? Enter input string search : ababaaaab I find text `` '' start index 0 end index 1 . I find text `` '' start index 1 end index 1 . I find text `` '' start index 2 end index 3 . I find text `` '' start index 3 end index 3 . I find text `` '' start index 4 end index 5 . I find text `` '' start index 5 end index 6 . I find text `` '' start index 6 end index 7 . I find text `` '' start index 7 end index 8 . I find text `` '' start index 8 end index 8 . I find text `` '' start index 9 end index 9 . Enter regex : a* Enter input string search : ababaaaab I find text `` '' start index 0 end index 1 . I find text `` '' start index 1 end index 1 . I find text `` '' start index 2 end index 3 . I find text `` '' start index 3 end index 3 . I find text `` aaaa '' start index 4 end index 8 . I find text `` '' start index 8 end index 8 . I find text `` '' start index 9 end index 9 . Enter regex : a+ Enter input string search : ababaaaab I find text `` '' start index 0 end index 1 . I find text `` '' start index 2 end index 3 . I find text `` aaaa '' start index 4 end index 8 . Even though letter `` b '' appear cell 1 , 3 , 8 , output report zero-length match location . The regular expression ? specifically look letter `` b '' ; 's merely look presence ( lack thereof ) letter `` '' . If quantifier allow match `` '' zero time , anything input string 's `` '' show zero-length match . The remain 's match accord rule discuss previous example . To match pattern exactly n number time , simply specify number inside set brace : Enter regex : { 3 } Enter input string search : aa No match find . Enter regex : { 3 } Enter input string search : aaa I find text `` aaa '' start index 0 end index 3 . Enter regex : { 3 } Enter input string search : aaaa I find text `` aaa '' start index 0 end index 3 . Here , regular expression { 3 } search three occurrence letter `` '' row . The first test fails input string enough 's match . The second test contain exactly 3 's input string , trigger match . The third test also trigger match exactly 3 's beginning input string . Anything follow irrelevant first match . If pattern appear point , would trigger subsequent match : Enter regex : { 3 } Enter input string search : aaaaaaaaa I find text `` aaa '' start index 0 end index 3 . I find text `` aaa '' start index 3 end index 6 . I find text `` aaa '' start index 6 end index 9 . To require pattern appear least n time , add comma number : Enter regex : { 3 , } Enter input string search : aaaaaaaaa I find text `` aaaaaaaaa '' start index 0 end index 9 . With input string , test find one match , 9 's row satisfy need `` least '' 3 's . Finally , specify upper limit number occurances , add second number inside brace : Enter regex : { 3,6 } // find least 3 ( 6 ) 's row Enter input string search : aaaaaaaaa I find text `` aaaaaa '' start index 0 end index 6 . I find text `` aaa '' start index 6 end index 9 . Here first match force stop upper limit 6 character . The second match include whatever leave , happen three 's â€” mimimum number character allow match . If input string one character shorter , would second match since two 's would remain . Capturing Groups Character Classes Quantifiers Until , 've test quantifier input string contain one character . In fact , quantifier attach one character time , regular expression `` abc+ '' would mean `` , follow b , follow c one time '' . It would mean `` abc '' one time . However , quantifier also attach Character Classes Capturing Groups , [ abc ] + ( b c , one time ) ( abc ) + ( group `` abc '' , one time ) . Let 's illustrate specify group ( dog ) , three time row . Enter regex : ( dog ) { 3 } Enter input string search : dogdogdogdogdogdog I find text `` dogdogdog '' start index 0 end index 9 . I find text `` dogdogdog '' start index 9 end index 18 . Enter regex : dog { 3 } Enter input string search : dogdogdogdogdogdog No match find . Here first example find three match , since quantifier apply entire capturing group . Remove parenthesis , however , match fail quantifier { 3 } apply letter `` g '' . Similarly , apply quantifier entire character class : Enter regex : [ abc ] { 3 } Enter input string search : abccabaaaccbbbc I find text `` abc '' start index 0 end index 3 . I find text `` cab '' start index 3 end index 6 . I find text `` aaa '' start index 6 end index 9 . I find text `` ccb '' start index 9 end index 12 . I find text `` bbc '' start index 12 end index 15 . Enter regex : abc { 3 } Enter input string search : abccabaaaccbbbc No match find . Here quantifier { 3 } applies entire character class first example , letter `` c '' second . Differences Among Greedy , Reluctant , Possessive Quantifiers There subtle difference among greedy , reluctant , possessive quantifier . Greedy quantifier consider `` greedy '' force matcher read , eat , entire input string prior attempt first match . If first match attempt ( entire input string ) fail , matcher back input string one character try , repeat process match find character leave back . Depending quantifier use expression , last thing try match 1 0 character . The reluctant quantifier , however , take opposite approach : They start beginning input string , reluctantly eat one character time look match . The last thing try entire input string . Finally , possessive quantifier always eat entire input string , try ( ) match . Unlike greedy quantifier , possessive quantifier never back , even would allow overall match succeed . To illustrate , consider input string xfooxxxxxxfoo . Enter regex : . *foo // greedy quantifier Enter input string search : xfooxxxxxxfoo I find text `` xfooxxxxxxfoo '' start index 0 end index 13 . Enter regex : . * ? foo // reluctant quantifier Enter input string search : xfooxxxxxxfoo I find text `` xfoo '' start index 0 end index 4 . I find text `` xxxxxxfoo '' start index 4 end index 13 . Enter regex : . *+foo // possessive quantifier Enter input string search : xfooxxxxxxfoo No match find . The first example use greedy quantifier . * find `` anything '' , zero time , follow letter `` f '' `` '' `` '' . Because quantifier greedy , . * portion expression first eat entire input string . At point , overall expression succeed , last three letter ( `` f '' `` '' `` '' ) already consume . So matcher slowly back one letter time rightmost occurrence `` foo '' regurgitate , point match succeed search end . The second example , however , reluctant , start first consume `` nothing '' . Because `` foo '' n't appear beginning string , 's force swallow first letter ( `` x '' ) , trigger first match 0 4 . Our test harness continue process input string exhaust . It find another match 4 13 . The third example fails find match quantifier possessive . In case , entire input string consume . *+ , leave nothing leave satisfy `` foo '' end expression . Use possessive quantifier situation want seize something without ever back ; outperform equivalent greedy quantifier case match immediately find .